(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],3:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],4:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)
},{"base64-js":2,"buffer":4,"ieee754":7}],5:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":9}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],7:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],8:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],9:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],10:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],11:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":13}],12:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":13}],13:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],14:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":15}],15:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":17,"./_stream_writable":19,"core-util-is":5,"inherits":8,"process-nextick-args":12}],16:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":18,"core-util-is":5,"inherits":8}],17:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":15,"./internal/streams/BufferList":20,"./internal/streams/destroy":21,"./internal/streams/stream":22,"_process":13,"core-util-is":5,"events":6,"inherits":8,"isarray":10,"process-nextick-args":12,"safe-buffer":28,"string_decoder/":23,"util":3}],18:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":15,"core-util-is":5,"inherits":8}],19:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":15,"./internal/streams/destroy":21,"./internal/streams/stream":22,"_process":13,"core-util-is":5,"inherits":8,"process-nextick-args":12,"safe-buffer":28,"timers":31,"util-deprecate":32}],20:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":28,"util":3}],21:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":12}],22:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":6}],23:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":28}],24:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":25}],25:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":15,"./lib/_stream_passthrough.js":16,"./lib/_stream_readable.js":17,"./lib/_stream_transform.js":18,"./lib/_stream_writable.js":19}],26:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":25}],27:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":19}],28:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":4}],29:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":6,"inherits":8,"readable-stream/duplex.js":14,"readable-stream/passthrough.js":24,"readable-stream/readable.js":25,"readable-stream/transform.js":26,"readable-stream/writable.js":27}],30:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23,"safe-buffer":28}],31:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":13,"timers":31}],32:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],33:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],34:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":33,"_process":13,"inherits":8}],35:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":74}],36:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":75}],37:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/is-iterable"), __esModule: true };
},{"core-js/library/fn/is-iterable":76}],38:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/map"), __esModule: true };
},{"core-js/library/fn/map":77}],39:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/epsilon"), __esModule: true };
},{"core-js/library/fn/number/epsilon":78}],40:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":79}],41:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":80}],42:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-properties"), __esModule: true };
},{"core-js/library/fn/object/define-properties":81}],43:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":82}],44:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/freeze"), __esModule: true };
},{"core-js/library/fn/object/freeze":83}],45:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":84}],46:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":85}],47:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":86}],48:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":87}],49:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/string/from-code-point"), __esModule: true };
},{"core-js/library/fn/string/from-code-point":88}],50:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":89}],51:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":90}],52:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],53:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
},{"../core-js/object/define-property":43}],54:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};
},{"../core-js/object/define-property":43}],55:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _setPrototypeOf = require("../core-js/object/set-prototype-of");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = require("../core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
},{"../core-js/object/create":41,"../core-js/object/set-prototype-of":47,"../helpers/typeof":58}],56:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};
},{"../helpers/typeof":58}],57:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _isIterable2 = require("../core-js/is-iterable");

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = require("../core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
},{"../core-js/get-iterator":36,"../core-js/is-iterable":37}],58:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":50,"../core-js/symbol/iterator":51}],59:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":207}],60:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],61:[function(require,module,exports){
/* Copyright 2013 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Bit reading helpers
*/

var BROTLI_READ_SIZE = 4096;
var BROTLI_IBUF_SIZE =  (2 * BROTLI_READ_SIZE + 32);
var BROTLI_IBUF_MASK =  (2 * BROTLI_READ_SIZE - 1);

var kBitMask = new Uint32Array([
  0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767,
  65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215
]);

/* Input byte buffer, consist of a ringbuffer and a "slack" region where */
/* bytes from the start of the ringbuffer are copied. */
function BrotliBitReader(input) {
  this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
  this.input_ = input;    /* input callback */
  
  this.reset();
}

BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;

BrotliBitReader.prototype.reset = function() {
  this.buf_ptr_ = 0;      /* next input will write here */
  this.val_ = 0;          /* pre-fetched bits */
  this.pos_ = 0;          /* byte position in stream */
  this.bit_pos_ = 0;      /* current bit-reading position in val_ */
  this.bit_end_pos_ = 0;  /* bit-reading end position from LSB of val_ */
  this.eos_ = 0;          /* input stream is finished */
  
  this.readMoreInput();
  for (var i = 0; i < 4; i++) {
    this.val_ |= this.buf_[this.pos_] << (8 * i);
    ++this.pos_;
  }
  
  return this.bit_end_pos_ > 0;
};

/* Fills up the input ringbuffer by calling the input callback.

   Does nothing if there are at least 32 bytes present after current position.

   Returns 0 if either:
    - the input callback returned an error, or
    - there is no more input and the position is past the end of the stream.

   After encountering the end of the input stream, 32 additional zero bytes are
   copied to the ringbuffer, therefore it is safe to call this function after
   every 32 bytes of input is read.
*/
BrotliBitReader.prototype.readMoreInput = function() {
  if (this.bit_end_pos_ > 256) {
    return;
  } else if (this.eos_) {
    if (this.bit_pos_ > this.bit_end_pos_)
      throw new Error('Unexpected end of input ' + this.bit_pos_ + ' ' + this.bit_end_pos_);
  } else {
    var dst = this.buf_ptr_;
    var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
    if (bytes_read < 0) {
      throw new Error('Unexpected end of input');
    }
    
    if (bytes_read < BROTLI_READ_SIZE) {
      this.eos_ = 1;
      /* Store 32 bytes of zero after the stream end. */
      for (var p = 0; p < 32; p++)
        this.buf_[dst + bytes_read + p] = 0;
    }
    
    if (dst === 0) {
      /* Copy the head of the ringbuffer to the slack region. */
      for (var p = 0; p < 32; p++)
        this.buf_[(BROTLI_READ_SIZE << 1) + p] = this.buf_[p];

      this.buf_ptr_ = BROTLI_READ_SIZE;
    } else {
      this.buf_ptr_ = 0;
    }
    
    this.bit_end_pos_ += bytes_read << 3;
  }
};

/* Guarantees that there are at least 24 bits in the buffer. */
BrotliBitReader.prototype.fillBitWindow = function() {    
  while (this.bit_pos_ >= 8) {
    this.val_ >>>= 8;
    this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
    ++this.pos_;
    this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
    this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
  }
};

/* Reads the specified number of bits from Read Buffer. */
BrotliBitReader.prototype.readBits = function(n_bits) {
  if (32 - this.bit_pos_ < n_bits) {
    this.fillBitWindow();
  }
  
  var val = ((this.val_ >>> this.bit_pos_) & kBitMask[n_bits]);
  this.bit_pos_ += n_bits;
  return val;
};

module.exports = BrotliBitReader;

},{}],62:[function(require,module,exports){
/* Copyright 2013 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Lookup table to map the previous two bytes to a context id.

   There are four different context modeling modes defined here:
     CONTEXT_LSB6: context id is the least significant 6 bits of the last byte,
     CONTEXT_MSB6: context id is the most significant 6 bits of the last byte,
     CONTEXT_UTF8: second-order context model tuned for UTF8-encoded text,
     CONTEXT_SIGNED: second-order context model tuned for signed integers.

   The context id for the UTF8 context model is calculated as follows. If p1
   and p2 are the previous two bytes, we calcualte the context as

     context = kContextLookup[p1] | kContextLookup[p2 + 256].

   If the previous two bytes are ASCII characters (i.e. < 128), this will be
   equivalent to

     context = 4 * context1(p1) + context2(p2),

   where context1 is based on the previous byte in the following way:

     0  : non-ASCII control
     1  : \t, \n, \r
     2  : space
     3  : other punctuation
     4  : " '
     5  : %
     6  : ( < [ {
     7  : ) > ] }
     8  : , ; :
     9  : .
     10 : =
     11 : number
     12 : upper-case vowel
     13 : upper-case consonant
     14 : lower-case vowel
     15 : lower-case consonant

   and context2 is based on the second last byte:

     0 : control, space
     1 : punctuation
     2 : upper-case letter, number
     3 : lower-case letter

   If the last byte is ASCII, and the second last byte is not (in a valid UTF8
   stream it will be a continuation byte, value between 128 and 191), the
   context is the same as if the second last byte was an ASCII control or space.

   If the last byte is a UTF8 lead byte (value >= 192), then the next byte will
   be a continuation byte and the context id is 2 or 3 depending on the LSB of
   the last byte and to a lesser extent on the second last byte if it is ASCII.

   If the last byte is a UTF8 continuation byte, the second last byte can be:
     - continuation byte: the next byte is probably ASCII or lead byte (assuming
       4-byte UTF8 characters are rare) and the context id is 0 or 1.
     - lead byte (192 - 207): next byte is ASCII or lead byte, context is 0 or 1
     - lead byte (208 - 255): next byte is continuation byte, context is 2 or 3

   The possible value combinations of the previous two bytes, the range of
   context ids and the type of the next byte is summarized in the table below:

   |--------\-----------------------------------------------------------------|
   |         \                         Last byte                              |
   | Second   \---------------------------------------------------------------|
   | last byte \    ASCII            |   cont. byte        |   lead byte      |
   |            \   (0-127)          |   (128-191)         |   (192-)         |
   |=============|===================|=====================|==================|
   |  ASCII      | next: ASCII/lead  |  not valid          |  next: cont.     |
   |  (0-127)    | context: 4 - 63   |                     |  context: 2 - 3  |
   |-------------|-------------------|---------------------|------------------|
   |  cont. byte | next: ASCII/lead  |  next: ASCII/lead   |  next: cont.     |
   |  (128-191)  | context: 4 - 63   |  context: 0 - 1     |  context: 2 - 3  |
   |-------------|-------------------|---------------------|------------------|
   |  lead byte  | not valid         |  next: ASCII/lead   |  not valid       |
   |  (192-207)  |                   |  context: 0 - 1     |                  |
   |-------------|-------------------|---------------------|------------------|
   |  lead byte  | not valid         |  next: cont.        |  not valid       |
   |  (208-)     |                   |  context: 2 - 3     |                  |
   |-------------|-------------------|---------------------|------------------|

   The context id for the signed context mode is calculated as:

     context = (kContextLookup[512 + p1] << 3) | kContextLookup[512 + p2].

   For any context modeling modes, the context ids can be calculated by |-ing
   together two lookups from one table using context model dependent offsets:

     context = kContextLookup[offset1 + p1] | kContextLookup[offset2 + p2].

   where offset1 and offset2 are dependent on the context mode.
*/

var CONTEXT_LSB6         = 0;
var CONTEXT_MSB6         = 1;
var CONTEXT_UTF8         = 2;
var CONTEXT_SIGNED       = 3;

/* Common context lookup table for all context modes. */
exports.lookup = new Uint8Array([
  /* CONTEXT_UTF8, last byte. */
  /* ASCII range. */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  4,  0,  0,  4,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   8, 12, 16, 12, 12, 20, 12, 16, 24, 28, 12, 12, 32, 12, 36, 12,
  44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 32, 32, 24, 40, 28, 12,
  12, 48, 52, 52, 52, 48, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48,
  52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 24, 12, 28, 12, 12,
  12, 56, 60, 60, 60, 56, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56,
  60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 24, 12, 28, 12,  0,
  /* UTF8 continuation byte range. */
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  /* UTF8 lead byte range. */
  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
  /* CONTEXT_UTF8 second last byte. */
  /* ASCII range. */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,
  1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1,
  1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 0,
  /* UTF8 continuation byte range. */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  /* UTF8 lead byte range. */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  /* CONTEXT_SIGNED, second last byte. */
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,
  /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
   0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
  40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
  40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
  40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
  48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 56,
  /* CONTEXT_LSB6, last byte. */
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
  /* CONTEXT_MSB6, last byte. */
   0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,
   4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,
   8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11,
  12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15,
  16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19,
  20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23,
  24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27,
  28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31,
  32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35,
  36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39,
  40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43,
  44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47,
  48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51,
  52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55,
  56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59,
  60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63,
  /* CONTEXT_{M,L}SB6, second last byte, */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
]);

exports.lookupOffsets = new Uint16Array([
  /* CONTEXT_LSB6 */
  1024, 1536,
  /* CONTEXT_MSB6 */
  1280, 1536,
  /* CONTEXT_UTF8 */
  0, 256,
  /* CONTEXT_SIGNED */
  768, 512,
]);

},{}],63:[function(require,module,exports){
/* Copyright 2013 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

var BrotliInput = require('./streams').BrotliInput;
var BrotliOutput = require('./streams').BrotliOutput;
var BrotliBitReader = require('./bit_reader');
var BrotliDictionary = require('./dictionary');
var HuffmanCode = require('./huffman').HuffmanCode;
var BrotliBuildHuffmanTable = require('./huffman').BrotliBuildHuffmanTable;
var Context = require('./context');
var Prefix = require('./prefix');
var Transform = require('./transform');

var kDefaultCodeLength = 8;
var kCodeLengthRepeatCode = 16;
var kNumLiteralCodes = 256;
var kNumInsertAndCopyCodes = 704;
var kNumBlockLengthCodes = 26;
var kLiteralContextBits = 6;
var kDistanceContextBits = 2;

var HUFFMAN_TABLE_BITS = 8;
var HUFFMAN_TABLE_MASK = 0xff;
/* Maximum possible Huffman table size for an alphabet size of 704, max code
 * length 15 and root table bits 8. */
var HUFFMAN_MAX_TABLE_SIZE = 1080;

var CODE_LENGTH_CODES = 18;
var kCodeLengthCodeOrder = new Uint8Array([
  1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15,
]);

var NUM_DISTANCE_SHORT_CODES = 16;
var kDistanceShortCodeIndexOffset = new Uint8Array([
  3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2
]);

var kDistanceShortCodeValueOffset = new Int8Array([
  0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3
]);

var kMaxHuffmanTableSize = new Uint16Array([
  256, 402, 436, 468, 500, 534, 566, 598, 630, 662, 694, 726, 758, 790, 822,
  854, 886, 920, 952, 984, 1016, 1048, 1080
]);

function DecodeWindowBits(br) {
  var n;
  if (br.readBits(1) === 0) {
    return 16;
  }
  
  n = br.readBits(3);
  if (n > 0) {
    return 17 + n;
  }
  
  n = br.readBits(3);
  if (n > 0) {
    return 8 + n;
  }
  
  return 17;
}

/* Decodes a number in the range [0..255], by reading 1 - 11 bits. */
function DecodeVarLenUint8(br) {
  if (br.readBits(1)) {
    var nbits = br.readBits(3);
    if (nbits === 0) {
      return 1;
    } else {
      return br.readBits(nbits) + (1 << nbits);
    }
  }
  return 0;
}

function MetaBlockLength() {
  this.meta_block_length = 0;
  this.input_end = 0;
  this.is_uncompressed = 0;
  this.is_metadata = false;
}

function DecodeMetaBlockLength(br) {
  var out = new MetaBlockLength;  
  var size_nibbles;
  var size_bytes;
  var i;
  
  out.input_end = br.readBits(1);
  if (out.input_end && br.readBits(1)) {
    return out;
  }
  
  size_nibbles = br.readBits(2) + 4;
  if (size_nibbles === 7) {
    out.is_metadata = true;
    
    if (br.readBits(1) !== 0)
      throw new Error('Invalid reserved bit');
    
    size_bytes = br.readBits(2);
    if (size_bytes === 0)
      return out;
    
    for (i = 0; i < size_bytes; i++) {
      var next_byte = br.readBits(8);
      if (i + 1 === size_bytes && size_bytes > 1 && next_byte === 0)
        throw new Error('Invalid size byte');
      
      out.meta_block_length |= next_byte << (i * 8);
    }
  } else {
    for (i = 0; i < size_nibbles; ++i) {
      var next_nibble = br.readBits(4);
      if (i + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)
        throw new Error('Invalid size nibble');
      
      out.meta_block_length |= next_nibble << (i * 4);
    }
  }
  
  ++out.meta_block_length;
  
  if (!out.input_end && !out.is_metadata) {
    out.is_uncompressed = br.readBits(1);
  }
  
  return out;
}

/* Decodes the next Huffman code from bit-stream. */
function ReadSymbol(table, index, br) {
  var start_index = index;
  
  var nbits;
  br.fillBitWindow();
  index += (br.val_ >>> br.bit_pos_) & HUFFMAN_TABLE_MASK;
  nbits = table[index].bits - HUFFMAN_TABLE_BITS;
  if (nbits > 0) {
    br.bit_pos_ += HUFFMAN_TABLE_BITS;
    index += table[index].value;
    index += (br.val_ >>> br.bit_pos_) & ((1 << nbits) - 1);
  }
  br.bit_pos_ += table[index].bits;
  return table[index].value;
}

function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
  var symbol = 0;
  var prev_code_len = kDefaultCodeLength;
  var repeat = 0;
  var repeat_code_len = 0;
  var space = 32768;
  
  var table = [];
  for (var i = 0; i < 32; i++)
    table.push(new HuffmanCode(0, 0));
  
  BrotliBuildHuffmanTable(table, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);

  while (symbol < num_symbols && space > 0) {
    var p = 0;
    var code_len;
    
    br.readMoreInput();
    br.fillBitWindow();
    p += (br.val_ >>> br.bit_pos_) & 31;
    br.bit_pos_ += table[p].bits;
    code_len = table[p].value & 0xff;
    if (code_len < kCodeLengthRepeatCode) {
      repeat = 0;
      code_lengths[symbol++] = code_len;
      if (code_len !== 0) {
        prev_code_len = code_len;
        space -= 32768 >> code_len;
      }
    } else {
      var extra_bits = code_len - 14;
      var old_repeat;
      var repeat_delta;
      var new_len = 0;
      if (code_len === kCodeLengthRepeatCode) {
        new_len = prev_code_len;
      }
      if (repeat_code_len !== new_len) {
        repeat = 0;
        repeat_code_len = new_len;
      }
      old_repeat = repeat;
      if (repeat > 0) {
        repeat -= 2;
        repeat <<= extra_bits;
      }
      repeat += br.readBits(extra_bits) + 3;
      repeat_delta = repeat - old_repeat;
      if (symbol + repeat_delta > num_symbols) {
        throw new Error('[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols');
      }
      
      for (var x = 0; x < repeat_delta; x++)
        code_lengths[symbol + x] = repeat_code_len;
      
      symbol += repeat_delta;
      
      if (repeat_code_len !== 0) {
        space -= repeat_delta << (15 - repeat_code_len);
      }
    }
  }
  if (space !== 0) {
    throw new Error("[ReadHuffmanCodeLengths] space = " + space);
  }
  
  for (; symbol < num_symbols; symbol++)
    code_lengths[symbol] = 0;
}

function ReadHuffmanCode(alphabet_size, tables, table, br) {
  var table_size = 0;
  var simple_code_or_skip;
  var code_lengths = new Uint8Array(alphabet_size);
  
  br.readMoreInput();
  
  /* simple_code_or_skip is used as follows:
     1 for simple code;
     0 for no skipping, 2 skips 2 code lengths, 3 skips 3 code lengths */
  simple_code_or_skip = br.readBits(2);
  if (simple_code_or_skip === 1) {
    /* Read symbols, codes & code lengths directly. */
    var i;
    var max_bits_counter = alphabet_size - 1;
    var max_bits = 0;
    var symbols = new Int32Array(4);
    var num_symbols = br.readBits(2) + 1;
    while (max_bits_counter) {
      max_bits_counter >>= 1;
      ++max_bits;
    }

    for (i = 0; i < num_symbols; ++i) {
      symbols[i] = br.readBits(max_bits) % alphabet_size;
      code_lengths[symbols[i]] = 2;
    }
    code_lengths[symbols[0]] = 1;
    switch (num_symbols) {
      case 1:
        break;
      case 3:
        if ((symbols[0] === symbols[1]) ||
            (symbols[0] === symbols[2]) ||
            (symbols[1] === symbols[2])) {
          throw new Error('[ReadHuffmanCode] invalid symbols');
        }
        break;
      case 2:
        if (symbols[0] === symbols[1]) {
          throw new Error('[ReadHuffmanCode] invalid symbols');
        }
        
        code_lengths[symbols[1]] = 1;
        break;
      case 4:
        if ((symbols[0] === symbols[1]) ||
            (symbols[0] === symbols[2]) ||
            (symbols[0] === symbols[3]) ||
            (symbols[1] === symbols[2]) ||
            (symbols[1] === symbols[3]) ||
            (symbols[2] === symbols[3])) {
          throw new Error('[ReadHuffmanCode] invalid symbols');
        }
        
        if (br.readBits(1)) {
          code_lengths[symbols[2]] = 3;
          code_lengths[symbols[3]] = 3;
        } else {
          code_lengths[symbols[0]] = 2;
        }
        break;
    }
  } else {  /* Decode Huffman-coded code lengths. */
    var i;
    var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
    var space = 32;
    var num_codes = 0;
    /* Static Huffman code for the code length code lengths */
    var huff = [
      new HuffmanCode(2, 0), new HuffmanCode(2, 4), new HuffmanCode(2, 3), new HuffmanCode(3, 2), 
      new HuffmanCode(2, 0), new HuffmanCode(2, 4), new HuffmanCode(2, 3), new HuffmanCode(4, 1),
      new HuffmanCode(2, 0), new HuffmanCode(2, 4), new HuffmanCode(2, 3), new HuffmanCode(3, 2), 
      new HuffmanCode(2, 0), new HuffmanCode(2, 4), new HuffmanCode(2, 3), new HuffmanCode(4, 5)
    ];
    for (i = simple_code_or_skip; i < CODE_LENGTH_CODES && space > 0; ++i) {
      var code_len_idx = kCodeLengthCodeOrder[i];
      var p = 0;
      var v;
      br.fillBitWindow();
      p += (br.val_ >>> br.bit_pos_) & 15;
      br.bit_pos_ += huff[p].bits;
      v = huff[p].value;
      code_length_code_lengths[code_len_idx] = v;
      if (v !== 0) {
        space -= (32 >> v);
        ++num_codes;
      }
    }
    
    if (!(num_codes === 1 || space === 0))
      throw new Error('[ReadHuffmanCode] invalid num_codes or space');
    
    ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
  }
  
  table_size = BrotliBuildHuffmanTable(tables, table, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
  
  if (table_size === 0) {
    throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
  }
  
  return table_size;
}

function ReadBlockLength(table, index, br) {
  var code;
  var nbits;
  code = ReadSymbol(table, index, br);
  nbits = Prefix.kBlockLengthPrefixCode[code].nbits;
  return Prefix.kBlockLengthPrefixCode[code].offset + br.readBits(nbits);
}

function TranslateShortCodes(code, ringbuffer, index) {
  var val;
  if (code < NUM_DISTANCE_SHORT_CODES) {
    index += kDistanceShortCodeIndexOffset[code];
    index &= 3;
    val = ringbuffer[index] + kDistanceShortCodeValueOffset[code];
  } else {
    val = code - NUM_DISTANCE_SHORT_CODES + 1;
  }
  return val;
}

function MoveToFront(v, index) {
  var value = v[index];
  var i = index;
  for (; i; --i) v[i] = v[i - 1];
  v[0] = value;
}

function InverseMoveToFrontTransform(v, v_len) {
  var mtf = new Uint8Array(256);
  var i;
  for (i = 0; i < 256; ++i) {
    mtf[i] = i;
  }
  for (i = 0; i < v_len; ++i) {
    var index = v[i];
    v[i] = mtf[index];
    if (index) MoveToFront(mtf, index);
  }
}

/* Contains a collection of huffman trees with the same alphabet size. */
function HuffmanTreeGroup(alphabet_size, num_htrees) {
  this.alphabet_size = alphabet_size;
  this.num_htrees = num_htrees;
  this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[(alphabet_size + 31) >>> 5]);  
  this.htrees = new Uint32Array(num_htrees);
}

HuffmanTreeGroup.prototype.decode = function(br) {
  var i;
  var table_size;
  var next = 0;
  for (i = 0; i < this.num_htrees; ++i) {
    this.htrees[i] = next;
    table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next, br);
    next += table_size;
  }
};

function DecodeContextMap(context_map_size, br) {
  var out = { num_htrees: null, context_map: null };
  var use_rle_for_zeros;
  var max_run_length_prefix = 0;
  var table;
  var i;
  
  br.readMoreInput();
  var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;

  var context_map = out.context_map = new Uint8Array(context_map_size);
  if (num_htrees <= 1) {
    return out;
  }

  use_rle_for_zeros = br.readBits(1);
  if (use_rle_for_zeros) {
    max_run_length_prefix = br.readBits(4) + 1;
  }
  
  table = [];
  for (i = 0; i < HUFFMAN_MAX_TABLE_SIZE; i++) {
    table[i] = new HuffmanCode(0, 0);
  }
  
  ReadHuffmanCode(num_htrees + max_run_length_prefix, table, 0, br);
  
  for (i = 0; i < context_map_size;) {
    var code;

    br.readMoreInput();
    code = ReadSymbol(table, 0, br);
    if (code === 0) {
      context_map[i] = 0;
      ++i;
    } else if (code <= max_run_length_prefix) {
      var reps = 1 + (1 << code) + br.readBits(code);
      while (--reps) {
        if (i >= context_map_size) {
          throw new Error("[DecodeContextMap] i >= context_map_size");
        }
        context_map[i] = 0;
        ++i;
      }
    } else {
      context_map[i] = code - max_run_length_prefix;
      ++i;
    }
  }
  if (br.readBits(1)) {
    InverseMoveToFrontTransform(context_map, context_map_size);
  }
  
  return out;
}

function DecodeBlockType(max_block_type, trees, tree_type, block_types, ringbuffers, indexes, br) {
  var ringbuffer = tree_type * 2;
  var index = tree_type;
  var type_code = ReadSymbol(trees, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
  var block_type;
  if (type_code === 0) {
    block_type = ringbuffers[ringbuffer + (indexes[index] & 1)];
  } else if (type_code === 1) {
    block_type = ringbuffers[ringbuffer + ((indexes[index] - 1) & 1)] + 1;
  } else {
    block_type = type_code - 2;
  }
  if (block_type >= max_block_type) {
    block_type -= max_block_type;
  }
  block_types[tree_type] = block_type;
  ringbuffers[ringbuffer + (indexes[index] & 1)] = block_type;
  ++indexes[index];
}

function CopyUncompressedBlockToOutput(output, len, pos, ringbuffer, ringbuffer_mask, br) {
  var rb_size = ringbuffer_mask + 1;
  var rb_pos = pos & ringbuffer_mask;
  var br_pos = br.pos_ & BrotliBitReader.IBUF_MASK;
  var nbytes;

  /* For short lengths copy byte-by-byte */
  if (len < 8 || br.bit_pos_ + (len << 3) < br.bit_end_pos_) {
    while (len-- > 0) {
      br.readMoreInput();
      ringbuffer[rb_pos++] = br.readBits(8);
      if (rb_pos === rb_size) {
        output.write(ringbuffer, rb_size);
        rb_pos = 0;
      }
    }
    return;
  }

  if (br.bit_end_pos_ < 32) {
    throw new Error('[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32');
  }

  /* Copy remaining 0-4 bytes from br.val_ to ringbuffer. */
  while (br.bit_pos_ < 32) {
    ringbuffer[rb_pos] = (br.val_ >>> br.bit_pos_);
    br.bit_pos_ += 8;
    ++rb_pos;
    --len;
  }

  /* Copy remaining bytes from br.buf_ to ringbuffer. */
  nbytes = (br.bit_end_pos_ - br.bit_pos_) >> 3;
  if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {
    var tail = BrotliBitReader.IBUF_MASK + 1 - br_pos;
    for (var x = 0; x < tail; x++)
      ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
    
    nbytes -= tail;
    rb_pos += tail;
    len -= tail;
    br_pos = 0;
  }

  for (var x = 0; x < nbytes; x++)
    ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
  
  rb_pos += nbytes;
  len -= nbytes;

  /* If we wrote past the logical end of the ringbuffer, copy the tail of the
     ringbuffer to its beginning and flush the ringbuffer to the output. */
  if (rb_pos >= rb_size) {
    output.write(ringbuffer, rb_size);
    rb_pos -= rb_size;    
    for (var x = 0; x < rb_pos; x++)
      ringbuffer[x] = ringbuffer[rb_size + x];
  }

  /* If we have more to copy than the remaining size of the ringbuffer, then we
     first fill the ringbuffer from the input and then flush the ringbuffer to
     the output */
  while (rb_pos + len >= rb_size) {
    nbytes = rb_size - rb_pos;
    if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
      throw new Error('[CopyUncompressedBlockToOutput] not enough bytes');
    }
    output.write(ringbuffer, rb_size);
    len -= nbytes;
    rb_pos = 0;
  }

  /* Copy straight from the input onto the ringbuffer. The ringbuffer will be
     flushed to the output at a later time. */
  if (br.input_.read(ringbuffer, rb_pos, len) < len) {
    throw new Error('[CopyUncompressedBlockToOutput] not enough bytes');
  }

  /* Restore the state of the bit reader. */
  br.reset();
}

/* Advances the bit reader position to the next byte boundary and verifies
   that any skipped bits are set to zero. */
function JumpToByteBoundary(br) {
  var new_bit_pos = (br.bit_pos_ + 7) & ~7;
  var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
  return pad_bits == 0;
}

function BrotliDecompressedSize(buffer) {
  var input = new BrotliInput(buffer);
  var br = new BrotliBitReader(input);
  DecodeWindowBits(br);
  var out = DecodeMetaBlockLength(br);
  return out.meta_block_length;
}

exports.BrotliDecompressedSize = BrotliDecompressedSize;

function BrotliDecompressBuffer(buffer, output_size) {
  var input = new BrotliInput(buffer);
  
  if (output_size == null) {
    output_size = BrotliDecompressedSize(buffer);
  }
  
  var output_buffer = new Uint8Array(output_size);
  var output = new BrotliOutput(output_buffer);
  
  BrotliDecompress(input, output);
  
  if (output.pos < output.buffer.length) {
    output.buffer = output.buffer.subarray(0, output.pos);
  }
  
  return output.buffer;
}

exports.BrotliDecompressBuffer = BrotliDecompressBuffer;

function BrotliDecompress(input, output) {
  var i;
  var pos = 0;
  var input_end = 0;
  var window_bits = 0;
  var max_backward_distance;
  var max_distance = 0;
  var ringbuffer_size;
  var ringbuffer_mask;
  var ringbuffer;
  var ringbuffer_end;
  /* This ring buffer holds a few past copy distances that will be used by */
  /* some special distance codes. */
  var dist_rb = [ 16, 15, 11, 4 ];
  var dist_rb_idx = 0;
  /* The previous 2 bytes used for context. */
  var prev_byte1 = 0;
  var prev_byte2 = 0;
  var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
  var block_type_trees;
  var block_len_trees;
  var br;

  /* We need the slack region for the following reasons:
       - always doing two 8-byte copies for fast backward copying
       - transforms
       - flushing the input ringbuffer when decoding uncompressed blocks */
  var kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE;

  br = new BrotliBitReader(input);

  /* Decode window size. */
  window_bits = DecodeWindowBits(br);
  max_backward_distance = (1 << window_bits) - 16;

  ringbuffer_size = 1 << window_bits;
  ringbuffer_mask = ringbuffer_size - 1;
  ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + BrotliDictionary.maxDictionaryWordLength);
  ringbuffer_end = ringbuffer_size;

  block_type_trees = [];
  block_len_trees = [];
  for (var x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {
    block_type_trees[x] = new HuffmanCode(0, 0);
    block_len_trees[x] = new HuffmanCode(0, 0);
  }

  while (!input_end) {
    var meta_block_remaining_len = 0;
    var is_uncompressed;
    var block_length = [ 1 << 28, 1 << 28, 1 << 28 ];
    var block_type = [ 0 ];
    var num_block_types = [ 1, 1, 1 ];
    var block_type_rb = [ 0, 1, 0, 1, 0, 1 ];
    var block_type_rb_index = [ 0 ];
    var distance_postfix_bits;
    var num_direct_distance_codes;
    var distance_postfix_mask;
    var num_distance_codes;
    var context_map = null;
    var context_modes = null;
    var num_literal_htrees;
    var dist_context_map = null;
    var num_dist_htrees;
    var context_offset = 0;
    var context_map_slice = null;
    var literal_htree_index = 0;
    var dist_context_offset = 0;
    var dist_context_map_slice = null;
    var dist_htree_index = 0;
    var context_lookup_offset1 = 0;
    var context_lookup_offset2 = 0;
    var context_mode;
    var htree_command;

    for (i = 0; i < 3; ++i) {
      hgroup[i].codes = null;
      hgroup[i].htrees = null;
    }

    br.readMoreInput();
    
    var _out = DecodeMetaBlockLength(br);
    meta_block_remaining_len = _out.meta_block_length;
    if (pos + meta_block_remaining_len > output.buffer.length) {
      /* We need to grow the output buffer to fit the additional data. */
      var tmp = new Uint8Array( pos + meta_block_remaining_len );
      tmp.set( output.buffer );
      output.buffer = tmp;
    }    
    input_end = _out.input_end;
    is_uncompressed = _out.is_uncompressed;
    
    if (_out.is_metadata) {
      JumpToByteBoundary(br);
      
      for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
        br.readMoreInput();
        /* Read one byte and ignore it. */
        br.readBits(8);
      }
      
      continue;
    }
    
    if (meta_block_remaining_len === 0) {
      continue;
    }
    
    if (is_uncompressed) {
      br.bit_pos_ = (br.bit_pos_ + 7) & ~7;
      CopyUncompressedBlockToOutput(output, meta_block_remaining_len, pos,
                                    ringbuffer, ringbuffer_mask, br);
      pos += meta_block_remaining_len;
      continue;
    }
    
    for (i = 0; i < 3; ++i) {
      num_block_types[i] = DecodeVarLenUint8(br) + 1;
      if (num_block_types[i] >= 2) {
        ReadHuffmanCode(num_block_types[i] + 2, block_type_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
        ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
        block_length[i] = ReadBlockLength(block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
        block_type_rb_index[i] = 1;
      }
    }
    
    br.readMoreInput();
    
    distance_postfix_bits = br.readBits(2);
    num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
    distance_postfix_mask = (1 << distance_postfix_bits) - 1;
    num_distance_codes = (num_direct_distance_codes + (48 << distance_postfix_bits));
    context_modes = new Uint8Array(num_block_types[0]);

    for (i = 0; i < num_block_types[0]; ++i) {
       br.readMoreInput();
       context_modes[i] = (br.readBits(2) << 1);
    }
    
    var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
    num_literal_htrees = _o1.num_htrees;
    context_map = _o1.context_map;
    
    var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
    num_dist_htrees = _o2.num_htrees;
    dist_context_map = _o2.context_map;
    
    hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
    hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
    hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);

    for (i = 0; i < 3; ++i) {
      hgroup[i].decode(br);
    }

    context_map_slice = 0;
    dist_context_map_slice = 0;
    context_mode = context_modes[block_type[0]];
    context_lookup_offset1 = Context.lookupOffsets[context_mode];
    context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
    htree_command = hgroup[1].htrees[0];

    while (meta_block_remaining_len > 0) {
      var cmd_code;
      var range_idx;
      var insert_code;
      var copy_code;
      var insert_length;
      var copy_length;
      var distance_code;
      var distance;
      var context;
      var j;
      var copy_dst;

      br.readMoreInput();
      
      if (block_length[1] === 0) {
        DecodeBlockType(num_block_types[1],
                        block_type_trees, 1, block_type, block_type_rb,
                        block_type_rb_index, br);
        block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
        htree_command = hgroup[1].htrees[block_type[1]];
      }
      --block_length[1];
      cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
      range_idx = cmd_code >> 6;
      if (range_idx >= 2) {
        range_idx -= 2;
        distance_code = -1;
      } else {
        distance_code = 0;
      }
      insert_code = Prefix.kInsertRangeLut[range_idx] + ((cmd_code >> 3) & 7);
      copy_code = Prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
      insert_length = Prefix.kInsertLengthPrefixCode[insert_code].offset +
          br.readBits(Prefix.kInsertLengthPrefixCode[insert_code].nbits);
      copy_length = Prefix.kCopyLengthPrefixCode[copy_code].offset +
          br.readBits(Prefix.kCopyLengthPrefixCode[copy_code].nbits);
      prev_byte1 = ringbuffer[pos-1 & ringbuffer_mask];
      prev_byte2 = ringbuffer[pos-2 & ringbuffer_mask];
      for (j = 0; j < insert_length; ++j) {
        br.readMoreInput();

        if (block_length[0] === 0) {
          DecodeBlockType(num_block_types[0],
                          block_type_trees, 0, block_type, block_type_rb,
                          block_type_rb_index, br);
          block_length[0] = ReadBlockLength(block_len_trees, 0, br);
          context_offset = block_type[0] << kLiteralContextBits;
          context_map_slice = context_offset;
          context_mode = context_modes[block_type[0]];
          context_lookup_offset1 = Context.lookupOffsets[context_mode];
          context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
        }
        context = (Context.lookup[context_lookup_offset1 + prev_byte1] |
                   Context.lookup[context_lookup_offset2 + prev_byte2]);
        literal_htree_index = context_map[context_map_slice + context];
        --block_length[0];
        prev_byte2 = prev_byte1;
        prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
        ringbuffer[pos & ringbuffer_mask] = prev_byte1;
        if ((pos & ringbuffer_mask) === ringbuffer_mask) {
          output.write(ringbuffer, ringbuffer_size);
        }
        ++pos;
      }
      meta_block_remaining_len -= insert_length;
      if (meta_block_remaining_len <= 0) break;

      if (distance_code < 0) {
        var context;
        
        br.readMoreInput();
        if (block_length[2] === 0) {
          DecodeBlockType(num_block_types[2],
                          block_type_trees, 2, block_type, block_type_rb,
                          block_type_rb_index, br);
          block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
          dist_context_offset = block_type[2] << kDistanceContextBits;
          dist_context_map_slice = dist_context_offset;
        }
        --block_length[2];
        context = (copy_length > 4 ? 3 : copy_length - 2) & 0xff;
        dist_htree_index = dist_context_map[dist_context_map_slice + context];
        distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
        if (distance_code >= num_direct_distance_codes) {
          var nbits;
          var postfix;
          var offset;
          distance_code -= num_direct_distance_codes;
          postfix = distance_code & distance_postfix_mask;
          distance_code >>= distance_postfix_bits;
          nbits = (distance_code >> 1) + 1;
          offset = ((2 + (distance_code & 1)) << nbits) - 4;
          distance_code = num_direct_distance_codes +
              ((offset + br.readBits(nbits)) <<
               distance_postfix_bits) + postfix;
        }
      }

      /* Convert the distance code to the actual distance by possibly looking */
      /* up past distnaces from the ringbuffer. */
      distance = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
      if (distance < 0) {
        throw new Error('[BrotliDecompress] invalid distance');
      }

      if (pos < max_backward_distance &&
          max_distance !== max_backward_distance) {
        max_distance = pos;
      } else {
        max_distance = max_backward_distance;
      }

      copy_dst = pos & ringbuffer_mask;

      if (distance > max_distance) {
        if (copy_length >= BrotliDictionary.minDictionaryWordLength &&
            copy_length <= BrotliDictionary.maxDictionaryWordLength) {
          var offset = BrotliDictionary.offsetsByLength[copy_length];
          var word_id = distance - max_distance - 1;
          var shift = BrotliDictionary.sizeBitsByLength[copy_length];
          var mask = (1 << shift) - 1;
          var word_idx = word_id & mask;
          var transform_idx = word_id >> shift;
          offset += word_idx * copy_length;
          if (transform_idx < Transform.kNumTransforms) {
            var len = Transform.transformDictionaryWord(ringbuffer, copy_dst, offset, copy_length, transform_idx);
            copy_dst += len;
            pos += len;
            meta_block_remaining_len -= len;
            if (copy_dst >= ringbuffer_end) {
              output.write(ringbuffer, ringbuffer_size);
              
              for (var _x = 0; _x < (copy_dst - ringbuffer_end); _x++)
                ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
            }
          } else {
            throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance +
              " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
          }
        } else {
          throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance +
            " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
        }
      } else {
        if (distance_code > 0) {
          dist_rb[dist_rb_idx & 3] = distance;
          ++dist_rb_idx;
        }

        if (copy_length > meta_block_remaining_len) {
          throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance +
            " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
        }

        for (j = 0; j < copy_length; ++j) {
          ringbuffer[pos & ringbuffer_mask] = ringbuffer[(pos - distance) & ringbuffer_mask];
          if ((pos & ringbuffer_mask) === ringbuffer_mask) {
            output.write(ringbuffer, ringbuffer_size);
          }
          ++pos;
          --meta_block_remaining_len;
        }
      }

      /* When we get here, we must have inserted at least one literal and */
      /* made a copy of at least length two, therefore accessing the last 2 */
      /* bytes is valid. */
      prev_byte1 = ringbuffer[(pos - 1) & ringbuffer_mask];
      prev_byte2 = ringbuffer[(pos - 2) & ringbuffer_mask];
    }

    /* Protect pos from overflow, wrap it around at every GB of input data */
    pos &= 0x3fffffff;
  }

  output.write(ringbuffer, pos & ringbuffer_mask);
}

exports.BrotliDecompress = BrotliDecompress;

BrotliDictionary.init();

},{"./bit_reader":61,"./context":62,"./dictionary":66,"./huffman":67,"./prefix":68,"./streams":69,"./transform":70}],64:[function(require,module,exports){
var base64 = require('base64-js');
var fs = require('fs');

/**
 * The normal dictionary-data.js is quite large, which makes it 
 * unsuitable for browser usage. In order to make it smaller, 
 * we read dictionary.bin, which is a compressed version of
 * the dictionary, and on initial load, Brotli decompresses 
 * it's own dictionary. 😜
 */
exports.init = function() {
  var BrotliDecompressBuffer = require('./decode').BrotliDecompressBuffer;
  var compressed = base64.toByteArray(require('./dictionary.bin.js'));
  return BrotliDecompressBuffer(compressed);
};

},{"./decode":63,"./dictionary.bin.js":65,"base64-js":60,"fs":1}],65:[function(require,module,exports){
module.exports="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";

},{}],66:[function(require,module,exports){
/* Copyright 2013 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Collection of static dictionary words.
*/

var data = require('./dictionary-data');
exports.init = function() {
  exports.dictionary = data.init();
};

exports.offsetsByLength = new Uint32Array([
     0,     0,     0,     0,     0,  4096,  9216, 21504, 35840, 44032,
 53248, 63488, 74752, 87040, 93696, 100864, 104704, 106752, 108928, 113536,
 115968, 118528, 119872, 121280, 122016,
]);

exports.sizeBitsByLength = new Uint8Array([
  0,  0,  0,  0, 10, 10, 11, 11, 10, 10,
 10, 10, 10,  9,  9,  8,  7,  7,  8,  7,
  7,  6,  6,  5,  5,
]);

exports.minDictionaryWordLength = 4;
exports.maxDictionaryWordLength = 24;

},{"./dictionary-data":64}],67:[function(require,module,exports){
function HuffmanCode(bits, value) {
  this.bits = bits;   /* number of bits used for this symbol */
  this.value = value; /* symbol value or table offset */
}

exports.HuffmanCode = HuffmanCode;

var MAX_LENGTH = 15;

/* Returns reverse(reverse(key, len) + 1, len), where reverse(key, len) is the
   bit-wise reversal of the len least significant bits of key. */
function GetNextKey(key, len) {
  var step = 1 << (len - 1);
  while (key & step) {
    step >>= 1;
  }
  return (key & (step - 1)) + step;
}

/* Stores code in table[0], table[step], table[2*step], ..., table[end] */
/* Assumes that end is an integer multiple of step */
function ReplicateValue(table, i, step, end, code) {
  do {
    end -= step;
    table[i + end] = new HuffmanCode(code.bits, code.value);
  } while (end > 0);
}

/* Returns the table width of the next 2nd level table. count is the histogram
   of bit lengths for the remaining symbols, len is the code length of the next
   processed symbol */
function NextTableBitSize(count, len, root_bits) {
  var left = 1 << (len - root_bits);
  while (len < MAX_LENGTH) {
    left -= count[len];
    if (left <= 0) break;
    ++len;
    left <<= 1;
  }
  return len - root_bits;
}

exports.BrotliBuildHuffmanTable = function(root_table, table, root_bits, code_lengths, code_lengths_size) {
  var start_table = table;
  var code;            /* current table entry */
  var len;             /* current code length */
  var symbol;          /* symbol index in original or sorted table */
  var key;             /* reversed prefix code */
  var step;            /* step size to replicate values in current table */
  var low;             /* low bits for current root entry */
  var mask;            /* mask for low bits */
  var table_bits;      /* key length of current table */
  var table_size;      /* size of current table */
  var total_size;      /* sum of root table size and 2nd level table sizes */
  var sorted;          /* symbols sorted by code length */
  var count = new Int32Array(MAX_LENGTH + 1);  /* number of codes of each length */
  var offset = new Int32Array(MAX_LENGTH + 1);  /* offsets in sorted table for each length */

  sorted = new Int32Array(code_lengths_size);

  /* build histogram of code lengths */
  for (symbol = 0; symbol < code_lengths_size; symbol++) {
    count[code_lengths[symbol]]++;
  }

  /* generate offsets into sorted symbol table by code length */
  offset[1] = 0;
  for (len = 1; len < MAX_LENGTH; len++) {
    offset[len + 1] = offset[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (symbol = 0; symbol < code_lengths_size; symbol++) {
    if (code_lengths[symbol] !== 0) {
      sorted[offset[code_lengths[symbol]]++] = symbol;
    }
  }
  
  table_bits = root_bits;
  table_size = 1 << table_bits;
  total_size = table_size;

  /* special case code with only one value */
  if (offset[MAX_LENGTH] === 1) {
    for (key = 0; key < total_size; ++key) {
      root_table[table + key] = new HuffmanCode(0, sorted[0] & 0xffff);
    }
    
    return total_size;
  }

  /* fill in root table */
  key = 0;
  symbol = 0;
  for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {
    for (; count[len] > 0; --count[len]) {
      code = new HuffmanCode(len & 0xff, sorted[symbol++] & 0xffff);
      ReplicateValue(root_table, table + key, step, table_size, code);
      key = GetNextKey(key, len);
    }
  }

  /* fill in 2nd level tables and add pointers to root table */
  mask = total_size - 1;
  low = -1;
  for (len = root_bits + 1, step = 2; len <= MAX_LENGTH; ++len, step <<= 1) {
    for (; count[len] > 0; --count[len]) {
      if ((key & mask) !== low) {
        table += table_size;
        table_bits = NextTableBitSize(count, len, root_bits);
        table_size = 1 << table_bits;
        total_size += table_size;
        low = key & mask;
        root_table[start_table + low] = new HuffmanCode((table_bits + root_bits) & 0xff, ((table - start_table) - low) & 0xffff);
      }
      code = new HuffmanCode((len - root_bits) & 0xff, sorted[symbol++] & 0xffff);
      ReplicateValue(root_table, table + (key >> root_bits), step, table_size, code);
      key = GetNextKey(key, len);
    }
  }
  
  return total_size;
}

},{}],68:[function(require,module,exports){
/* Copyright 2013 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Lookup tables to map prefix codes to value ranges. This is used during
   decoding of the block lengths, literal insertion lengths and copy lengths.
*/

/* Represents the range of values belonging to a prefix code: */
/* [offset, offset + 2^nbits) */
function PrefixCodeRange(offset, nbits) {
  this.offset = offset;
  this.nbits = nbits;
}

exports.kBlockLengthPrefixCode = [
  new PrefixCodeRange(1, 2), new PrefixCodeRange(5, 2), new PrefixCodeRange(9, 2), new PrefixCodeRange(13, 2),
  new PrefixCodeRange(17, 3), new PrefixCodeRange(25, 3), new PrefixCodeRange(33, 3), new PrefixCodeRange(41, 3),
  new PrefixCodeRange(49, 4), new PrefixCodeRange(65, 4), new PrefixCodeRange(81, 4), new PrefixCodeRange(97, 4),
  new PrefixCodeRange(113, 5), new PrefixCodeRange(145, 5), new PrefixCodeRange(177, 5), new PrefixCodeRange(209, 5),
  new PrefixCodeRange(241, 6), new PrefixCodeRange(305, 6), new PrefixCodeRange(369, 7), new PrefixCodeRange(497, 8),
  new PrefixCodeRange(753, 9), new PrefixCodeRange(1265, 10), new PrefixCodeRange(2289, 11), new PrefixCodeRange(4337, 12),
  new PrefixCodeRange(8433, 13), new PrefixCodeRange(16625, 24)
];

exports.kInsertLengthPrefixCode = [
  new PrefixCodeRange(0, 0), new PrefixCodeRange(1, 0), new PrefixCodeRange(2, 0), new PrefixCodeRange(3, 0),
  new PrefixCodeRange(4, 0), new PrefixCodeRange(5, 0), new PrefixCodeRange(6, 1), new PrefixCodeRange(8, 1),
  new PrefixCodeRange(10, 2), new PrefixCodeRange(14, 2), new PrefixCodeRange(18, 3), new PrefixCodeRange(26, 3),
  new PrefixCodeRange(34, 4), new PrefixCodeRange(50, 4), new PrefixCodeRange(66, 5), new PrefixCodeRange(98, 5),
  new PrefixCodeRange(130, 6), new PrefixCodeRange(194, 7), new PrefixCodeRange(322, 8), new PrefixCodeRange(578, 9),
  new PrefixCodeRange(1090, 10), new PrefixCodeRange(2114, 12), new PrefixCodeRange(6210, 14), new PrefixCodeRange(22594, 24),
];

exports.kCopyLengthPrefixCode = [
  new PrefixCodeRange(2, 0), new PrefixCodeRange(3, 0), new PrefixCodeRange(4, 0), new PrefixCodeRange(5, 0),
  new PrefixCodeRange(6, 0), new PrefixCodeRange(7, 0), new PrefixCodeRange(8, 0), new PrefixCodeRange(9, 0),
  new PrefixCodeRange(10, 1), new PrefixCodeRange(12, 1), new PrefixCodeRange(14, 2), new PrefixCodeRange(18, 2),
  new PrefixCodeRange(22, 3), new PrefixCodeRange(30, 3), new PrefixCodeRange(38, 4), new PrefixCodeRange(54, 4),
  new PrefixCodeRange(70, 5), new PrefixCodeRange(102, 5), new PrefixCodeRange(134, 6), new PrefixCodeRange(198, 7),
  new PrefixCodeRange(326, 8), new PrefixCodeRange(582, 9), new PrefixCodeRange(1094, 10), new PrefixCodeRange(2118, 24),
];

exports.kInsertRangeLut = [
  0, 0, 8, 8, 0, 16, 8, 16, 16,
];

exports.kCopyRangeLut = [
  0, 8, 0, 8, 16, 0, 16, 8, 16,
];

},{}],69:[function(require,module,exports){
function BrotliInput(buffer) {
  this.buffer = buffer;
  this.pos = 0;
}

BrotliInput.prototype.read = function(buf, i, count) {
  if (this.pos + count > this.buffer.length) {
    count = this.buffer.length - this.pos;
  }
  
  for (var p = 0; p < count; p++)
    buf[i + p] = this.buffer[this.pos + p];
  
  this.pos += count;
  return count;
}

exports.BrotliInput = BrotliInput;

function BrotliOutput(buf) {
  this.buffer = buf;
  this.pos = 0;
}

BrotliOutput.prototype.write = function(buf, count) {
  if (this.pos + count > this.buffer.length)
    throw new Error('Output buffer is not large enough');
  
  this.buffer.set(buf.subarray(0, count), this.pos);
  this.pos += count;
  return count;
};

exports.BrotliOutput = BrotliOutput;

},{}],70:[function(require,module,exports){
/* Copyright 2013 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Transformations on dictionary words.
*/

var BrotliDictionary = require('./dictionary');

var kIdentity       = 0;
var kOmitLast1      = 1;
var kOmitLast2      = 2;
var kOmitLast3      = 3;
var kOmitLast4      = 4;
var kOmitLast5      = 5;
var kOmitLast6      = 6;
var kOmitLast7      = 7;
var kOmitLast8      = 8;
var kOmitLast9      = 9;
var kUppercaseFirst = 10;
var kUppercaseAll   = 11;
var kOmitFirst1     = 12;
var kOmitFirst2     = 13;
var kOmitFirst3     = 14;
var kOmitFirst4     = 15;
var kOmitFirst5     = 16;
var kOmitFirst6     = 17;
var kOmitFirst7     = 18;
var kOmitFirst8     = 19;
var kOmitFirst9     = 20;

function Transform(prefix, transform, suffix) {
  this.prefix = new Uint8Array(prefix.length);
  this.transform = transform;
  this.suffix = new Uint8Array(suffix.length);
  
  for (var i = 0; i < prefix.length; i++)
    this.prefix[i] = prefix.charCodeAt(i);
  
  for (var i = 0; i < suffix.length; i++)
    this.suffix[i] = suffix.charCodeAt(i);
}

var kTransforms = [
     new Transform(         "", kIdentity,       ""           ),
     new Transform(         "", kIdentity,       " "          ),
     new Transform(        " ", kIdentity,       " "          ),
     new Transform(         "", kOmitFirst1,     ""           ),
     new Transform(         "", kUppercaseFirst, " "          ),
     new Transform(         "", kIdentity,       " the "      ),
     new Transform(        " ", kIdentity,       ""           ),
     new Transform(       "s ", kIdentity,       " "          ),
     new Transform(         "", kIdentity,       " of "       ),
     new Transform(         "", kUppercaseFirst, ""           ),
     new Transform(         "", kIdentity,       " and "      ),
     new Transform(         "", kOmitFirst2,     ""           ),
     new Transform(         "", kOmitLast1,      ""           ),
     new Transform(       ", ", kIdentity,       " "          ),
     new Transform(         "", kIdentity,       ", "         ),
     new Transform(        " ", kUppercaseFirst, " "          ),
     new Transform(         "", kIdentity,       " in "       ),
     new Transform(         "", kIdentity,       " to "       ),
     new Transform(       "e ", kIdentity,       " "          ),
     new Transform(         "", kIdentity,       "\""         ),
     new Transform(         "", kIdentity,       "."          ),
     new Transform(         "", kIdentity,       "\">"        ),
     new Transform(         "", kIdentity,       "\n"         ),
     new Transform(         "", kOmitLast3,      ""           ),
     new Transform(         "", kIdentity,       "]"          ),
     new Transform(         "", kIdentity,       " for "      ),
     new Transform(         "", kOmitFirst3,     ""           ),
     new Transform(         "", kOmitLast2,      ""           ),
     new Transform(         "", kIdentity,       " a "        ),
     new Transform(         "", kIdentity,       " that "     ),
     new Transform(        " ", kUppercaseFirst, ""           ),
     new Transform(         "", kIdentity,       ". "         ),
     new Transform(        ".", kIdentity,       ""           ),
     new Transform(        " ", kIdentity,       ", "         ),
     new Transform(         "", kOmitFirst4,     ""           ),
     new Transform(         "", kIdentity,       " with "     ),
     new Transform(         "", kIdentity,       "'"          ),
     new Transform(         "", kIdentity,       " from "     ),
     new Transform(         "", kIdentity,       " by "       ),
     new Transform(         "", kOmitFirst5,     ""           ),
     new Transform(         "", kOmitFirst6,     ""           ),
     new Transform(    " the ", kIdentity,       ""           ),
     new Transform(         "", kOmitLast4,      ""           ),
     new Transform(         "", kIdentity,       ". The "     ),
     new Transform(         "", kUppercaseAll,   ""           ),
     new Transform(         "", kIdentity,       " on "       ),
     new Transform(         "", kIdentity,       " as "       ),
     new Transform(         "", kIdentity,       " is "       ),
     new Transform(         "", kOmitLast7,      ""           ),
     new Transform(         "", kOmitLast1,      "ing "       ),
     new Transform(         "", kIdentity,       "\n\t"       ),
     new Transform(         "", kIdentity,       ":"          ),
     new Transform(        " ", kIdentity,       ". "         ),
     new Transform(         "", kIdentity,       "ed "        ),
     new Transform(         "", kOmitFirst9,     ""           ),
     new Transform(         "", kOmitFirst7,     ""           ),
     new Transform(         "", kOmitLast6,      ""           ),
     new Transform(         "", kIdentity,       "("          ),
     new Transform(         "", kUppercaseFirst, ", "         ),
     new Transform(         "", kOmitLast8,      ""           ),
     new Transform(         "", kIdentity,       " at "       ),
     new Transform(         "", kIdentity,       "ly "        ),
     new Transform(    " the ", kIdentity,       " of "       ),
     new Transform(         "", kOmitLast5,      ""           ),
     new Transform(         "", kOmitLast9,      ""           ),
     new Transform(        " ", kUppercaseFirst, ", "         ),
     new Transform(         "", kUppercaseFirst, "\""         ),
     new Transform(        ".", kIdentity,       "("          ),
     new Transform(         "", kUppercaseAll,   " "          ),
     new Transform(         "", kUppercaseFirst, "\">"        ),
     new Transform(         "", kIdentity,       "=\""        ),
     new Transform(        " ", kIdentity,       "."          ),
     new Transform(    ".com/", kIdentity,       ""           ),
     new Transform(    " the ", kIdentity,       " of the "   ),
     new Transform(         "", kUppercaseFirst, "'"          ),
     new Transform(         "", kIdentity,       ". This "    ),
     new Transform(         "", kIdentity,       ","          ),
     new Transform(        ".", kIdentity,       " "          ),
     new Transform(         "", kUppercaseFirst, "("          ),
     new Transform(         "", kUppercaseFirst, "."          ),
     new Transform(         "", kIdentity,       " not "      ),
     new Transform(        " ", kIdentity,       "=\""        ),
     new Transform(         "", kIdentity,       "er "        ),
     new Transform(        " ", kUppercaseAll,   " "          ),
     new Transform(         "", kIdentity,       "al "        ),
     new Transform(        " ", kUppercaseAll,   ""           ),
     new Transform(         "", kIdentity,       "='"         ),
     new Transform(         "", kUppercaseAll,   "\""         ),
     new Transform(         "", kUppercaseFirst, ". "         ),
     new Transform(        " ", kIdentity,       "("          ),
     new Transform(         "", kIdentity,       "ful "       ),
     new Transform(        " ", kUppercaseFirst, ". "         ),
     new Transform(         "", kIdentity,       "ive "       ),
     new Transform(         "", kIdentity,       "less "      ),
     new Transform(         "", kUppercaseAll,   "'"          ),
     new Transform(         "", kIdentity,       "est "       ),
     new Transform(        " ", kUppercaseFirst, "."          ),
     new Transform(         "", kUppercaseAll,   "\">"        ),
     new Transform(        " ", kIdentity,       "='"         ),
     new Transform(         "", kUppercaseFirst, ","          ),
     new Transform(         "", kIdentity,       "ize "       ),
     new Transform(         "", kUppercaseAll,   "."          ),
     new Transform( "\xc2\xa0", kIdentity,       ""           ),
     new Transform(        " ", kIdentity,       ","          ),
     new Transform(         "", kUppercaseFirst, "=\""        ),
     new Transform(         "", kUppercaseAll,   "=\""        ),
     new Transform(         "", kIdentity,       "ous "       ),
     new Transform(         "", kUppercaseAll,   ", "         ),
     new Transform(         "", kUppercaseFirst, "='"         ),
     new Transform(        " ", kUppercaseFirst, ","          ),
     new Transform(        " ", kUppercaseAll,   "=\""        ),
     new Transform(        " ", kUppercaseAll,   ", "         ),
     new Transform(         "", kUppercaseAll,   ","          ),
     new Transform(         "", kUppercaseAll,   "("          ),
     new Transform(         "", kUppercaseAll,   ". "         ),
     new Transform(        " ", kUppercaseAll,   "."          ),
     new Transform(         "", kUppercaseAll,   "='"         ),
     new Transform(        " ", kUppercaseAll,   ". "         ),
     new Transform(        " ", kUppercaseFirst, "=\""        ),
     new Transform(        " ", kUppercaseAll,   "='"         ),
     new Transform(        " ", kUppercaseFirst, "='"         )
];

exports.kTransforms = kTransforms;
exports.kNumTransforms = kTransforms.length;

function ToUpperCase(p, i) {
  if (p[i] < 0xc0) {
    if (p[i] >= 97 && p[i] <= 122) {
      p[i] ^= 32;
    }
    return 1;
  }
  
  /* An overly simplified uppercasing model for utf-8. */
  if (p[i] < 0xe0) {
    p[i + 1] ^= 32;
    return 2;
  }
  
  /* An arbitrary transform for three byte characters. */
  p[i + 2] ^= 5;
  return 3;
}

exports.transformDictionaryWord = function(dst, idx, word, len, transform) {
  var prefix = kTransforms[transform].prefix;
  var suffix = kTransforms[transform].suffix;
  var t = kTransforms[transform].transform;
  var skip = t < kOmitFirst1 ? 0 : t - (kOmitFirst1 - 1);
  var i = 0;
  var start_idx = idx;
  var uppercase;
  
  if (skip > len) {
    skip = len;
  }
  
  var prefix_pos = 0;
  while (prefix_pos < prefix.length) {
    dst[idx++] = prefix[prefix_pos++];
  }
  
  word += skip;
  len -= skip;
  
  if (t <= kOmitLast9) {
    len -= t;
  }
  
  for (i = 0; i < len; i++) {
    dst[idx++] = BrotliDictionary.dictionary[word + i];
  }
  
  uppercase = idx - len;
  
  if (t === kUppercaseFirst) {
    ToUpperCase(dst, uppercase);
  } else if (t === kUppercaseAll) {
    while (len > 0) {
      var step = ToUpperCase(dst, uppercase);
      uppercase += step;
      len -= step;
    }
  }
  
  var suffix_pos = 0;
  while (suffix_pos < suffix.length) {
    dst[idx++] = suffix[suffix_pos++];
  }
  
  return idx - start_idx;
}

},{"./dictionary":66}],71:[function(require,module,exports){
module.exports = require('./dec/decode').BrotliDecompressBuffer;

},{"./dec/decode":63}],72:[function(require,module,exports){
/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2018, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.chroma = factory());
}(this, (function () { 'use strict';

    var limit = function (x, min, max) {
        if ( min === void 0 ) min=0;
        if ( max === void 0 ) max=1;

        return x < min ? min : x > max ? max : x;
    };

    var clip_rgb = function (rgb) {
        rgb._clipped = false;
        rgb._unclipped = rgb.slice(0);
        for (var i=0; i<=3; i++) {
            if (i < 3) {
                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }
                rgb[i] = limit(rgb[i], 0, 255);
            } else if (i === 3) {
                rgb[i] = limit(rgb[i], 0, 1);
            }
        }
        return rgb;
    };

    // ported from jQuery's $.type
    var classToType = {};
    for (var i = 0, list = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i < list.length; i += 1) {
        var name = list[i];

        classToType[("[object " + name + "]")] = name.toLowerCase();
    }
    var type = function(obj) {
        return classToType[Object.prototype.toString.call(obj)] || "object";
    };

    var unpack = function (args, keyOrder) {
        if ( keyOrder === void 0 ) keyOrder=null;

    	// if called with more than 3 arguments, we return the arguments
        if (args.length >= 3) { return Array.prototype.slice.call(args); }
        // with less than 3 args we check if first arg is object
        // and use the keyOrder string to extract and sort properties
    	if (type(args[0]) == 'object' && keyOrder) {
    		return keyOrder.split('')
    			.filter(function (k) { return args[0][k] !== undefined; })
    			.map(function (k) { return args[0][k]; });
    	}
    	// otherwise we just return the first argument
    	// (which we suppose is an array of args)
        return args[0];
    };

    var last = function (args) {
        if (args.length < 2) { return null; }
        var l = args.length-1;
        if (type(args[l]) == 'string') { return args[l].toLowerCase(); }
        return null;
    };

    var PI = Math.PI;

    var utils = {
    	clip_rgb: clip_rgb,
    	limit: limit,
    	type: type,
    	unpack: unpack,
    	last: last,
    	PI: PI,
    	TWOPI: PI*2,
    	PITHIRD: PI/3,
    	DEG2RAD: PI / 180,
    	RAD2DEG: 180 / PI
    };

    var input = {
    	format: {},
    	autodetect: []
    };

    var last$1 = utils.last;
    var clip_rgb$1 = utils.clip_rgb;
    var type$1 = utils.type;


    var Color = function Color() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var me = this;
        if (type$1(args[0]) === 'object' &&
            args[0].constructor &&
            args[0].constructor === this.constructor) {
            // the argument is already a Color instance
            return args[0];
        }

        // last argument could be the mode
        var mode = last$1(args);
        var autodetect = false;

        if (!mode) {
            autodetect = true;
            if (!input.sorted) {
                input.autodetect = input.autodetect.sort(function (a,b) { return b.p - a.p; });
                input.sorted = true;
            }
            // auto-detect format
            for (var i = 0, list = input.autodetect; i < list.length; i += 1) {
                var chk = list[i];

                mode = chk.test.apply(chk, args);
                if (mode) { break; }
            }
        }

        if (input.format[mode]) {
            var rgb = input.format[mode].apply(null, autodetect ? args : args.slice(0,-1));
            me._rgb = clip_rgb$1(rgb);
        } else {
            throw new Error('unknown format: '+args);
        }

        // add alpha channel
        if (me._rgb.length === 3) { me._rgb.push(1); }
    };

    Color.prototype.toString = function toString () {
        if (type$1(this.hex) == 'function') { return this.hex(); }
        return ("[" + (this._rgb.join(',')) + "]");
    };

    var Color_1 = Color;

    var chroma = function () {
    	var args = [], len = arguments.length;
    	while ( len-- ) args[ len ] = arguments[ len ];

    	return new (Function.prototype.bind.apply( chroma.Color, [ null ].concat( args) ));
    };

    chroma.Color = Color_1;
    chroma.version = '2.0.3';

    var chroma_1 = chroma;

    var unpack$1 = utils.unpack;
    var max = Math.max;

    var rgb2cmyk = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$1(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r = r / 255;
        g = g / 255;
        b = b / 255;
        var k = 1 - max(r,max(g,b));
        var f = k < 1 ? 1 / (1-k) : 0;
        var c = (1-r-k) * f;
        var m = (1-g-k) * f;
        var y = (1-b-k) * f;
        return [c,m,y,k];
    };

    var rgb2cmyk_1 = rgb2cmyk;

    var unpack$2 = utils.unpack;

    var cmyk2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$2(args, 'cmyk');
        var c = args[0];
        var m = args[1];
        var y = args[2];
        var k = args[3];
        var alpha = args.length > 4 ? args[4] : 1;
        if (k === 1) { return [0,0,0,alpha]; }
        return [
            c >= 1 ? 0 : 255 * (1-c) * (1-k), // r
            m >= 1 ? 0 : 255 * (1-m) * (1-k), // g
            y >= 1 ? 0 : 255 * (1-y) * (1-k), // b
            alpha
        ];
    };

    var cmyk2rgb_1 = cmyk2rgb;

    var unpack$3 = utils.unpack;
    var type$2 = utils.type;



    Color_1.prototype.cmyk = function() {
        return rgb2cmyk_1(this._rgb);
    };

    chroma_1.cmyk = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['cmyk']) ));
    };

    input.format.cmyk = cmyk2rgb_1;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$3(args, 'cmyk');
            if (type$2(args) === 'array' && args.length === 4) {
                return 'cmyk';
            }
        }
    });

    var unpack$4 = utils.unpack;
    var last$2 = utils.last;
    var rnd = function (a) { return Math.round(a*100)/100; };

    /*
     * supported arguments:
     * - hsl2css(h,s,l)
     * - hsl2css(h,s,l,a)
     * - hsl2css([h,s,l], mode)
     * - hsl2css([h,s,l,a], mode)
     * - hsl2css({h,s,l,a}, mode)
     */
    var hsl2css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hsla = unpack$4(args, 'hsla');
        var mode = last$2(args) || 'lsa';
        hsla[0] = rnd(hsla[0] || 0);
        hsla[1] = rnd(hsla[1]*100) + '%';
        hsla[2] = rnd(hsla[2]*100) + '%';
        if (mode === 'hsla' || (hsla.length > 3 && hsla[3]<1)) {
            hsla[3] = hsla.length > 3 ? hsla[3] : 1;
            mode = 'hsla';
        } else {
            hsla.length = 3;
        }
        return (mode + "(" + (hsla.join(',')) + ")");
    };

    var hsl2css_1 = hsl2css;

    var unpack$5 = utils.unpack;

    /*
     * supported arguments:
     * - rgb2hsl(r,g,b)
     * - rgb2hsl(r,g,b,a)
     * - rgb2hsl([r,g,b])
     * - rgb2hsl([r,g,b,a])
     * - rgb2hsl({r,g,b,a})
     */
    var rgb2hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$5(args, 'rgba');
        var r = args[0];
        var g = args[1];
        var b = args[2];

        r /= 255;
        g /= 255;
        b /= 255;

        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);

        var l = (max + min) / 2;
        var s, h;

        if (max === min){
            s = 0;
            h = Number.NaN;
        } else {
            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
        }

        if (r == max) { h = (g - b) / (max - min); }
        else if (g == max) { h = 2 + (b - r) / (max - min); }
        else if (b == max) { h = 4 + (r - g) / (max - min); }

        h *= 60;
        if (h < 0) { h += 360; }
        if (args.length>3 && args[3]!==undefined) { return [h,s,l,args[3]]; }
        return [h,s,l];
    };

    var rgb2hsl_1 = rgb2hsl;

    var unpack$6 = utils.unpack;
    var last$3 = utils.last;


    var round = Math.round;

    /*
     * supported arguments:
     * - rgb2css(r,g,b)
     * - rgb2css(r,g,b,a)
     * - rgb2css([r,g,b], mode)
     * - rgb2css([r,g,b,a], mode)
     * - rgb2css({r,g,b,a}, mode)
     */
    var rgb2css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$6(args, 'rgba');
        var mode = last$3(args) || 'rgb';
        if (mode.substr(0,3) == 'hsl') {
            return hsl2css_1(rgb2hsl_1(rgba), mode);
        }
        rgba[0] = round(rgba[0]);
        rgba[1] = round(rgba[1]);
        rgba[2] = round(rgba[2]);
        if (mode === 'rgba' || (rgba.length > 3 && rgba[3]<1)) {
            rgba[3] = rgba.length > 3 ? rgba[3] : 1;
            mode = 'rgba';
        }
        return (mode + "(" + (rgba.slice(0,mode==='rgb'?3:4).join(',')) + ")");
    };

    var rgb2css_1 = rgb2css;

    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    var RE_HEXA = /^#?([A-Fa-f0-9]{8})$/;

    var hex2rgb = function (hex) {
        if (hex.match(RE_HEX)) {
            // remove optional leading #
            if (hex.length === 4 || hex.length === 7) {
                hex = hex.substr(1);
            }
            // expand short-notation to full six-digit
            if (hex.length === 3) {
                hex = hex.split('');
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            }
            var u = parseInt(hex, 16);
            var r = u >> 16;
            var g = u >> 8 & 0xFF;
            var b = u & 0xFF;
            return [r,g,b,1];
        }

        // match rgba hex format, eg #FF000077
        if (hex.match(RE_HEXA)) {
            if (hex.length === 9) {
                // remove optional leading #
                hex = hex.substr(1);
            }
            var u$1 = parseInt(hex, 16);
            var r$1 = u$1 >> 24 & 0xFF;
            var g$1 = u$1 >> 16 & 0xFF;
            var b$1 = u$1 >> 8 & 0xFF;
            var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;
            return [r$1,g$1,b$1,a];
        }

        // we used to check for css colors here
        // if _input.css? and rgb = _input.css hex
        //     return rgb

        throw new Error(("unknown hex color: " + hex));
    };

    var hex2rgb_1 = hex2rgb;

    var unpack$7 = utils.unpack;
    var round$1 = Math.round;

    var hsl2rgb = function () {
        var assign;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$7(args, 'hsl');
        var h = args[0];
        var s = args[1];
        var l = args[2];
        var r,g,b;
        if (s === 0) {
            r = g = b = l*255;
        } else {
            var t3 = [0,0,0];
            var c = [0,0,0];
            var t2 = l < 0.5 ? l * (1+s) : l+s-l*s;
            var t1 = 2 * l - t2;
            var h_ = h / 360;
            t3[0] = h_ + 1/3;
            t3[1] = h_;
            t3[2] = h_ - 1/3;
            for (var i=0; i<3; i++) {
                if (t3[i] < 0) { t3[i] += 1; }
                if (t3[i] > 1) { t3[i] -= 1; }
                if (6 * t3[i] < 1)
                    { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }
                else if (2 * t3[i] < 1)
                    { c[i] = t2; }
                else if (3 * t3[i] < 2)
                    { c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6; }
                else
                    { c[i] = t1; }
            }
            (assign = [round$1(c[0]*255),round$1(c[1]*255),round$1(c[2]*255)], r = assign[0], g = assign[1], b = assign[2]);
        }
        if (args.length > 3) {
            // keep alpha channel
            return [r,g,b,args[3]];
        }
        return [r,g,b,1];
    };

    var hsl2rgb_1 = hsl2rgb;

    /**
    	X11 color names

    	http://www.w3.org/TR/css3-color/#svg-color
    */

    var w3cx11 = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflower: '#6495ed',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        laserlemon: '#ffff54',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrod: '#fafad2',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        maroon2: '#7f0000',
        maroon3: '#b03060',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        purple2: '#7f007f',
        purple3: '#a020f0',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32'
    };

    var w3cx11_1 = w3cx11;

    var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
    var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;

    var round$2 = Math.round;

    var css2rgb = function (css) {
        css = css.toLowerCase().trim();
        // named X11 colors
        if (w3cx11_1[css]) {
            return hex2rgb_1(w3cx11_1[css]);
        }
        var m;

        // rgb(250,20,0)
        if ((m = css.match(RE_RGB))) {
            var rgb = m.slice(1,4);
            for (var i=0; i<3; i++) {
                rgb[i] = +rgb[i];
            }
            rgb[3] = 1;  // default alpha
            return rgb;
        }

        // rgba(250,20,0,0.4)
        if ((m = css.match(RE_RGBA))) {
            var rgb$1 = m.slice(1,5);
            for (var i$1=0; i$1<4; i$1++) {
                rgb$1[i$1] = +rgb$1[i$1];
            }
            return rgb$1;
        }

        // rgb(100%,0%,0%)
        if ((m = css.match(RE_RGB_PCT))) {
            var rgb$2 = m.slice(1,4);
            for (var i$2=0; i$2<3; i$2++) {
                rgb$2[i$2] = round$2(rgb$2[i$2] * 2.55);
            }
            rgb$2[3] = 1;  // default alpha
            return rgb$2;
        }

        // rgba(100%,0%,0%,0.4)
        if ((m = css.match(RE_RGBA_PCT))) {
            var rgb$3 = m.slice(1,5);
            for (var i$3=0; i$3<3; i$3++) {
                rgb$3[i$3] = round$2(rgb$3[i$3] * 2.55);
            }
            rgb$3[3] = +rgb$3[3];
            return rgb$3;
        }

        // hsl(0,100%,50%)
        if ((m = css.match(RE_HSL))) {
            var hsl = m.slice(1,4);
            hsl[1] *= 0.01;
            hsl[2] *= 0.01;
            var rgb$4 = hsl2rgb_1(hsl);
            rgb$4[3] = 1;
            return rgb$4;
        }

        // hsla(0,100%,50%,0.5)
        if ((m = css.match(RE_HSLA))) {
            var hsl$1 = m.slice(1,4);
            hsl$1[1] *= 0.01;
            hsl$1[2] *= 0.01;
            var rgb$5 = hsl2rgb_1(hsl$1);
            rgb$5[3] = +m[4];  // default alpha = 1
            return rgb$5;
        }
    };

    css2rgb.test = function (s) {
        return RE_RGB.test(s) ||
            RE_RGBA.test(s) ||
            RE_RGB_PCT.test(s) ||
            RE_RGBA_PCT.test(s) ||
            RE_HSL.test(s) ||
            RE_HSLA.test(s);
    };

    var css2rgb_1 = css2rgb;

    var type$3 = utils.type;




    Color_1.prototype.css = function(mode) {
        return rgb2css_1(this._rgb, mode);
    };

    chroma_1.css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['css']) ));
    };

    input.format.css = css2rgb_1;

    input.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$3(h) === 'string' && css2rgb_1.test(h)) {
                return 'css';
            }
        }
    });

    var unpack$8 = utils.unpack;

    input.format.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$8(args, 'rgba');
        rgb[0] *= 255;
        rgb[1] *= 255;
        rgb[2] *= 255;
        return rgb;
    };

    chroma_1.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['gl']) ));
    };

    Color_1.prototype.gl = function() {
        var rgb = this._rgb;
        return [rgb[0]/255, rgb[1]/255, rgb[2]/255, rgb[3]];
    };

    var unpack$9 = utils.unpack;

    var rgb2hcg = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$9(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var c = delta * 100 / 255;
        var _g = min / (255 - delta) * 100;
        var h;
        if (delta === 0) {
            h = Number.NaN;
        } else {
            if (r === max) { h = (g - b) / delta; }
            if (g === max) { h = 2+(b - r) / delta; }
            if (b === max) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, c, _g];
    };

    var rgb2hcg_1 = rgb2hcg;

    var unpack$a = utils.unpack;
    var floor = Math.floor;

    /*
     * this is basically just HSV with some minor tweaks
     *
     * hue.. [0..360]
     * chroma .. [0..1]
     * grayness .. [0..1]
     */

    var hcg2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$a(args, 'hcg');
        var h = args[0];
        var c = args[1];
        var _g = args[2];
        var r,g,b;
        _g = _g * 255;
        var _c = c * 255;
        if (c === 0) {
            r = g = b = _g;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;
            var i = floor(h);
            var f = h - i;
            var p = _g * (1 - c);
            var q = p + _c * (1 - f);
            var t = p + _c * f;
            var v = p + _c;
            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var hcg2rgb_1 = hcg2rgb;

    var unpack$b = utils.unpack;
    var type$4 = utils.type;






    Color_1.prototype.hcg = function() {
        return rgb2hcg_1(this._rgb);
    };

    chroma_1.hcg = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hcg']) ));
    };

    input.format.hcg = hcg2rgb_1;

    input.autodetect.push({
        p: 1,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$b(args, 'hcg');
            if (type$4(args) === 'array' && args.length === 3) {
                return 'hcg';
            }
        }
    });

    var unpack$c = utils.unpack;
    var last$4 = utils.last;
    var round$3 = Math.round;

    var rgb2hex = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$c(args, 'rgba');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var a = ref[3];
        var mode = last$4(args) || 'auto';
        if (a === undefined) { a = 1; }
        if (mode === 'auto') {
            mode = a < 1 ? 'rgba' : 'rgb';
        }
        r = round$3(r);
        g = round$3(g);
        b = round$3(b);
        var u = r << 16 | g << 8 | b;
        var str = "000000" + u.toString(16); //#.toUpperCase();
        str = str.substr(str.length - 6);
        var hxa = '0' + round$3(a * 255).toString(16);
        hxa = hxa.substr(hxa.length - 2);
        switch (mode.toLowerCase()) {
            case 'rgba': return ("#" + str + hxa);
            case 'argb': return ("#" + hxa + str);
            default: return ("#" + str);
        }
    };

    var rgb2hex_1 = rgb2hex;

    var type$5 = utils.type;




    Color_1.prototype.hex = function(mode) {
        return rgb2hex_1(this._rgb, mode);
    };

    chroma_1.hex = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hex']) ));
    };

    input.format.hex = hex2rgb_1;
    input.autodetect.push({
        p: 4,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$5(h) === 'string' && [3,4,6,7,8,9].includes(h.length)) {
                return 'hex';
            }
        }
    });

    var unpack$d = utils.unpack;
    var TWOPI = utils.TWOPI;
    var min = Math.min;
    var sqrt = Math.sqrt;
    var acos = Math.acos;

    var rgb2hsi = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
        */
        var ref = unpack$d(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r /= 255;
        g /= 255;
        b /= 255;
        var h;
        var min_ = min(r,g,b);
        var i = (r+g+b) / 3;
        var s = i > 0 ? 1 - min_/i : 0;
        if (s === 0) {
            h = NaN;
        } else {
            h = ((r-g)+(r-b)) / 2;
            h /= sqrt((r-g)*(r-g) + (r-b)*(g-b));
            h = acos(h);
            if (b > g) {
                h = TWOPI - h;
            }
            h /= TWOPI;
        }
        return [h*360,s,i];
    };

    var rgb2hsi_1 = rgb2hsi;

    var unpack$e = utils.unpack;
    var limit$1 = utils.limit;
    var TWOPI$1 = utils.TWOPI;
    var PITHIRD = utils.PITHIRD;
    var cos = Math.cos;

    /*
     * hue [0..360]
     * saturation [0..1]
     * intensity [0..1]
     */
    var hsi2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
        */
        args = unpack$e(args, 'hsi');
        var h = args[0];
        var s = args[1];
        var i = args[2];
        var r,g,b;

        if (isNaN(h)) { h = 0; }
        if (isNaN(s)) { s = 0; }
        // normalize hue
        if (h > 360) { h -= 360; }
        if (h < 0) { h += 360; }
        h /= 360;
        if (h < 1/3) {
            b = (1-s)/3;
            r = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;
            g = 1 - (b+r);
        } else if (h < 2/3) {
            h -= 1/3;
            r = (1-s)/3;
            g = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;
            b = 1 - (r+g);
        } else {
            h -= 2/3;
            g = (1-s)/3;
            b = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;
            r = 1 - (g+b);
        }
        r = limit$1(i*r*3);
        g = limit$1(i*g*3);
        b = limit$1(i*b*3);
        return [r*255, g*255, b*255, args.length > 3 ? args[3] : 1];
    };

    var hsi2rgb_1 = hsi2rgb;

    var unpack$f = utils.unpack;
    var type$6 = utils.type;






    Color_1.prototype.hsi = function() {
        return rgb2hsi_1(this._rgb);
    };

    chroma_1.hsi = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsi']) ));
    };

    input.format.hsi = hsi2rgb_1;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$f(args, 'hsi');
            if (type$6(args) === 'array' && args.length === 3) {
                return 'hsi';
            }
        }
    });

    var unpack$g = utils.unpack;
    var type$7 = utils.type;






    Color_1.prototype.hsl = function() {
        return rgb2hsl_1(this._rgb);
    };

    chroma_1.hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsl']) ));
    };

    input.format.hsl = hsl2rgb_1;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$g(args, 'hsl');
            if (type$7(args) === 'array' && args.length === 3) {
                return 'hsl';
            }
        }
    });

    var unpack$h = utils.unpack;
    var min$1 = Math.min;
    var max$1 = Math.max;

    /*
     * supported arguments:
     * - rgb2hsv(r,g,b)
     * - rgb2hsv([r,g,b])
     * - rgb2hsv({r,g,b})
     */
    var rgb2hsl$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$h(args, 'rgb');
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var min_ = min$1(r, g, b);
        var max_ = max$1(r, g, b);
        var delta = max_ - min_;
        var h,s,v;
        v = max_ / 255.0;
        if (max_ === 0) {
            h = Number.NaN;
            s = 0;
        } else {
            s = delta / max_;
            if (r === max_) { h = (g - b) / delta; }
            if (g === max_) { h = 2+(b - r) / delta; }
            if (b === max_) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, s, v]
    };

    var rgb2hsv = rgb2hsl$1;

    var unpack$i = utils.unpack;
    var floor$1 = Math.floor;

    var hsv2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$i(args, 'hsv');
        var h = args[0];
        var s = args[1];
        var v = args[2];
        var r,g,b;
        v *= 255;
        if (s === 0) {
            r = g = b = v;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;

            var i = floor$1(h);
            var f = h - i;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));

            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r,g,b,args.length > 3?args[3]:1];
    };

    var hsv2rgb_1 = hsv2rgb;

    var unpack$j = utils.unpack;
    var type$8 = utils.type;






    Color_1.prototype.hsv = function() {
        return rgb2hsv(this._rgb);
    };

    chroma_1.hsv = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsv']) ));
    };

    input.format.hsv = hsv2rgb_1;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$j(args, 'hsv');
            if (type$8(args) === 'array' && args.length === 3) {
                return 'hsv';
            }
        }
    });

    var labConstants = {
        // Corresponds roughly to RGB brighter/darker
        Kn: 18,

        // D65 standard referent
        Xn: 0.950470,
        Yn: 1,
        Zn: 1.088830,

        t0: 0.137931034,  // 4 / 29
        t1: 0.206896552,  // 6 / 29
        t2: 0.12841855,   // 3 * t1 * t1
        t3: 0.008856452,  // t1 * t1 * t1
    };

    var unpack$k = utils.unpack;
    var pow = Math.pow;

    var rgb2lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$k(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2xyz(r,g,b);
        var x = ref$1[0];
        var y = ref$1[1];
        var z = ref$1[2];
        var l = 116 * y - 16;
        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
    };

    var rgb_xyz = function (r) {
        if ((r /= 255) <= 0.04045) { return r / 12.92; }
        return pow((r + 0.055) / 1.055, 2.4);
    };

    var xyz_lab = function (t) {
        if (t > labConstants.t3) { return pow(t, 1 / 3); }
        return t / labConstants.t2 + labConstants.t0;
    };

    var rgb2xyz = function (r,g,b) {
        r = rgb_xyz(r);
        g = rgb_xyz(g);
        b = rgb_xyz(b);
        var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / labConstants.Xn);
        var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / labConstants.Yn);
        var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / labConstants.Zn);
        return [x,y,z];
    };

    var rgb2lab_1 = rgb2lab;

    var unpack$l = utils.unpack;
    var pow$1 = Math.pow;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var lab2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$l(args, 'lab');
        var l = args[0];
        var a = args[1];
        var b = args[2];
        var x,y,z, r,g,b_;

        y = (l + 16) / 116;
        x = isNaN(a) ? y : y + a / 500;
        z = isNaN(b) ? y : y - b / 200;

        y = labConstants.Yn * lab_xyz(y);
        x = labConstants.Xn * lab_xyz(x);
        z = labConstants.Zn * lab_xyz(z);

        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);  // D65 -> sRGB
        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);

        return [r,g,b_,args.length > 3 ? args[3] : 1];
    };

    var xyz_rgb = function (r) {
        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$1(r, 1 / 2.4) - 0.055)
    };

    var lab_xyz = function (t) {
        return t > labConstants.t1 ? t * t * t : labConstants.t2 * (t - labConstants.t0)
    };

    var lab2rgb_1 = lab2rgb;

    var unpack$m = utils.unpack;
    var type$9 = utils.type;






    Color_1.prototype.lab = function() {
        return rgb2lab_1(this._rgb);
    };

    chroma_1.lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['lab']) ));
    };

    input.format.lab = lab2rgb_1;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$m(args, 'lab');
            if (type$9(args) === 'array' && args.length === 3) {
                return 'lab';
            }
        }
    });

    var unpack$n = utils.unpack;
    var RAD2DEG = utils.RAD2DEG;
    var sqrt$1 = Math.sqrt;
    var atan2 = Math.atan2;
    var round$4 = Math.round;

    var lab2lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$n(args, 'lab');
        var l = ref[0];
        var a = ref[1];
        var b = ref[2];
        var c = sqrt$1(a * a + b * b);
        var h = (atan2(b, a) * RAD2DEG + 360) % 360;
        if (round$4(c*10000) === 0) { h = Number.NaN; }
        return [l, c, h];
    };

    var lab2lch_1 = lab2lch;

    var unpack$o = utils.unpack;



    var rgb2lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$o(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2lab_1(r,g,b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch_1(l,a,b_);
    };

    var rgb2lch_1 = rgb2lch;

    var unpack$p = utils.unpack;
    var DEG2RAD = utils.DEG2RAD;
    var sin = Math.sin;
    var cos$1 = Math.cos;

    var lch2lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.
        These formulas were invented by David Dalrymple to obtain maximum contrast without going
        out of gamut if the parameters are in the range 0-1.

        A saturation multiplier was added by Gregor Aisch
        */
        var ref = unpack$p(args, 'lch');
        var l = ref[0];
        var c = ref[1];
        var h = ref[2];
        if (isNaN(h)) { h = 0; }
        h = h * DEG2RAD;
        return [l, cos$1(h) * c, sin(h) * c]
    };

    var lch2lab_1 = lch2lab;

    var unpack$q = utils.unpack;



    var lch2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$q(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab_1 (l,c,h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = lab2rgb_1 (L,a,b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var lch2rgb_1 = lch2rgb;

    var unpack$r = utils.unpack;


    var hcl2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hcl = unpack$r(args, 'hcl').reverse();
        return lch2rgb_1.apply(void 0, hcl);
    };

    var hcl2rgb_1 = hcl2rgb;

    var unpack$s = utils.unpack;
    var type$a = utils.type;






    Color_1.prototype.lch = function() { return rgb2lch_1(this._rgb); };
    Color_1.prototype.hcl = function() { return rgb2lch_1(this._rgb).reverse(); };

    chroma_1.lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['lch']) ));
    };
    chroma_1.hcl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hcl']) ));
    };

    input.format.lch = lch2rgb_1;
    input.format.hcl = hcl2rgb_1;

    ['lch','hcl'].forEach(function (m) { return input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$s(args, m);
            if (type$a(args) === 'array' && args.length === 3) {
                return m;
            }
        }
    }); });

    var type$b = utils.type;





    Color_1.prototype.name = function() {
        var hex = rgb2hex_1(this._rgb, 'rgb');
        for (var i = 0, list = Object.keys(w3cx11_1); i < list.length; i += 1) {
            var n = list[i];

            if (w3cx11_1[n] === hex) { return n.toLowerCase(); }
        }
        return hex;
    };

    input.format.named = function (name) {
        name = name.toLowerCase();
        if (w3cx11_1[name]) { return hex2rgb_1(w3cx11_1[name]); }
        throw new Error('unknown color name: '+name);
    };

    input.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$b(h) === 'string' && w3cx11_1[h.toLowerCase()]) {
                return 'named';
            }
        }
    });

    var unpack$t = utils.unpack;

    var rgb2num = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$t(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        return (r << 16) + (g << 8) + b;
    };

    var rgb2num_1 = rgb2num;

    var type$c = utils.type;

    var num2rgb = function (num) {
        if (type$c(num) == "number" && num >= 0 && num <= 0xFFFFFF) {
            var r = num >> 16;
            var g = (num >> 8) & 0xFF;
            var b = num & 0xFF;
            return [r,g,b,1];
        }
        throw new Error("unknown num color: "+num);
    };

    var num2rgb_1 = num2rgb;

    var type$d = utils.type;



    Color_1.prototype.num = function() {
        return rgb2num_1(this._rgb);
    };

    chroma_1.num = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['num']) ));
    };

    input.format.num = num2rgb_1;

    input.autodetect.push({
        p: 5,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            if (args.length === 1 && type$d(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {
                return 'num';
            }
        }
    });

    var unpack$u = utils.unpack;
    var type$e = utils.type;
    var round$5 = Math.round;

    Color_1.prototype.rgb = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        if (rnd === false) { return this._rgb.slice(0,3); }
        return this._rgb.slice(0,3).map(round$5);
    };

    Color_1.prototype.rgba = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        return this._rgb.slice(0,4).map(function (v,i) {
            return i<3 ? (rnd === false ? v : round$5(v)) : v;
        });
    };

    chroma_1.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['rgb']) ));
    };

    input.format.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$u(args, 'rgba');
        if (rgba[3] === undefined) { rgba[3] = 1; }
        return rgba;
    };

    input.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$u(args, 'rgba');
            if (type$e(args) === 'array' && (args.length === 3 ||
                args.length === 4 && type$e(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {
                return 'rgb';
            }
        }
    });

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     */

    var log = Math.log;

    var temperature2rgb = function (kelvin) {
        var temp = kelvin / 100;
        var r,g,b;
        if (temp < 66) {
            r = 255;
            g = -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log(g);
            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log(b);
        } else {
            r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log(r);
            g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log(g);
            b = 255;
        }
        return [r,g,b,1];
    };

    var temperature2rgb_1 = temperature2rgb;

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     **/


    var unpack$v = utils.unpack;
    var round$6 = Math.round;

    var rgb2temperature = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$v(args, 'rgb');
        var r = rgb[0], b = rgb[2];
        var minTemp = 1000;
        var maxTemp = 40000;
        var eps = 0.4;
        var temp;
        while (maxTemp - minTemp > eps) {
            temp = (maxTemp + minTemp) * 0.5;
            var rgb$1 = temperature2rgb_1(temp);
            if ((rgb$1[2] / rgb$1[0]) >= (b / r)) {
                maxTemp = temp;
            } else {
                minTemp = temp;
            }
        }
        return round$6(temp);
    };

    var rgb2temperature_1 = rgb2temperature;

    Color_1.prototype.temp =
    Color_1.prototype.kelvin =
    Color_1.prototype.temperature = function() {
        return rgb2temperature_1(this._rgb);
    };

    chroma_1.temp =
    chroma_1.kelvin =
    chroma_1.temperature = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['temp']) ));
    };

    input.format.temp =
    input.format.kelvin =
    input.format.temperature = temperature2rgb_1;

    var type$f = utils.type;

    Color_1.prototype.alpha = function(a, mutate) {
        if ( mutate === void 0 ) mutate=false;

        if (a !== undefined && type$f(a) === 'number') {
            if (mutate) {
                this._rgb[3] = a;
                return this;
            }
            return new Color_1([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');
        }
        return this._rgb[3];
    };

    Color_1.prototype.clipped = function() {
        return this._rgb._clipped || false;
    };

    Color_1.prototype.darken = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lab = me.lab();
    	lab[0] -= labConstants.Kn * amount;
    	return new Color_1(lab, 'lab').alpha(me.alpha(), true);
    };

    Color_1.prototype.brighten = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.darken(-amount);
    };

    Color_1.prototype.darker = Color_1.prototype.darken;
    Color_1.prototype.brighter = Color_1.prototype.brighten;

    Color_1.prototype.get = function(mc) {
        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel);
            if (i > -1) { return src[i]; }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var type$g = utils.type;
    var pow$2 = Math.pow;

    var EPS = 1e-7;
    var MAX_ITER = 20;

    Color_1.prototype.luminance = function(lum) {
        if (lum !== undefined && type$g(lum) === 'number') {
            if (lum === 0) {
                // return pure black
                return new Color_1([0,0,0,this._rgb[3]], 'rgb');
            }
            if (lum === 1) {
                // return pure white
                return new Color_1([255,255,255,this._rgb[3]], 'rgb');
            }
            // compute new color using...
            var cur_lum = this.luminance();
            var mode = 'rgb';
            var max_iter = MAX_ITER;

            var test = function (low, high) {
                var mid = low.interpolate(high, 0.5, mode);
                var lm = mid.luminance();
                if (Math.abs(lum - lm) < EPS || !max_iter--) {
                    // close enough
                    return mid;
                }
                return lm > lum ? test(low, mid) : test(mid, high);
            };

            var rgb = (cur_lum > lum ? test(new Color_1([0,0,0]), this) : test(this, new Color_1([255,255,255]))).rgb();
            return new Color_1(rgb.concat( [this._rgb[3]]));
        }
        return rgb2luminance.apply(void 0, (this._rgb).slice(0,3));
    };


    var rgb2luminance = function (r,g,b) {
        // relative luminance
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        r = luminance_x(r);
        g = luminance_x(g);
        b = luminance_x(b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    };

    var luminance_x = function (x) {
        x /= 255;
        return x <= 0.03928 ? x/12.92 : pow$2((x+0.055)/1.055, 2.4);
    };

    var interpolator = {};

    var type$h = utils.type;


    var mix = function (col1, col2, f) {
        if ( f === void 0 ) f=0.5;
        var rest = [], len = arguments.length - 3;
        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];

        var mode = rest[0] || 'lrgb';
        if (!interpolator[mode] && !rest.length) {
            // fall back to the first supported mode
            mode = Object.keys(interpolator)[0];
        }
        if (!interpolator[mode]) {
            throw new Error(("interpolation mode " + mode + " is not defined"));
        }
        if (type$h(col1) !== 'object') { col1 = new Color_1(col1); }
        if (type$h(col2) !== 'object') { col2 = new Color_1(col2); }
        return interpolator[mode](col1, col2, f)
            .alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
    };

    Color_1.prototype.mix =
    Color_1.prototype.interpolate = function(col2, f) {
    	if ( f === void 0 ) f=0.5;
    	var rest = [], len = arguments.length - 2;
    	while ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];

    	return mix.apply(void 0, [ this, col2, f ].concat( rest ));
    };

    Color_1.prototype.premultiply = function(mutate) {
    	if ( mutate === void 0 ) mutate=false;

    	var rgb = this._rgb;
    	var a = rgb[3];
    	if (mutate) {
    		this._rgb = [rgb[0]*a, rgb[1]*a, rgb[2]*a, a];
    		return this;
    	} else {
    		return new Color_1([rgb[0]*a, rgb[1]*a, rgb[2]*a, a], 'rgb');
    	}
    };

    Color_1.prototype.saturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lch = me.lch();
    	lch[1] += labConstants.Kn * amount;
    	if (lch[1] < 0) { lch[1] = 0; }
    	return new Color_1(lch, 'lch').alpha(me.alpha(), true);
    };

    Color_1.prototype.desaturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.saturate(-amount);
    };

    var type$i = utils.type;

    Color_1.prototype.set = function(mc, value, mutate) {
        if ( mutate === void 0 ) mutate=false;

        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel);
            if (i > -1) {
                if (type$i(value) == 'string') {
                    switch(value.charAt(0)) {
                        case '+': src[i] += +value; break;
                        case '-': src[i] += +value; break;
                        case '*': src[i] *= +(value.substr(1)); break;
                        case '/': src[i] /= +(value.substr(1)); break;
                        default: src[i] = +value;
                    }
                } else if (type$i(value) === 'number') {
                    src[i] = value;
                } else {
                    throw new Error("unsupported value for Color.set");
                }
                var out = new Color_1(src, mode);
                if (mutate) {
                    this._rgb = out._rgb;
                    return this;
                }
                return out;
            }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var rgb$1 = function (col1, col2, f) {
        var xyz0 = col1._rgb;
        var xyz1 = col2._rgb;
        return new Color_1(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'rgb'
        )
    };

    // register interpolator
    interpolator.rgb = rgb$1;

    var sqrt$2 = Math.sqrt;
    var pow$3 = Math.pow;

    var lrgb = function (col1, col2, f) {
        var ref = col1._rgb;
        var x1 = ref[0];
        var y1 = ref[1];
        var z1 = ref[2];
        var ref$1 = col2._rgb;
        var x2 = ref$1[0];
        var y2 = ref$1[1];
        var z2 = ref$1[2];
        return new Color_1(
            sqrt$2(pow$3(x1,2) * (1-f) + pow$3(x2,2) * f),
            sqrt$2(pow$3(y1,2) * (1-f) + pow$3(y2,2) * f),
            sqrt$2(pow$3(z1,2) * (1-f) + pow$3(z2,2) * f),
            'rgb'
        )
    };

    // register interpolator
    interpolator.lrgb = lrgb;

    var lab$1 = function (col1, col2, f) {
        var xyz0 = col1.lab();
        var xyz1 = col2.lab();
        return new Color_1(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'lab'
        )
    };

    // register interpolator
    interpolator.lab = lab$1;

    var _hsx = function (col1, col2, f, m) {
        var assign, assign$1;

        var xyz0, xyz1;
        if (m === 'hsl') {
            xyz0 = col1.hsl();
            xyz1 = col2.hsl();
        } else if (m === 'hsv') {
            xyz0 = col1.hsv();
            xyz1 = col2.hsv();
        } else if (m === 'hcg') {
            xyz0 = col1.hcg();
            xyz1 = col2.hcg();
        } else if (m === 'hsi') {
            xyz0 = col1.hsi();
            xyz1 = col2.hsi();
        } else if (m === 'lch' || m === 'hcl') {
            m = 'hcl';
            xyz0 = col1.hcl();
            xyz1 = col2.hcl();
        }

        var hue0, hue1, sat0, sat1, lbv0, lbv1;
        if (m.substr(0, 1) === 'h') {
            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);
            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);
        }

        var sat, hue, lbv, dh;

        if (!isNaN(hue0) && !isNaN(hue1)) {
            // both colors have hue
            if (hue1 > hue0 && hue1 - hue0 > 180) {
                dh = hue1-(hue0+360);
            } else if (hue1 < hue0 && hue0 - hue1 > 180) {
                dh = hue1+360-hue0;
            } else{
                dh = hue1 - hue0;
            }
            hue = hue0 + f * dh;
        } else if (!isNaN(hue0)) {
            hue = hue0;
            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }
        } else if (!isNaN(hue1)) {
            hue = hue1;
            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }
        } else {
            hue = Number.NaN;
        }

        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }
        lbv = lbv0 + f * (lbv1-lbv0);
        return new Color_1([hue, sat, lbv], m);
    };

    var lch$1 = function (col1, col2, f) {
    	return _hsx(col1, col2, f, 'lch');
    };

    // register interpolator
    interpolator.lch = lch$1;
    interpolator.hcl = lch$1;

    var num$1 = function (col1, col2, f) {
        var c1 = col1.num();
        var c2 = col2.num();
        return new Color_1(c1 + f * (c2-c1), 'num')
    };

    // register interpolator
    interpolator.num = num$1;

    var hcg$1 = function (col1, col2, f) {
    	return _hsx(col1, col2, f, 'hcg');
    };

    // register interpolator
    interpolator.hcg = hcg$1;

    var hsi$1 = function (col1, col2, f) {
    	return _hsx(col1, col2, f, 'hsi');
    };

    // register interpolator
    interpolator.hsi = hsi$1;

    var hsl$1 = function (col1, col2, f) {
    	return _hsx(col1, col2, f, 'hsl');
    };

    // register interpolator
    interpolator.hsl = hsl$1;

    var hsv$1 = function (col1, col2, f) {
    	return _hsx(col1, col2, f, 'hsv');
    };

    // register interpolator
    interpolator.hsv = hsv$1;

    var clip_rgb$2 = utils.clip_rgb;
    var pow$4 = Math.pow;
    var sqrt$3 = Math.sqrt;
    var PI$1 = Math.PI;
    var cos$2 = Math.cos;
    var sin$1 = Math.sin;
    var atan2$1 = Math.atan2;

    var average = function (colors, mode) {
        if ( mode === void 0 ) mode='lrgb';

        var l = colors.length;
        // convert colors to Color objects
        colors = colors.map(function (c) { return new Color_1(c); });
        if (mode === 'lrgb') {
            return _average_lrgb(colors)
        }
        var first = colors.shift();
        var xyz = first.get(mode);
        var cnt = [];
        var dx = 0;
        var dy = 0;
        // initial color
        for (var i=0; i<xyz.length; i++) {
            xyz[i] = xyz[i] || 0;
            cnt.push(isNaN(xyz[i]) ? 0 : 1);
            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {
                var A = xyz[i] / 180 * PI$1;
                dx += cos$2(A);
                dy += sin$1(A);
            }
        }

        var alpha = first.alpha();
        colors.forEach(function (c) {
            var xyz2 = c.get(mode);
            alpha += c.alpha();
            for (var i=0; i<xyz.length; i++) {
                if (!isNaN(xyz2[i])) {
                    cnt[i]++;
                    if (mode.charAt(i) === 'h') {
                        var A = xyz2[i] / 180 * PI$1;
                        dx += cos$2(A);
                        dy += sin$1(A);
                    } else {
                        xyz[i] += xyz2[i];
                    }
                }
            }
        });

        for (var i$1=0; i$1<xyz.length; i$1++) {
            if (mode.charAt(i$1) === 'h') {
                var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;
                while (A$1 < 0) { A$1 += 360; }
                while (A$1 >= 360) { A$1 -= 360; }
                xyz[i$1] = A$1;
            } else {
                xyz[i$1] = xyz[i$1]/cnt[i$1];
            }
        }
        alpha /= l;
        return (new Color_1(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true);
    };


    var _average_lrgb = function (colors) {
        var l = colors.length;
        var f = 1/l;
        var xyz = [0,0,0,0];
        for (var i = 0, list = colors; i < list.length; i += 1) {
            var col = list[i];

            var rgb = col._rgb;
            xyz[0] += pow$4(rgb[0],2) * f;
            xyz[1] += pow$4(rgb[1],2) * f;
            xyz[2] += pow$4(rgb[2],2) * f;
            xyz[3] += rgb[3] * f;
        }
        xyz[0] = sqrt$3(xyz[0]);
        xyz[1] = sqrt$3(xyz[1]);
        xyz[2] = sqrt$3(xyz[2]);
        if (xyz[3] > 0.9999999) { xyz[3] = 1; }
        return new Color_1(clip_rgb$2(xyz));
    };

    // minimal multi-purpose interface

    // @requires utils color analyze


    var type$j = utils.type;

    var pow$5 = Math.pow;

    var scale = function(colors) {

        // constructor
        var _mode = 'rgb';
        var _nacol = chroma_1('#ccc');
        var _spread = 0;
        // const _fixed = false;
        var _domain = [0, 1];
        var _pos = [];
        var _padding = [0,0];
        var _classes = false;
        var _colors = [];
        var _out = false;
        var _min = 0;
        var _max = 1;
        var _correctLightness = false;
        var _colorCache = {};
        var _useCache = true;
        var _gamma = 1;

        // private methods

        var setColors = function(colors) {
            colors = colors || ['#fff', '#000'];
            if (colors && type$j(colors) === 'string' && chroma_1.brewer &&
                chroma_1.brewer[colors.toLowerCase()]) {
                colors = chroma_1.brewer[colors.toLowerCase()];
            }
            if (type$j(colors) === 'array') {
                // handle single color
                if (colors.length === 1) {
                    colors = [colors[0], colors[0]];
                }
                // make a copy of the colors
                colors = colors.slice(0);
                // convert to chroma classes
                for (var c=0; c<colors.length; c++) {
                    colors[c] = chroma_1(colors[c]);
                }
                // auto-fill color position
                _pos.length = 0;
                for (var c$1=0; c$1<colors.length; c$1++) {
                    _pos.push(c$1/(colors.length-1));
                }
            }
            resetCache();
            return _colors = colors;
        };

        var getClass = function(value) {
            if (_classes != null) {
                var n = _classes.length-1;
                var i = 0;
                while (i < n && value >= _classes[i]) {
                    i++;
                }
                return i-1;
            }
            return 0;
        };

        var tmap = function (t) { return t; };

        // const classifyValue = function(value) {
        //     let val = value;
        //     if (_classes.length > 2) {
        //         const n = _classes.length-1;
        //         const i = getClass(value);
        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class
        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class
        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));
        //     }
        //     return val;
        // };

        var getColor = function(val, bypassMap) {
            var col, t;
            if (bypassMap == null) { bypassMap = false; }
            if (isNaN(val) || (val === null)) { return _nacol; }
            if (!bypassMap) {
                if (_classes && (_classes.length > 2)) {
                    // find the class
                    var c = getClass(val);
                    t = c / (_classes.length-2);
                } else if (_max !== _min) {
                    // just interpolate between min/max
                    t = (val - _min) / (_max - _min);
                } else {
                    t = 1;
                }
            } else {
                t = val;
            }

            if (!bypassMap) {
                t = tmap(t);  // lightness correction
            }

            if (_gamma !== 1) { t = pow$5(t, _gamma); }

            t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));

            t = Math.min(1, Math.max(0, t));

            var k = Math.floor(t * 10000);

            if (_useCache && _colorCache[k]) {
                col = _colorCache[k];
            } else {
                if (type$j(_colors) === 'array') {
                    //for i in [0.._pos.length-1]
                    for (var i=0; i<_pos.length; i++) {
                        var p = _pos[i];
                        if (t <= p) {
                            col = _colors[i];
                            break;
                        }
                        if ((t >= p) && (i === (_pos.length-1))) {
                            col = _colors[i];
                            break;
                        }
                        if (t > p && t < _pos[i+1]) {
                            t = (t-p)/(_pos[i+1]-p);
                            col = chroma_1.interpolate(_colors[i], _colors[i+1], t, _mode);
                            break;
                        }
                    }
                } else if (type$j(_colors) === 'function') {
                    col = _colors(t);
                }
                if (_useCache) { _colorCache[k] = col; }
            }
            return col;
        };

        var resetCache = function () { return _colorCache = {}; };

        setColors(colors);

        // public interface

        var f = function(v) {
            var c = chroma_1(getColor(v));
            if (_out && c[_out]) { return c[_out](); } else { return c; }
        };

        f.classes = function(classes) {
            if (classes != null) {
                if (type$j(classes) === 'array') {
                    _classes = classes;
                    _domain = [classes[0], classes[classes.length-1]];
                } else {
                    var d = chroma_1.analyze(_domain);
                    if (classes === 0) {
                        _classes = [d.min, d.max];
                    } else {
                        _classes = chroma_1.limits(d, 'e', classes);
                    }
                }
                return f;
            }
            return _classes;
        };


        f.domain = function(domain) {
            if (!arguments.length) {
                return _domain;
            }
            _min = domain[0];
            _max = domain[domain.length-1];
            _pos = [];
            var k = _colors.length;
            if ((domain.length === k) && (_min !== _max)) {
                // update positions
                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {
                    var d = list[i];

                  _pos.push((d-_min) / (_max-_min));
                }
            } else {
                for (var c=0; c<k; c++) {
                    _pos.push(c/(k-1));
                }
            }
            _domain = [_min, _max];
            return f;
        };

        f.mode = function(_m) {
            if (!arguments.length) {
                return _mode;
            }
            _mode = _m;
            resetCache();
            return f;
        };

        f.range = function(colors, _pos) {
            setColors(colors, _pos);
            return f;
        };

        f.out = function(_o) {
            _out = _o;
            return f;
        };

        f.spread = function(val) {
            if (!arguments.length) {
                return _spread;
            }
            _spread = val;
            return f;
        };

        f.correctLightness = function(v) {
            if (v == null) { v = true; }
            _correctLightness = v;
            resetCache();
            if (_correctLightness) {
                tmap = function(t) {
                    var L0 = getColor(0, true).lab()[0];
                    var L1 = getColor(1, true).lab()[0];
                    var pol = L0 > L1;
                    var L_actual = getColor(t, true).lab()[0];
                    var L_ideal = L0 + ((L1 - L0) * t);
                    var L_diff = L_actual - L_ideal;
                    var t0 = 0;
                    var t1 = 1;
                    var max_iter = 20;
                    while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {
                        (function() {
                            if (pol) { L_diff *= -1; }
                            if (L_diff < 0) {
                                t0 = t;
                                t += (t1 - t) * 0.5;
                            } else {
                                t1 = t;
                                t += (t0 - t) * 0.5;
                            }
                            L_actual = getColor(t, true).lab()[0];
                            return L_diff = L_actual - L_ideal;
                        })();
                    }
                    return t;
                };
            } else {
                tmap = function (t) { return t; };
            }
            return f;
        };

        f.padding = function(p) {
            if (p != null) {
                if (type$j(p) === 'number') {
                    p = [p,p];
                }
                _padding = p;
                return f;
            } else {
                return _padding;
            }
        };

        f.colors = function(numColors, out) {
            // If no arguments are given, return the original colors that were provided
            if (arguments.length < 2) { out = 'hex'; }
            var result = [];

            if (arguments.length === 0) {
                result = _colors.slice(0);

            } else if (numColors === 1) {
                result = [f(0.5)];

            } else if (numColors > 1) {
                var dm = _domain[0];
                var dd = _domain[1] - dm;
                result = __range__(0, numColors, false).map(function (i) { return f( dm + ((i/(numColors-1)) * dd) ); });

            } else { // returns all colors based on the defined classes
                colors = [];
                var samples = [];
                if (_classes && (_classes.length > 2)) {
                    for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
                        samples.push((_classes[i-1]+_classes[i])*0.5);
                    }
                } else {
                    samples = _domain;
                }
                result = samples.map(function (v) { return f(v); });
            }

            if (chroma_1[out]) {
                result = result.map(function (c) { return c[out](); });
            }
            return result;
        };

        f.cache = function(c) {
            if (c != null) {
                _useCache = c;
                return f;
            } else {
                return _useCache;
            }
        };

        f.gamma = function(g) {
            if (g != null) {
                _gamma = g;
                return f;
            } else {
                return _gamma;
            }
        };

        f.nodata = function(d) {
            if (d != null) {
                _nacol = chroma_1(d);
                return f;
            } else {
                return _nacol;
            }
        };

        return f;
    };

    function __range__(left, right, inclusive) {
      var range = [];
      var ascending = left < right;
      var end = !inclusive ? right : ascending ? right + 1 : right - 1;
      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
        range.push(i);
      }
      return range;
    }

    //
    // interpolates between a set of colors uzing a bezier spline
    //

    // @requires utils lab




    var bezier = function(colors) {
        var assign, assign$1, assign$2;

        var I, lab0, lab1, lab2;
        colors = colors.map(function (c) { return new Color_1(c); });
        if (colors.length === 2) {
            // linear interpolation
            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return lab0[i] + (t * (lab1[i] - lab0[i])); }));
                return new Color_1(lab, 'lab');
            };
        } else if (colors.length === 3) {
            // quadratic bezier interpolation
            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i]); }));
                return new Color_1(lab, 'lab');
            };
        } else if (colors.length === 4) {
            // cubic bezier interpolation
            var lab3;
            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * lab1[i]) + (3 * (1-t) * t * t * lab2[i]) + (t*t*t * lab3[i]); }));
                return new Color_1(lab, 'lab');
            };
        } else if (colors.length === 5) {
            var I0 = bezier(colors.slice(0, 3));
            var I1 = bezier(colors.slice(2, 5));
            I = function(t) {
                if (t < 0.5) {
                    return I0(t*2);
                } else {
                    return I1((t-0.5)*2);
                }
            };
        }
        return I;
    };

    var bezier_1 = function (colors) {
        var f = bezier(colors);
        f.scale = function () { return scale(f); };
        return f;
    };

    /*
     * interpolates between a set of colors uzing a bezier spline
     * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/
     */




    var blend = function (bottom, top, mode) {
        if (!blend[mode]) {
            throw new Error('unknown blend mode ' + mode);
        }
        return blend[mode](bottom, top);
    };

    var blend_f = function (f) { return function (bottom,top) {
            var c0 = chroma_1(top).rgb();
            var c1 = chroma_1(bottom).rgb();
            return chroma_1.rgb(f(c0, c1));
        }; };

    var each = function (f) { return function (c0, c1) {
            var out = [];
            out[0] = f(c0[0], c1[0]);
            out[1] = f(c0[1], c1[1]);
            out[2] = f(c0[2], c1[2]);
            return out;
        }; };

    var normal = function (a) { return a; };
    var multiply = function (a,b) { return a * b / 255; };
    var darken$1 = function (a,b) { return a > b ? b : a; };
    var lighten = function (a,b) { return a > b ? a : b; };
    var screen = function (a,b) { return 255 * (1 - (1-a/255) * (1-b/255)); };
    var overlay = function (a,b) { return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255 ) * ( 1 - b / 255 )); };
    var burn = function (a,b) { return 255 * (1 - (1 - b / 255) / (a/255)); };
    var dodge = function (a,b) {
        if (a === 255) { return 255; }
        a = 255 * (b / 255) / (1 - a / 255);
        return a > 255 ? 255 : a
    };

    // # add = (a,b) ->
    // #     if (a + b > 255) then 255 else a + b

    blend.normal = blend_f(each(normal));
    blend.multiply = blend_f(each(multiply));
    blend.screen = blend_f(each(screen));
    blend.overlay = blend_f(each(overlay));
    blend.darken = blend_f(each(darken$1));
    blend.lighten = blend_f(each(lighten));
    blend.dodge = blend_f(each(dodge));
    blend.burn = blend_f(each(burn));
    // blend.add = blend_f(each(add));

    var blend_1 = blend;

    // cubehelix interpolation
    // based on D.A. Green "A colour scheme for the display of astronomical intensity images"
    // http://astron-soc.in/bulletin/11June/289392011.pdf

    var type$k = utils.type;
    var clip_rgb$3 = utils.clip_rgb;
    var TWOPI$2 = utils.TWOPI;
    var pow$6 = Math.pow;
    var sin$2 = Math.sin;
    var cos$3 = Math.cos;


    var cubehelix = function(start, rotations, hue, gamma, lightness) {
        if ( start === void 0 ) start=300;
        if ( rotations === void 0 ) rotations=-1.5;
        if ( hue === void 0 ) hue=1;
        if ( gamma === void 0 ) gamma=1;
        if ( lightness === void 0 ) lightness=[0,1];

        var dh = 0, dl;
        if (type$k(lightness) === 'array') {
            dl = lightness[1] - lightness[0];
        } else {
            dl = 0;
            lightness = [lightness, lightness];
        }

        var f = function(fract) {
            var a = TWOPI$2 * (((start+120)/360) + (rotations * fract));
            var l = pow$6(lightness[0] + (dl * fract), gamma);
            var h = dh !== 0 ? hue[0] + (fract * dh) : hue;
            var amp = (h * l * (1-l)) / 2;
            var cos_a = cos$3(a);
            var sin_a = sin$2(a);
            var r = l + (amp * ((-0.14861 * cos_a) + (1.78277* sin_a)));
            var g = l + (amp * ((-0.29227 * cos_a) - (0.90649* sin_a)));
            var b = l + (amp * (+1.97294 * cos_a));
            return chroma_1(clip_rgb$3([r*255,g*255,b*255,1]));
        };

        f.start = function(s) {
            if ((s == null)) { return start; }
            start = s;
            return f;
        };

        f.rotations = function(r) {
            if ((r == null)) { return rotations; }
            rotations = r;
            return f;
        };

        f.gamma = function(g) {
            if ((g == null)) { return gamma; }
            gamma = g;
            return f;
        };

        f.hue = function(h) {
            if ((h == null)) { return hue; }
            hue = h;
            if (type$k(hue) === 'array') {
                dh = hue[1] - hue[0];
                if (dh === 0) { hue = hue[1]; }
            } else {
                dh = 0;
            }
            return f;
        };

        f.lightness = function(h) {
            if ((h == null)) { return lightness; }
            if (type$k(h) === 'array') {
                lightness = h;
                dl = h[1] - h[0];
            } else {
                lightness = [h,h];
                dl = 0;
            }
            return f;
        };

        f.scale = function () { return chroma_1.scale(f); };

        f.hue(hue);

        return f;
    };

    var digits = '0123456789abcdef';

    var floor$2 = Math.floor;
    var random = Math.random;

    var random_1 = function () {
        var code = '#';
        for (var i=0; i<6; i++) {
            code += digits.charAt(floor$2(random() * 16));
        }
        return new Color_1(code, 'hex');
    };

    var log$1 = Math.log;
    var pow$7 = Math.pow;
    var floor$3 = Math.floor;
    var abs = Math.abs;


    var analyze = function (data, key) {
        if ( key === void 0 ) key=null;

        var r = {
            min: Number.MAX_VALUE,
            max: Number.MAX_VALUE*-1,
            sum: 0,
            values: [],
            count: 0
        };
        if (type(data) === 'object') {
            data = Object.values(data);
        }
        data.forEach(function (val) {
            if (key && type(val) === 'object') { val = val[key]; }
            if (val !== undefined && val !== null && !isNaN(val)) {
                r.values.push(val);
                r.sum += val;
                if (val < r.min) { r.min = val; }
                if (val > r.max) { r.max = val; }
                r.count += 1;
            }
        });

        r.domain = [r.min, r.max];

        r.limits = function (mode, num) { return limits(r, mode, num); };

        return r;
    };


    var limits = function (data, mode, num) {
        if ( mode === void 0 ) mode='equal';
        if ( num === void 0 ) num=7;

        if (type(data) == 'array') {
            data = analyze(data);
        }
        var min = data.min;
        var max = data.max;
        var values = data.values.sort(function (a,b) { return a-b; });

        if (num === 1) { return [min,max]; }

        var limits = [];

        if (mode.substr(0,1) === 'c') { // continuous
            limits.push(min);
            limits.push(max);
        }

        if (mode.substr(0,1) === 'e') { // equal interval
            limits.push(min);
            for (var i=1; i<num; i++) {
                limits.push(min+((i/num)*(max-min)));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'l') { // log scale
            if (min <= 0) {
                throw new Error('Logarithmic scales are only possible for values > 0');
            }
            var min_log = Math.LOG10E * log$1(min);
            var max_log = Math.LOG10E * log$1(max);
            limits.push(min);
            for (var i$1=1; i$1<num; i$1++) {
                limits.push(pow$7(10, min_log + ((i$1/num) * (max_log - min_log))));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'q') { // quantile scale
            limits.push(min);
            for (var i$2=1; i$2<num; i$2++) {
                var p = ((values.length-1) * i$2)/num;
                var pb = floor$3(p);
                if (pb === p) {
                    limits.push(values[pb]);
                } else { // p > pb
                    var pr = p - pb;
                    limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));
                }
            }
            limits.push(max);

        }

        else if (mode.substr(0,1) === 'k') { // k-means clustering
            /*
            implementation based on
            http://code.google.com/p/figue/source/browse/trunk/figue.js#336
            simplified for 1-d input values
            */
            var cluster;
            var n = values.length;
            var assignments = new Array(n);
            var clusterSizes = new Array(num);
            var repeat = true;
            var nb_iters = 0;
            var centroids = null;

            // get seed values
            centroids = [];
            centroids.push(min);
            for (var i$3=1; i$3<num; i$3++) {
                centroids.push(min + ((i$3/num) * (max-min)));
            }
            centroids.push(max);

            while (repeat) {
                // assignment step
                for (var j=0; j<num; j++) {
                    clusterSizes[j] = 0;
                }
                for (var i$4=0; i$4<n; i$4++) {
                    var value = values[i$4];
                    var mindist = Number.MAX_VALUE;
                    var best = (void 0);
                    for (var j$1=0; j$1<num; j$1++) {
                        var dist = abs(centroids[j$1]-value);
                        if (dist < mindist) {
                            mindist = dist;
                            best = j$1;
                        }
                        clusterSizes[best]++;
                        assignments[i$4] = best;
                    }
                }

                // update centroids step
                var newCentroids = new Array(num);
                for (var j$2=0; j$2<num; j$2++) {
                    newCentroids[j$2] = null;
                }
                for (var i$5=0; i$5<n; i$5++) {
                    cluster = assignments[i$5];
                    if (newCentroids[cluster] === null) {
                        newCentroids[cluster] = values[i$5];
                    } else {
                        newCentroids[cluster] += values[i$5];
                    }
                }
                for (var j$3=0; j$3<num; j$3++) {
                    newCentroids[j$3] *= 1/clusterSizes[j$3];
                }

                // check convergence
                repeat = false;
                for (var j$4=0; j$4<num; j$4++) {
                    if (newCentroids[j$4] !== centroids[j$4]) {
                        repeat = true;
                        break;
                    }
                }

                centroids = newCentroids;
                nb_iters++;

                if (nb_iters > 200) {
                    repeat = false;
                }
            }

            // finished k-means clustering
            // the next part is borrowed from gabrielflor.it
            var kClusters = {};
            for (var j$5=0; j$5<num; j$5++) {
                kClusters[j$5] = [];
            }
            for (var i$6=0; i$6<n; i$6++) {
                cluster = assignments[i$6];
                kClusters[cluster].push(values[i$6]);
            }
            var tmpKMeansBreaks = [];
            for (var j$6=0; j$6<num; j$6++) {
                tmpKMeansBreaks.push(kClusters[j$6][0]);
                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length-1]);
            }
            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a,b){ return a-b; });
            limits.push(tmpKMeansBreaks[0]);
            for (var i$7=1; i$7 < tmpKMeansBreaks.length; i$7+= 2) {
                var v = tmpKMeansBreaks[i$7];
                if (!isNaN(v) && (limits.indexOf(v) === -1)) {
                    limits.push(v);
                }
            }
        }
        return limits;
    };

    var analyze_1 = {analyze: analyze, limits: limits};

    var contrast = function (a, b) {
        // WCAG contrast ratio
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
        a = new Color_1(a);
        b = new Color_1(b);
        var l1 = a.luminance();
        var l2 = b.luminance();
        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
    };

    var sqrt$4 = Math.sqrt;
    var atan2$2 = Math.atan2;
    var abs$1 = Math.abs;
    var cos$4 = Math.cos;
    var PI$2 = Math.PI;

    var deltaE = function(a, b, L, C) {
        if ( L === void 0 ) L=1;
        if ( C === void 0 ) C=1;

        // Delta E (CMC)
        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CMC.html
        a = new Color_1(a);
        b = new Color_1(b);
        var ref = Array.from(a.lab());
        var L1 = ref[0];
        var a1 = ref[1];
        var b1 = ref[2];
        var ref$1 = Array.from(b.lab());
        var L2 = ref$1[0];
        var a2 = ref$1[1];
        var b2 = ref$1[2];
        var c1 = sqrt$4((a1 * a1) + (b1 * b1));
        var c2 = sqrt$4((a2 * a2) + (b2 * b2));
        var sl = L1 < 16.0 ? 0.511 : (0.040975 * L1) / (1.0 + (0.01765 * L1));
        var sc = ((0.0638 * c1) / (1.0 + (0.0131 * c1))) + 0.638;
        var h1 = c1 < 0.000001 ? 0.0 : (atan2$2(b1, a1) * 180.0) / PI$2;
        while (h1 < 0) { h1 += 360; }
        while (h1 >= 360) { h1 -= 360; }
        var t = (h1 >= 164.0) && (h1 <= 345.0) ? (0.56 + abs$1(0.2 * cos$4((PI$2 * (h1 + 168.0)) / 180.0))) : (0.36 + abs$1(0.4 * cos$4((PI$2 * (h1 + 35.0)) / 180.0)));
        var c4 = c1 * c1 * c1 * c1;
        var f = sqrt$4(c4 / (c4 + 1900.0));
        var sh = sc * (((f * t) + 1.0) - f);
        var delL = L1 - L2;
        var delC = c1 - c2;
        var delA = a1 - a2;
        var delB = b1 - b2;
        var dH2 = ((delA * delA) + (delB * delB)) - (delC * delC);
        var v1 = delL / (L * sl);
        var v2 = delC / (C * sc);
        var v3 = sh;
        return sqrt$4((v1 * v1) + (v2 * v2) + (dH2 / (v3 * v3)));
    };

    // simple Euclidean distance
    var distance = function(a, b, mode) {
        if ( mode === void 0 ) mode='lab';

        // Delta E (CIE 1976)
        // see http://www.brucelindbloom.com/index.html?Equations.html
        a = new Color_1(a);
        b = new Color_1(b);
        var l1 = a.get(mode);
        var l2 = b.get(mode);
        var sum_sq = 0;
        for (var i in l1) {
            var d = (l1[i] || 0) - (l2[i] || 0);
            sum_sq += d*d;
        }
        return Math.sqrt(sum_sq);
    };

    var valid = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        try {
            new (Function.prototype.bind.apply( Color_1, [ null ].concat( args) ));
            return true;
        } catch (e) {
            return false;
        }
    };

    // some pre-defined color scales:




    var scales = {
    	cool: function cool() { return scale([chroma_1.hsl(180,1,.9), chroma_1.hsl(250,.7,.4)]) },
    	hot: function hot() { return scale(['#000','#f00','#ff0','#fff'], [0,.25,.75,1]).mode('rgb') }
    };

    /**
        ColorBrewer colors for chroma.js

        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
        Pennsylvania State University.

        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0

        Unless required by applicable law or agreed to in writing, software distributed
        under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
        CONDITIONS OF ANY KIND, either express or implied. See the License for the
        specific language governing permissions and limitations under the License.
    */

    var colorbrewer = {
        // sequential
        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],

        // diverging

        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],

        // qualitative

        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
    };

    // add lowercase aliases for case-insensitive matches
    for (var i$1 = 0, list$1 = Object.keys(colorbrewer); i$1 < list$1.length; i$1 += 1) {
        var key = list$1[i$1];

        colorbrewer[key.toLowerCase()] = colorbrewer[key];
    }

    var colorbrewer_1 = colorbrewer;

    // feel free to comment out anything to rollup
    // a smaller chroma.js built

    // io --> convert colors















    // operators --> modify existing Colors










    // interpolators










    // generators -- > create new colors
    chroma_1.average = average;
    chroma_1.bezier = bezier_1;
    chroma_1.blend = blend_1;
    chroma_1.cubehelix = cubehelix;
    chroma_1.mix = chroma_1.interpolate = mix;
    chroma_1.random = random_1;
    chroma_1.scale = scale;

    // other utility methods
    chroma_1.analyze = analyze_1.analyze;
    chroma_1.contrast = contrast;
    chroma_1.deltaE = deltaE;
    chroma_1.distance = distance;
    chroma_1.limits = analyze_1.limits;
    chroma_1.valid = valid;

    // scale
    chroma_1.scales = scales;

    // colors
    chroma_1.colors = w3cx11_1;
    chroma_1.brewer = colorbrewer_1;

    var chroma_js = chroma_1;

    return chroma_js;

})));

},{}],73:[function(require,module,exports){
(function (Buffer){
var clone = (function() {
'use strict';

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
*/
function clone(parent, circular, depth, prototype) {
  var filter;
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    filter = circular.filter;
    circular = circular.circular
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth == 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
};
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
};
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
};
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
};
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
};
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}

}).call(this,require("buffer").Buffer)
},{"buffer":4}],74:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/_core').Array.from;

},{"../../modules/_core":105,"../../modules/es6.array.from":171,"../../modules/es6.string.iterator":186}],75:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');

},{"../modules/core.get-iterator":169,"../modules/es6.string.iterator":186,"../modules/web.dom.iterable":196}],76:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.is-iterable');

},{"../modules/core.is-iterable":170,"../modules/es6.string.iterator":186,"../modules/web.dom.iterable":196}],77:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
require('../modules/es7.map.to-json');
require('../modules/es7.map.of');
require('../modules/es7.map.from');
module.exports = require('../modules/_core').Map;

},{"../modules/_core":105,"../modules/es6.map":173,"../modules/es6.object.to-string":183,"../modules/es6.string.iterator":186,"../modules/es7.map.from":188,"../modules/es7.map.of":189,"../modules/es7.map.to-json":190,"../modules/web.dom.iterable":196}],78:[function(require,module,exports){
require('../../modules/es6.number.epsilon');
module.exports = Math.pow(2, -52);

},{"../../modules/es6.number.epsilon":174}],79:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;

},{"../../modules/_core":105,"../../modules/es6.object.assign":175}],80:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};

},{"../../modules/_core":105,"../../modules/es6.object.create":176}],81:[function(require,module,exports){
require('../../modules/es6.object.define-properties');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperties(T, D) {
  return $Object.defineProperties(T, D);
};

},{"../../modules/_core":105,"../../modules/es6.object.define-properties":177}],82:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

},{"../../modules/_core":105,"../../modules/es6.object.define-property":178}],83:[function(require,module,exports){
require('../../modules/es6.object.freeze');
module.exports = require('../../modules/_core').Object.freeze;

},{"../../modules/_core":105,"../../modules/es6.object.freeze":179}],84:[function(require,module,exports){
require('../../modules/es6.object.get-own-property-descriptor');
var $Object = require('../../modules/_core').Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};

},{"../../modules/_core":105,"../../modules/es6.object.get-own-property-descriptor":180}],85:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;

},{"../../modules/_core":105,"../../modules/es6.object.keys":181}],86:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/_core').Object.setPrototypeOf;

},{"../../modules/_core":105,"../../modules/es6.object.set-prototype-of":182}],87:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
require('../modules/es7.set.of');
require('../modules/es7.set.from');
module.exports = require('../modules/_core').Set;

},{"../modules/_core":105,"../modules/es6.object.to-string":183,"../modules/es6.set":184,"../modules/es6.string.iterator":186,"../modules/es7.set.from":191,"../modules/es7.set.of":192,"../modules/es7.set.to-json":193,"../modules/web.dom.iterable":196}],88:[function(require,module,exports){
require('../../modules/es6.string.from-code-point');
module.exports = require('../../modules/_core').String.fromCodePoint;

},{"../../modules/_core":105,"../../modules/es6.string.from-code-point":185}],89:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":105,"../../modules/es6.object.to-string":183,"../../modules/es6.symbol":187,"../../modules/es7.symbol.async-iterator":194,"../../modules/es7.symbol.observable":195}],90:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":166,"../../modules/es6.string.iterator":186,"../../modules/web.dom.iterable":196}],91:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],92:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],93:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],94:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":124}],95:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":115}],96:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":157,"./_to-iobject":159,"./_to-length":160}],97:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":99,"./_ctx":107,"./_iobject":121,"./_to-length":160,"./_to-object":161}],98:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":123,"./_is-object":124,"./_wks":167}],99:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":98}],100:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":101,"./_wks":167}],101:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],102:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":93,"./_ctx":107,"./_descriptors":109,"./_for-of":115,"./_iter-define":127,"./_iter-step":129,"./_meta":132,"./_object-create":134,"./_object-dp":135,"./_redefine-all":147,"./_set-species":152,"./_validate-collection":164}],103:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":95,"./_classof":100}],104:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var meta = require('./_meta');
var fails = require('./_fails');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var setToStringTag = require('./_set-to-string-tag');
var dP = require('./_object-dp').f;
var each = require('./_array-methods')(0);
var DESCRIPTORS = require('./_descriptors');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":93,"./_array-methods":97,"./_descriptors":109,"./_export":113,"./_fails":114,"./_for-of":115,"./_global":116,"./_hide":118,"./_is-object":124,"./_meta":132,"./_object-dp":135,"./_redefine-all":147,"./_set-to-string-tag":153}],105:[function(require,module,exports){
var core = module.exports = { version: '2.6.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],106:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":135,"./_property-desc":146}],107:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":91}],108:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],109:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":114}],110:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":116,"./_is-object":124}],111:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],112:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":140,"./_object-keys":143,"./_object-pie":144}],113:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":105,"./_ctx":107,"./_global":116,"./_has":117,"./_hide":118}],114:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],115:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":94,"./_ctx":107,"./_is-array-iter":122,"./_iter-call":125,"./_to-length":160,"./core.get-iterator-method":168}],116:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],117:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],118:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":109,"./_object-dp":135,"./_property-desc":146}],119:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":116}],120:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":109,"./_dom-create":110,"./_fails":114}],121:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":101}],122:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":130,"./_wks":167}],123:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":101}],124:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],125:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":94}],126:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":118,"./_object-create":134,"./_property-desc":146,"./_set-to-string-tag":153,"./_wks":167}],127:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":113,"./_hide":118,"./_iter-create":126,"./_iterators":130,"./_library":131,"./_object-gpo":141,"./_redefine":148,"./_set-to-string-tag":153,"./_wks":167}],128:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":167}],129:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],130:[function(require,module,exports){
module.exports = {};

},{}],131:[function(require,module,exports){
module.exports = true;

},{}],132:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":114,"./_has":117,"./_is-object":124,"./_object-dp":135,"./_uid":163}],133:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":114,"./_iobject":121,"./_object-gops":140,"./_object-keys":143,"./_object-pie":144,"./_to-object":161}],134:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":94,"./_dom-create":110,"./_enum-bug-keys":111,"./_html":119,"./_object-dps":136,"./_shared-key":154}],135:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":94,"./_descriptors":109,"./_ie8-dom-define":120,"./_to-primitive":162}],136:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":94,"./_descriptors":109,"./_object-dp":135,"./_object-keys":143}],137:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":109,"./_has":117,"./_ie8-dom-define":120,"./_object-pie":144,"./_property-desc":146,"./_to-iobject":159,"./_to-primitive":162}],138:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":139,"./_to-iobject":159}],139:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":111,"./_object-keys-internal":142}],140:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],141:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":117,"./_shared-key":154,"./_to-object":161}],142:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":96,"./_has":117,"./_shared-key":154,"./_to-iobject":159}],143:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":111,"./_object-keys-internal":142}],144:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],145:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":105,"./_export":113,"./_fails":114}],146:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],147:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};

},{"./_hide":118}],148:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":118}],149:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":91,"./_ctx":107,"./_export":113,"./_for-of":115}],150:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":113}],151:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":94,"./_ctx":107,"./_is-object":124,"./_object-gopd":137}],152:[function(require,module,exports){
'use strict';
var global = require('./_global');
var core = require('./_core');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_core":105,"./_descriptors":109,"./_global":116,"./_object-dp":135,"./_wks":167}],153:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":117,"./_object-dp":135,"./_wks":167}],154:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":155,"./_uid":163}],155:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":105,"./_global":116,"./_library":131}],156:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":108,"./_to-integer":158}],157:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":158}],158:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],159:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":108,"./_iobject":121}],160:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":158}],161:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":108}],162:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":124}],163:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],164:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":124}],165:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":105,"./_global":116,"./_library":131,"./_object-dp":135,"./_wks-ext":166}],166:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":167}],167:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":116,"./_shared":155,"./_uid":163}],168:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":100,"./_core":105,"./_iterators":130,"./_wks":167}],169:[function(require,module,exports){
var anObject = require('./_an-object');
var get = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

},{"./_an-object":94,"./_core":105,"./core.get-iterator-method":168}],170:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};

},{"./_classof":100,"./_core":105,"./_iterators":130,"./_wks":167}],171:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":106,"./_ctx":107,"./_export":113,"./_is-array-iter":122,"./_iter-call":125,"./_iter-detect":128,"./_to-length":160,"./_to-object":161,"./core.get-iterator-method":168}],172:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":92,"./_iter-define":127,"./_iter-step":129,"./_iterators":130,"./_to-iobject":159}],173:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":104,"./_collection-strong":102,"./_validate-collection":164}],174:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":113}],175:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":113,"./_object-assign":133}],176:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":113,"./_object-create":134}],177:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":109,"./_export":113,"./_object-dps":136}],178:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":109,"./_export":113,"./_object-dp":135}],179:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":124,"./_meta":132,"./_object-sap":145}],180:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":137,"./_object-sap":145,"./_to-iobject":159}],181:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":143,"./_object-sap":145,"./_to-object":161}],182:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":113,"./_set-proto":151}],183:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],184:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":104,"./_collection-strong":102,"./_validate-collection":164}],185:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":113,"./_to-absolute-index":157}],186:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":127,"./_string-at":156}],187:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":94,"./_descriptors":109,"./_enum-keys":112,"./_export":113,"./_fails":114,"./_global":116,"./_has":117,"./_hide":118,"./_is-array":123,"./_is-object":124,"./_library":131,"./_meta":132,"./_object-create":134,"./_object-dp":135,"./_object-gopd":137,"./_object-gopn":139,"./_object-gopn-ext":138,"./_object-gops":140,"./_object-keys":143,"./_object-pie":144,"./_property-desc":146,"./_redefine":148,"./_set-to-string-tag":153,"./_shared":155,"./_to-iobject":159,"./_to-primitive":162,"./_uid":163,"./_wks":167,"./_wks-define":165,"./_wks-ext":166}],188:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":149}],189:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":150}],190:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":103,"./_export":113}],191:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":149}],192:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":150}],193:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":103,"./_export":113}],194:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":165}],195:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":165}],196:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":116,"./_hide":118,"./_iterators":130,"./_wks":167,"./es6.array.iterator":172}],197:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":198,"./lib/keys.js":199}],198:[function(require,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],199:[function(require,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}],200:[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.Delaunator = factory());
}(this, (function () { 'use strict';

    var EPSILON = Math.pow(2, -52);

    var Delaunator = function Delaunator(coords) {
        var this$1 = this;

        var n = coords.length >> 1;
        if (n > 0 && typeof coords[0] !== 'number') { throw new Error('Expected coords to contain numbers.'); }

        this.coords = coords;

        // arrays that will store the triangulation graph
        var maxTriangles = 2 * n - 5;
        var triangles = this.triangles = new Uint32Array(maxTriangles * 3);
        var halfedges = this.halfedges = new Int32Array(maxTriangles * 3);

        // temporary arrays for tracking the edges of the advancing convex hull
        this._hashSize = Math.ceil(Math.sqrt(n));
        var hullPrev = this.hullPrev = new Uint32Array(n); // edge to prev edge
        var hullNext = this.hullNext = new Uint32Array(n); // edge to next edge
        var hullTri = this.hullTri = new Uint32Array(n); // edge to adjacent triangle
        var hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

        // populate an array of point indices; calculate input data bbox
        var ids = new Uint32Array(n);
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;

        for (var i = 0; i < n; i++) {
            var x = coords[2 * i];
            var y = coords[2 * i + 1];
            if (x < minX) { minX = x; }
            if (y < minY) { minY = y; }
            if (x > maxX) { maxX = x; }
            if (y > maxY) { maxY = y; }
            ids[i] = i;
        }
        var cx = (minX + maxX) / 2;
        var cy = (minY + maxY) / 2;

        var minDist = Infinity;
        var i0, i1, i2;

        // pick a seed point close to the center
        for (var i$1 = 0; i$1 < n; i$1++) {
            var d = dist(cx, cy, coords[2 * i$1], coords[2 * i$1 + 1]);
            if (d < minDist) {
                i0 = i$1;
                minDist = d;
            }
        }
        var i0x = coords[2 * i0];
        var i0y = coords[2 * i0 + 1];

        minDist = Infinity;

        // find the point closest to the seed
        for (var i$2 = 0; i$2 < n; i$2++) {
            if (i$2 === i0) { continue; }
            var d$1 = dist(i0x, i0y, coords[2 * i$2], coords[2 * i$2 + 1]);
            if (d$1 < minDist && d$1 > 0) {
                i1 = i$2;
                minDist = d$1;
            }
        }
        var i1x = coords[2 * i1];
        var i1y = coords[2 * i1 + 1];

        var minRadius = Infinity;

        // find the third point which forms the smallest circumcircle with the first two
        for (var i$3 = 0; i$3 < n; i$3++) {
            if (i$3 === i0 || i$3 === i1) { continue; }
            var r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i$3], coords[2 * i$3 + 1]);
            if (r < minRadius) {
                i2 = i$3;
                minRadius = r;
            }
        }
        var i2x = coords[2 * i2];
        var i2y = coords[2 * i2 + 1];

        if (minRadius === Infinity) {
            throw new Error('No Delaunay triangulation exists for this input.');
        }

        // swap the order of the seed points for counter-clockwise orientation
        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
            var i$4 = i1;
            var x$1 = i1x;
            var y$1 = i1y;
            i1 = i2;
            i1x = i2x;
            i1y = i2y;
            i2 = i$4;
            i2x = x$1;
            i2y = y$1;
        }

        var center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
        this._cx = center.x;
        this._cy = center.y;

        var dists = new Float64Array(n);
        for (var i$5 = 0; i$5 < n; i$5++) {
            dists[i$5] = dist(coords[2 * i$5], coords[2 * i$5 + 1], center.x, center.y);
        }

        // sort the points by distance from the seed triangle circumcenter
        quicksort(ids, dists, 0, n - 1);

        // set up the seed triangle as the starting hull
        this.hullStart = i0;
        var hullSize = 3;

        hullNext[i0] = hullPrev[i2] = i1;
        hullNext[i1] = hullPrev[i0] = i2;
        hullNext[i2] = hullPrev[i1] = i0;

        hullTri[i0] = 0;
        hullTri[i1] = 1;
        hullTri[i2] = 2;

        hullHash[this._hashKey(i0x, i0y)] = i0;
        hullHash[this._hashKey(i1x, i1y)] = i1;
        hullHash[this._hashKey(i2x, i2y)] = i2;

        this.trianglesLen = 0;
        this._addTriangle(i0, i1, i2, -1, -1, -1);

        for (var k = 0, xp = (void 0), yp = (void 0); k < ids.length; k++) {
            var i$6 = ids[k];
            var x$2 = coords[2 * i$6];
            var y$2 = coords[2 * i$6 + 1];

            // skip near-duplicate points
            if (k > 0 && Math.abs(x$2 - xp) <= EPSILON && Math.abs(y$2 - yp) <= EPSILON) { continue; }
            xp = x$2;
            yp = y$2;

            // skip seed triangle points
            if (i$6 === i0 || i$6 === i1 || i$6 === i2) { continue; }

            // find a visible edge on the convex hull using edge hash
            var start = 0;
            for (var j = 0, key = this._hashKey(x$2, y$2); j < this._hashSize; j++) {
                start = hullHash[(key + j) % this$1._hashSize];
                if (start !== -1 && start !== hullNext[start]) { break; }
            }

            start = hullPrev[start];
            var e = start, q = (void 0);
            while (q = hullNext[e], !orient(x$2, y$2, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {
                e = q;
                if (e === start) {
                    e = -1;
                    break;
                }
            }
            if (e === -1) { continue; } // likely a near-duplicate point; skip it

            // add the first triangle from the point
            var t = this$1._addTriangle(e, i$6, hullNext[e], -1, -1, hullTri[e]);

            // recursively flip triangles from the point until they satisfy the Delaunay condition
            hullTri[i$6] = this$1._legalize(t + 2);
            hullTri[e] = t; // keep track of boundary triangles on the hull
            hullSize++;

            // walk forward through the hull, adding more triangles and flipping recursively
            var n$1 = hullNext[e];
            while (q = hullNext[n$1], orient(x$2, y$2, coords[2 * n$1], coords[2 * n$1 + 1], coords[2 * q], coords[2 * q + 1])) {
                t = this$1._addTriangle(n$1, i$6, q, hullTri[i$6], -1, hullTri[n$1]);
                hullTri[i$6] = this$1._legalize(t + 2);
                hullNext[n$1] = n$1; // mark as removed
                hullSize--;
                n$1 = q;
            }

            // walk backward from the other side, adding more triangles and flipping
            if (e === start) {
                while (q = hullPrev[e], orient(x$2, y$2, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
                    t = this$1._addTriangle(q, i$6, e, -1, hullTri[e], hullTri[q]);
                    this$1._legalize(t + 2);
                    hullTri[q] = t;
                    hullNext[e] = e; // mark as removed
                    hullSize--;
                    e = q;
                }
            }

            // update the hull indices
            this$1.hullStart = hullPrev[i$6] = e;
            hullNext[e] = hullPrev[n$1] = i$6;
            hullNext[i$6] = n$1;

            // save the two new edges in the hash table
            hullHash[this$1._hashKey(x$2, y$2)] = i$6;
            hullHash[this$1._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
        }

        this.hull = new Uint32Array(hullSize);
        for (var i$7 = 0, e$1 = this.hullStart; i$7 < hullSize; i$7++) {
            this$1.hull[i$7] = e$1;
            e$1 = hullNext[e$1];
        }
        this.hullPrev = this.hullNext = this.hullTri = null; // get rid of temporary arrays

        // trim typed triangle mesh arrays
        this.triangles = triangles.subarray(0, this.trianglesLen);
        this.halfedges = halfedges.subarray(0, this.trianglesLen);
    };

    Delaunator.from = function from (points, getX, getY) {
            if ( getX === void 0 ) getX = defaultGetX;
            if ( getY === void 0 ) getY = defaultGetY;

        var n = points.length;
        var coords = new Float64Array(n * 2);

        for (var i = 0; i < n; i++) {
            var p = points[i];
            coords[2 * i] = getX(p);
            coords[2 * i + 1] = getY(p);
        }

        return new Delaunator(coords);
    };

    Delaunator.prototype._hashKey = function _hashKey (x, y) {
        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
    };

    Delaunator.prototype._legalize = function _legalize (a) {
            var this$1 = this;

        var ref = this;
            var triangles = ref.triangles;
            var coords = ref.coords;
            var halfedges = ref.halfedges;

        var b = halfedges[a];

        /* if the pair of triangles doesn't satisfy the Delaunay condition
         * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
         * then do the same check/flip recursively for the new pair of triangles
         *
         *       pl                pl
         *      /||\              /  \
         *   al/ || \bl        al/\a
         *    /  ||  \          /  \
         *   /  a||b  \flip/___ar___\
         * p0\   ||   /p1   =>   p0\---bl---/p1
         *    \  ||  /          \  /
         *   ar\ || /br         b\/br
         *      \||/              \  /
         *       pr                pr
         */
        var a0 = a - a % 3;
        var b0 = b - b % 3;

        var al = a0 + (a + 1) % 3;
        var ar = a0 + (a + 2) % 3;
        var bl = b0 + (b + 2) % 3;

        if (b === -1) { return ar; }

        var p0 = triangles[ar];
        var pr = triangles[a];
        var pl = triangles[al];
        var p1 = triangles[bl];

        var illegal = inCircle(
            coords[2 * p0], coords[2 * p0 + 1],
            coords[2 * pr], coords[2 * pr + 1],
            coords[2 * pl], coords[2 * pl + 1],
            coords[2 * p1], coords[2 * p1 + 1]);

        if (illegal) {
            triangles[a] = p1;
            triangles[b] = p0;

            var hbl = halfedges[bl];

            // edge swapped on the other side of the hull (rare); fix the halfedge reference
            if (hbl === -1) {
                var e = this.hullStart;
                do {
                    if (this$1.hullTri[e] === bl) {
                        this$1.hullTri[e] = a;
                        break;
                    }
                    e = this$1.hullNext[e];
                } while (e !== this.hullStart);
            }
            this._link(a, hbl);
            this._link(b, halfedges[ar]);
            this._link(ar, bl);

            var br = b0 + (b + 1) % 3;

            this._legalize(a);
            return this._legalize(br);
        }

        return ar;
    };

    Delaunator.prototype._link = function _link (a, b) {
        this.halfedges[a] = b;
        if (b !== -1) { this.halfedges[b] = a; }
    };

    // add a new triangle given vertex indices and adjacent half-edge ids
    Delaunator.prototype._addTriangle = function _addTriangle (i0, i1, i2, a, b, c) {
        var t = this.trianglesLen;

        this.triangles[t] = i0;
        this.triangles[t + 1] = i1;
        this.triangles[t + 2] = i2;

        this._link(t, a);
        this._link(t + 1, b);
        this._link(t + 2, c);

        this.trianglesLen += 3;

        return t;
    };

    // monotonically increases with real angle, but doesn't need expensive trigonometry
    function pseudoAngle(dx, dy) {
        var p = dx / (Math.abs(dx) + Math.abs(dy));
        return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
    }

    function dist(ax, ay, bx, by) {
        var dx = ax - bx;
        var dy = ay - by;
        return dx * dx + dy * dy;
    }

    function orient(px, py, qx, qy, rx, ry) {
        return (qy - py) * (rx - qx) - (qx - px) * (ry - qy) < 0;
    }

    function inCircle(ax, ay, bx, by, cx, cy, px, py) {
        var dx = ax - px;
        var dy = ay - py;
        var ex = bx - px;
        var ey = by - py;
        var fx = cx - px;
        var fy = cy - py;

        var ap = dx * dx + dy * dy;
        var bp = ex * ex + ey * ey;
        var cp = fx * fx + fy * fy;

        return dx * (ey * cp - bp * fy) -
               dy * (ex * cp - bp * fx) +
               ap * (ex * fy - ey * fx) < 0;
    }

    function circumradius(ax, ay, bx, by, cx, cy) {
        var dx = bx - ax;
        var dy = by - ay;
        var ex = cx - ax;
        var ey = cy - ay;

        var bl = dx * dx + dy * dy;
        var cl = ex * ex + ey * ey;
        var d = 0.5 / (dx * ey - dy * ex);

        var x = (ey * bl - dy * cl) * d;
        var y = (dx * cl - ex * bl) * d;

        return x * x + y * y;
    }

    function circumcenter(ax, ay, bx, by, cx, cy) {
        var dx = bx - ax;
        var dy = by - ay;
        var ex = cx - ax;
        var ey = cy - ay;

        var bl = dx * dx + dy * dy;
        var cl = ex * ex + ey * ey;
        var d = 0.5 / (dx * ey - dy * ex);

        var x = ax + (ey * bl - dy * cl) * d;
        var y = ay + (dx * cl - ex * bl) * d;

        return {x: x, y: y};
    }

    function quicksort(ids, dists, left, right) {
        if (right - left <= 20) {
            for (var i = left + 1; i <= right; i++) {
                var temp = ids[i];
                var tempDist = dists[temp];
                var j = i - 1;
                while (j >= left && dists[ids[j]] > tempDist) { ids[j + 1] = ids[j--]; }
                ids[j + 1] = temp;
            }
        } else {
            var median = (left + right) >> 1;
            var i$1 = left + 1;
            var j$1 = right;
            swap(ids, median, i$1);
            if (dists[ids[left]] > dists[ids[right]]) { swap(ids, left, right); }
            if (dists[ids[i$1]] > dists[ids[right]]) { swap(ids, i$1, right); }
            if (dists[ids[left]] > dists[ids[i$1]]) { swap(ids, left, i$1); }

            var temp$1 = ids[i$1];
            var tempDist$1 = dists[temp$1];
            while (true) {
                do { i$1++; } while (dists[ids[i$1]] < tempDist$1);
                do { j$1--; } while (dists[ids[j$1]] > tempDist$1);
                if (j$1 < i$1) { break; }
                swap(ids, i$1, j$1);
            }
            ids[left + 1] = ids[j$1];
            ids[j$1] = temp$1;

            if (right - i$1 + 1 >= j$1 - left) {
                quicksort(ids, dists, i$1, right);
                quicksort(ids, dists, left, j$1 - 1);
            } else {
                quicksort(ids, dists, left, j$1 - 1);
                quicksort(ids, dists, i$1, right);
            }
        }
    }

    function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultGetX(p) {
        return p[0];
    }
    function defaultGetY(p) {
        return p[1];
    }

    return Delaunator;

})));

},{}],201:[function(require,module,exports){
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _slicedToArray = _interopDefault(require('babel-runtime/helpers/slicedToArray'));
var _getIterator = _interopDefault(require('babel-runtime/core-js/get-iterator'));
var _defineProperty = _interopDefault(require('babel-runtime/helpers/defineProperty'));
var _regeneratorRuntime = _interopDefault(require('babel-runtime/regenerator'));
var _Symbol$iterator = _interopDefault(require('babel-runtime/core-js/symbol/iterator'));
var _classCallCheck = _interopDefault(require('babel-runtime/helpers/classCallCheck'));
var _createClass = _interopDefault(require('babel-runtime/helpers/createClass'));

var INITIAL_STATE = 1;
var FAIL_STATE = 0;

/**
 * A StateMachine represents a deterministic finite automaton.
 * It can perform matches over a sequence of values, similar to a regular expression.
 */

var StateMachine = function () {
  function StateMachine(dfa) {
    _classCallCheck(this, StateMachine);

    this.stateTable = dfa.stateTable;
    this.accepting = dfa.accepting;
    this.tags = dfa.tags;
  }

  /**
   * Returns an iterable object that yields pattern matches over the input sequence.
   * Matches are of the form [startIndex, endIndex, tags].
   */


  _createClass(StateMachine, [{
    key: 'match',
    value: function match(str) {
      var self = this;
      return _defineProperty({}, _Symbol$iterator, _regeneratorRuntime.mark(function _callee() {
        var state, startRun, lastAccepting, lastState, p, c;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                state = INITIAL_STATE;
                startRun = null;
                lastAccepting = null;
                lastState = null;
                p = 0;

              case 5:
                if (!(p < str.length)) {
                  _context.next = 21;
                  break;
                }

                c = str[p];


                lastState = state;
                state = self.stateTable[state][c];

                if (!(state === FAIL_STATE)) {
                  _context.next = 15;
                  break;
                }

                if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {
                  _context.next = 13;
                  break;
                }

                _context.next = 13;
                return [startRun, lastAccepting, self.tags[lastState]];

              case 13:

                // reset the state as if we started over from the initial state
                state = self.stateTable[INITIAL_STATE][c];
                startRun = null;

              case 15:

                // start a run if not in the failure state
                if (state !== FAIL_STATE && startRun == null) {
                  startRun = p;
                }

                // if accepting, mark the potential match end
                if (self.accepting[state]) {
                  lastAccepting = p;
                }

                // reset the state to the initial state if we get into the failure state
                if (state === FAIL_STATE) {
                  state = INITIAL_STATE;
                }

              case 18:
                p++;
                _context.next = 5;
                break;

              case 21:
                if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {
                  _context.next = 24;
                  break;
                }

                _context.next = 24;
                return [startRun, lastAccepting, self.tags[state]];

              case 24:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
    }

    /**
     * For each match over the input sequence, action functions matching
     * the tag definitions in the input pattern are called with the startIndex,
     * endIndex, and sub-match sequence.
     */

  }, {
    key: 'apply',
    value: function apply(str, actions) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _getIterator(this.match(str)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 3);

          var start = _step$value[0];
          var end = _step$value[1];
          var tags = _step$value[2];
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = _getIterator(tags), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var tag = _step2.value;

              if (typeof actions[tag] === 'function') {
                actions[tag](start, end, str.slice(start, end + 1));
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);

  return StateMachine;
}();

module.exports = StateMachine;


},{"babel-runtime/core-js/get-iterator":36,"babel-runtime/core-js/symbol/iterator":51,"babel-runtime/helpers/classCallCheck":52,"babel-runtime/helpers/createClass":53,"babel-runtime/helpers/defineProperty":54,"babel-runtime/helpers/slicedToArray":57,"babel-runtime/regenerator":59}],202:[function(require,module,exports){
(function (process,Buffer){
'use strict';
function _interopDefault(ex) {
    return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}
var r = _interopDefault(require('restructure'));
var _Object$getOwnPropertyDescriptor = _interopDefault(require('babel-runtime/core-js/object/get-own-property-descriptor'));
var _getIterator = _interopDefault(require('babel-runtime/core-js/get-iterator'));
var _Object$freeze = _interopDefault(require('babel-runtime/core-js/object/freeze'));
var _typeof = _interopDefault(require('babel-runtime/helpers/typeof'));
var _Object$keys = _interopDefault(require('babel-runtime/core-js/object/keys'));
var _Object$defineProperty = _interopDefault(require('babel-runtime/core-js/object/define-property'));
var _classCallCheck = _interopDefault(require('babel-runtime/helpers/classCallCheck'));
var _createClass = _interopDefault(require('babel-runtime/helpers/createClass'));
var _Map = _interopDefault(require('babel-runtime/core-js/map'));
var _possibleConstructorReturn = _interopDefault(require('babel-runtime/helpers/possibleConstructorReturn'));
var _inherits = _interopDefault(require('babel-runtime/helpers/inherits'));
var restructure_src_utils = require('restructure/src/utils');
var _Object$defineProperties = _interopDefault(require('babel-runtime/core-js/object/define-properties'));
var isEqual = _interopDefault(require('deep-equal'));
var _Object$assign = _interopDefault(require('babel-runtime/core-js/object/assign'));
var _String$fromCodePoint = _interopDefault(require('babel-runtime/core-js/string/from-code-point'));
var _Array$from = _interopDefault(require('babel-runtime/core-js/array/from'));
var _Set = _interopDefault(require('babel-runtime/core-js/set'));
var unicode = _interopDefault(require('unicode-properties'));
var UnicodeTrie = _interopDefault(require('unicode-trie'));
var StateMachine = _interopDefault(require('dfa'));
var _Number$EPSILON = _interopDefault(require('babel-runtime/core-js/number/epsilon'));
var cloneDeep = _interopDefault(require('clone'));
var inflate = _interopDefault(require('tiny-inflate'));
var brotli = _interopDefault(require('brotli/decompress'));
var fontkit = {};
fontkit.logErrors = false;
var formats = [];
fontkit.registerFormat = function (format) {
    formats.push(format);
};
fontkit.openSync = function (filename, postscriptName) {
    var buffer = fs.readFileSync(filename);
    return fontkit.create(buffer, postscriptName);
};
fontkit.open = function (filename, postscriptName, callback) {
    if (typeof postscriptName === 'function') {
        callback = postscriptName;
        postscriptName = null;
    }
    fs.readFile(filename, function (err, buffer) {
        if (err) {
            return callback(err);
        }
        try {
            var font = fontkit.create(buffer, postscriptName);
        } catch (e) {
            return callback(e);
        }
        return callback(null, font);
    });
    return;
};
fontkit.create = function (buffer, postscriptName) {
    for (var i = 0; i < formats.length; i++) {
        var format = formats[i];
        if (format.probe(buffer)) {
            var font = new format(new r.DecodeStream(buffer));
            if (postscriptName) {
                return font.getFont(postscriptName);
            }
            return font;
        }
    }
    throw new Error('Unknown font format');
};
fontkit.defaultLanguage = 'en';
fontkit.setDefaultLanguage = function () {
    var lang = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'en';
    fontkit.defaultLanguage = lang;
};
function cache(target, key, descriptor) {
    if (descriptor.get) {
        var get = descriptor.get;
        descriptor.get = function () {
            var value = get.call(this);
            _Object$defineProperty(this, key, { value: value });
            return value;
        };
    } else if (typeof descriptor.value === 'function') {
        var fn = descriptor.value;
        return {
            get: function get() {
                var cache = new _Map();
                function memoized() {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    var key = args.length > 0 ? args[0] : 'value';
                    if (cache.has(key)) {
                        return cache.get(key);
                    }
                    var result = fn.apply(this, args);
                    cache.set(key, result);
                    return result;
                }
                ;
                _Object$defineProperty(this, key, { value: memoized });
                return memoized;
            }
        };
    }
}
var SubHeader = new r.Struct({
        firstCode: r.uint16,
        entryCount: r.uint16,
        idDelta: r.int16,
        idRangeOffset: r.uint16
    });
var CmapGroup = new r.Struct({
        startCharCode: r.uint32,
        endCharCode: r.uint32,
        glyphID: r.uint32
    });
var UnicodeValueRange = new r.Struct({
        startUnicodeValue: r.uint24,
        additionalCount: r.uint8
    });
var UVSMapping = new r.Struct({
        unicodeValue: r.uint24,
        glyphID: r.uint16
    });
var DefaultUVS = new r.Array(UnicodeValueRange, r.uint32);
var NonDefaultUVS = new r.Array(UVSMapping, r.uint32);
var VarSelectorRecord = new r.Struct({
        varSelector: r.uint24,
        defaultUVS: new r.Pointer(r.uint32, DefaultUVS, { type: 'parent' }),
        nonDefaultUVS: new r.Pointer(r.uint32, NonDefaultUVS, { type: 'parent' })
    });
var CmapSubtable = new r.VersionedStruct(r.uint16, {
        0: {
            length: r.uint16,
            language: r.uint16,
            codeMap: new r.LazyArray(r.uint8, 256)
        },
        2: {
            length: r.uint16,
            language: r.uint16,
            subHeaderKeys: new r.Array(r.uint16, 256),
            subHeaderCount: function subHeaderCount(t) {
                return Math.max.apply(Math, t.subHeaderKeys);
            },
            subHeaders: new r.LazyArray(SubHeader, 'subHeaderCount'),
            glyphIndexArray: new r.LazyArray(r.uint16, 'subHeaderCount')
        },
        4: {
            length: r.uint16,
            language: r.uint16,
            segCountX2: r.uint16,
            segCount: function segCount(t) {
                return t.segCountX2 >> 1;
            },
            searchRange: r.uint16,
            entrySelector: r.uint16,
            rangeShift: r.uint16,
            endCode: new r.LazyArray(r.uint16, 'segCount'),
            reservedPad: new r.Reserved(r.uint16),
            startCode: new r.LazyArray(r.uint16, 'segCount'),
            idDelta: new r.LazyArray(r.int16, 'segCount'),
            idRangeOffset: new r.LazyArray(r.uint16, 'segCount'),
            glyphIndexArray: new r.LazyArray(r.uint16, function (t) {
                return (t.length - t._currentOffset) / 2;
            })
        },
        6: {
            length: r.uint16,
            language: r.uint16,
            firstCode: r.uint16,
            entryCount: r.uint16,
            glyphIndices: new r.LazyArray(r.uint16, 'entryCount')
        },
        8: {
            reserved: new r.Reserved(r.uint16),
            length: r.uint32,
            language: r.uint16,
            is32: new r.LazyArray(r.uint8, 8192),
            nGroups: r.uint32,
            groups: new r.LazyArray(CmapGroup, 'nGroups')
        },
        10: {
            reserved: new r.Reserved(r.uint16),
            length: r.uint32,
            language: r.uint32,
            firstCode: r.uint32,
            entryCount: r.uint32,
            glyphIndices: new r.LazyArray(r.uint16, 'numChars')
        },
        12: {
            reserved: new r.Reserved(r.uint16),
            length: r.uint32,
            language: r.uint32,
            nGroups: r.uint32,
            groups: new r.LazyArray(CmapGroup, 'nGroups')
        },
        13: {
            reserved: new r.Reserved(r.uint16),
            length: r.uint32,
            language: r.uint32,
            nGroups: r.uint32,
            groups: new r.LazyArray(CmapGroup, 'nGroups')
        },
        14: {
            length: r.uint32,
            numRecords: r.uint32,
            varSelectors: new r.LazyArray(VarSelectorRecord, 'numRecords')
        }
    });
var CmapEntry = new r.Struct({
        platformID: r.uint16,
        encodingID: r.uint16,
        table: new r.Pointer(r.uint32, CmapSubtable, {
            type: 'parent',
            lazy: true
        })
    });
var cmap = new r.Struct({
        version: r.uint16,
        numSubtables: r.uint16,
        tables: new r.Array(CmapEntry, 'numSubtables')
    });
var head = new r.Struct({
        version: r.int32,
        revision: r.int32,
        checkSumAdjustment: r.uint32,
        magicNumber: r.uint32,
        flags: r.uint16,
        unitsPerEm: r.uint16,
        created: new r.Array(r.int32, 2),
        modified: new r.Array(r.int32, 2),
        xMin: r.int16,
        yMin: r.int16,
        xMax: r.int16,
        yMax: r.int16,
        macStyle: new r.Bitfield(r.uint16, [
            'bold',
            'italic',
            'underline',
            'outline',
            'shadow',
            'condensed',
            'extended'
        ]),
        lowestRecPPEM: r.uint16,
        fontDirectionHint: r.int16,
        indexToLocFormat: r.int16,
        glyphDataFormat: r.int16
    });
var hhea = new r.Struct({
        version: r.int32,
        ascent: r.int16,
        descent: r.int16,
        lineGap: r.int16,
        advanceWidthMax: r.uint16,
        minLeftSideBearing: r.int16,
        minRightSideBearing: r.int16,
        xMaxExtent: r.int16,
        caretSlopeRise: r.int16,
        caretSlopeRun: r.int16,
        caretOffset: r.int16,
        reserved: new r.Reserved(r.int16, 4),
        metricDataFormat: r.int16,
        numberOfMetrics: r.uint16
    });
var HmtxEntry = new r.Struct({
        advance: r.uint16,
        bearing: r.int16
    });
var hmtx = new r.Struct({
        metrics: new r.LazyArray(HmtxEntry, function (t) {
            return t.parent.hhea.numberOfMetrics;
        }),
        bearings: new r.LazyArray(r.int16, function (t) {
            return t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics;
        })
    });
var maxp = new r.Struct({
        version: r.int32,
        numGlyphs: r.uint16,
        maxPoints: r.uint16,
        maxContours: r.uint16,
        maxComponentPoints: r.uint16,
        maxComponentContours: r.uint16,
        maxZones: r.uint16,
        maxTwilightPoints: r.uint16,
        maxStorage: r.uint16,
        maxFunctionDefs: r.uint16,
        maxInstructionDefs: r.uint16,
        maxStackElements: r.uint16,
        maxSizeOfInstructions: r.uint16,
        maxComponentElements: r.uint16,
        maxComponentDepth: r.uint16
    });
function getEncoding(platformID, encodingID) {
    var languageID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    if (platformID === 1 && MAC_LANGUAGE_ENCODINGS[languageID]) {
        return MAC_LANGUAGE_ENCODINGS[languageID];
    }
    return ENCODINGS[platformID][encodingID];
}
var ENCODINGS = [
        [
            'utf16be',
            'utf16be',
            'utf16be',
            'utf16be',
            'utf16be',
            'utf16be'
        ],
        [
            'macroman',
            'shift-jis',
            'big5',
            'euc-kr',
            'iso-8859-6',
            'iso-8859-8',
            'macgreek',
            'maccyrillic',
            'symbol',
            'Devanagari',
            'Gurmukhi',
            'Gujarati',
            'Oriya',
            'Bengali',
            'Tamil',
            'Telugu',
            'Kannada',
            'Malayalam',
            'Sinhalese',
            'Burmese',
            'Khmer',
            'macthai',
            'Laotian',
            'Georgian',
            'Armenian',
            'gb-2312-80',
            'Tibetan',
            'Mongolian',
            'Geez',
            'maccenteuro',
            'Vietnamese',
            'Sindhi'
        ],
        ['ascii'],
        [
            'symbol',
            'utf16be',
            'shift-jis',
            'gb18030',
            'big5',
            'wansung',
            'johab',
            null,
            null,
            null,
            'utf16be'
        ]
    ];
var MAC_LANGUAGE_ENCODINGS = {
        15: 'maciceland',
        17: 'macturkish',
        18: 'maccroatian',
        24: 'maccenteuro',
        25: 'maccenteuro',
        26: 'maccenteuro',
        27: 'maccenteuro',
        28: 'maccenteuro',
        30: 'maciceland',
        37: 'macromania',
        38: 'maccenteuro',
        39: 'maccenteuro',
        40: 'maccenteuro',
        143: 'macinuit',
        146: 'macgaelic'
    };
var LANGUAGES = [
        [],
        {
            0: 'en',
            30: 'fo',
            60: 'ks',
            90: 'rw',
            1: 'fr',
            31: 'fa',
            61: 'ku',
            91: 'rn',
            2: 'de',
            32: 'ru',
            62: 'sd',
            92: 'ny',
            3: 'it',
            33: 'zh',
            63: 'bo',
            93: 'mg',
            4: 'nl',
            34: 'nl-BE',
            64: 'ne',
            94: 'eo',
            5: 'sv',
            35: 'ga',
            65: 'sa',
            128: 'cy',
            6: 'es',
            36: 'sq',
            66: 'mr',
            129: 'eu',
            7: 'da',
            37: 'ro',
            67: 'bn',
            130: 'ca',
            8: 'pt',
            38: 'cz',
            68: 'as',
            131: 'la',
            9: 'no',
            39: 'sk',
            69: 'gu',
            132: 'qu',
            10: 'he',
            40: 'si',
            70: 'pa',
            133: 'gn',
            11: 'ja',
            41: 'yi',
            71: 'or',
            134: 'ay',
            12: 'ar',
            42: 'sr',
            72: 'ml',
            135: 'tt',
            13: 'fi',
            43: 'mk',
            73: 'kn',
            136: 'ug',
            14: 'el',
            44: 'bg',
            74: 'ta',
            137: 'dz',
            15: 'is',
            45: 'uk',
            75: 'te',
            138: 'jv',
            16: 'mt',
            46: 'be',
            76: 'si',
            139: 'su',
            17: 'tr',
            47: 'uz',
            77: 'my',
            140: 'gl',
            18: 'hr',
            48: 'kk',
            78: 'km',
            141: 'af',
            19: 'zh-Hant',
            49: 'az-Cyrl',
            79: 'lo',
            142: 'br',
            20: 'ur',
            50: 'az-Arab',
            80: 'vi',
            143: 'iu',
            21: 'hi',
            51: 'hy',
            81: 'id',
            144: 'gd',
            22: 'th',
            52: 'ka',
            82: 'tl',
            145: 'gv',
            23: 'ko',
            53: 'mo',
            83: 'ms',
            146: 'ga',
            24: 'lt',
            54: 'ky',
            84: 'ms-Arab',
            147: 'to',
            25: 'pl',
            55: 'tg',
            85: 'am',
            148: 'el-polyton',
            26: 'hu',
            56: 'tk',
            86: 'ti',
            149: 'kl',
            27: 'es',
            57: 'mn-CN',
            87: 'om',
            150: 'az',
            28: 'lv',
            58: 'mn',
            88: 'so',
            151: 'nn',
            29: 'se',
            59: 'ps',
            89: 'sw'
        },
        [],
        {
            1078: 'af',
            16393: 'en-IN',
            1159: 'rw',
            1074: 'tn',
            1052: 'sq',
            6153: 'en-IE',
            1089: 'sw',
            1115: 'si',
            1156: 'gsw',
            8201: 'en-JM',
            1111: 'kok',
            1051: 'sk',
            1118: 'am',
            17417: 'en-MY',
            1042: 'ko',
            1060: 'sl',
            5121: 'ar-DZ',
            5129: 'en-NZ',
            1088: 'ky',
            11274: 'es-AR',
            15361: 'ar-BH',
            13321: 'en-PH',
            1108: 'lo',
            16394: 'es-BO',
            3073: 'ar',
            18441: 'en-SG',
            1062: 'lv',
            13322: 'es-CL',
            2049: 'ar-IQ',
            7177: 'en-ZA',
            1063: 'lt',
            9226: 'es-CO',
            11265: 'ar-JO',
            11273: 'en-TT',
            2094: 'dsb',
            5130: 'es-CR',
            13313: 'ar-KW',
            2057: 'en-GB',
            1134: 'lb',
            7178: 'es-DO',
            12289: 'ar-LB',
            1033: 'en',
            1071: 'mk',
            12298: 'es-EC',
            4097: 'ar-LY',
            12297: 'en-ZW',
            2110: 'ms-BN',
            17418: 'es-SV',
            6145: 'ary',
            1061: 'et',
            1086: 'ms',
            4106: 'es-GT',
            8193: 'ar-OM',
            1080: 'fo',
            1100: 'ml',
            18442: 'es-HN',
            16385: 'ar-QA',
            1124: 'fil',
            1082: 'mt',
            2058: 'es-MX',
            1025: 'ar-SA',
            1035: 'fi',
            1153: 'mi',
            19466: 'es-NI',
            10241: 'ar-SY',
            2060: 'fr-BE',
            1146: 'arn',
            6154: 'es-PA',
            7169: 'aeb',
            3084: 'fr-CA',
            1102: 'mr',
            15370: 'es-PY',
            14337: 'ar-AE',
            1036: 'fr',
            1148: 'moh',
            10250: 'es-PE',
            9217: 'ar-YE',
            5132: 'fr-LU',
            1104: 'mn',
            20490: 'es-PR',
            1067: 'hy',
            6156: 'fr-MC',
            2128: 'mn-CN',
            3082: 'es',
            1101: 'as',
            4108: 'fr-CH',
            1121: 'ne',
            1034: 'es',
            2092: 'az-Cyrl',
            1122: 'fy',
            1044: 'nb',
            21514: 'es-US',
            1068: 'az',
            1110: 'gl',
            2068: 'nn',
            14346: 'es-UY',
            1133: 'ba',
            1079: 'ka',
            1154: 'oc',
            8202: 'es-VE',
            1069: 'eu',
            3079: 'de-AT',
            1096: 'or',
            2077: 'sv-FI',
            1059: 'be',
            1031: 'de',
            1123: 'ps',
            1053: 'sv',
            2117: 'bn',
            5127: 'de-LI',
            1045: 'pl',
            1114: 'syr',
            1093: 'bn-IN',
            4103: 'de-LU',
            1046: 'pt',
            1064: 'tg',
            8218: 'bs-Cyrl',
            2055: 'de-CH',
            2070: 'pt-PT',
            2143: 'tzm',
            5146: 'bs',
            1032: 'el',
            1094: 'pa',
            1097: 'ta',
            1150: 'br',
            1135: 'kl',
            1131: 'qu-BO',
            1092: 'tt',
            1026: 'bg',
            1095: 'gu',
            2155: 'qu-EC',
            1098: 'te',
            1027: 'ca',
            1128: 'ha',
            3179: 'qu',
            1054: 'th',
            3076: 'zh-HK',
            1037: 'he',
            1048: 'ro',
            1105: 'bo',
            5124: 'zh-MO',
            1081: 'hi',
            1047: 'rm',
            1055: 'tr',
            2052: 'zh',
            1038: 'hu',
            1049: 'ru',
            1090: 'tk',
            4100: 'zh-SG',
            1039: 'is',
            9275: 'smn',
            1152: 'ug',
            1028: 'zh-TW',
            1136: 'ig',
            4155: 'smj-NO',
            1058: 'uk',
            1155: 'co',
            1057: 'id',
            5179: 'smj',
            1070: 'hsb',
            1050: 'hr',
            1117: 'iu',
            3131: 'se-FI',
            1056: 'ur',
            4122: 'hr-BA',
            2141: 'iu-Latn',
            1083: 'se',
            2115: 'uz-Cyrl',
            1029: 'cs',
            2108: 'ga',
            2107: 'se-SE',
            1091: 'uz',
            1030: 'da',
            1076: 'xh',
            8251: 'sms',
            1066: 'vi',
            1164: 'prs',
            1077: 'zu',
            6203: 'sma-NO',
            1106: 'cy',
            1125: 'dv',
            1040: 'it',
            7227: 'sms',
            1160: 'wo',
            2067: 'nl-BE',
            2064: 'it-CH',
            1103: 'sa',
            1157: 'sah',
            1043: 'nl',
            1041: 'ja',
            7194: 'sr-Cyrl-BA',
            1144: 'ii',
            3081: 'en-AU',
            1099: 'kn',
            3098: 'sr',
            1130: 'yo',
            10249: 'en-BZ',
            1087: 'kk',
            6170: 'sr-Latn-BA',
            4105: 'en-CA',
            1107: 'km',
            2074: 'sr-Latn',
            9225: 'en-029',
            1158: 'quc',
            1132: 'nso'
        }
    ];
var NameRecord = new r.Struct({
        platformID: r.uint16,
        encodingID: r.uint16,
        languageID: r.uint16,
        nameID: r.uint16,
        length: r.uint16,
        string: new r.Pointer(r.uint16, new r.String('length', function (t) {
            return getEncoding(t.platformID, t.encodingID, t.languageID);
        }), {
            type: 'parent',
            relativeTo: 'parent.stringOffset',
            allowNull: false
        })
    });
var LangTagRecord = new r.Struct({
        length: r.uint16,
        tag: new r.Pointer(r.uint16, new r.String('length', 'utf16be'), {
            type: 'parent',
            relativeTo: 'stringOffset'
        })
    });
var NameTable = new r.VersionedStruct(r.uint16, {
        0: {
            count: r.uint16,
            stringOffset: r.uint16,
            records: new r.Array(NameRecord, 'count')
        },
        1: {
            count: r.uint16,
            stringOffset: r.uint16,
            records: new r.Array(NameRecord, 'count'),
            langTagCount: r.uint16,
            langTags: new r.Array(LangTagRecord, 'langTagCount')
        }
    });
var NAMES = [
        'copyright',
        'fontFamily',
        'fontSubfamily',
        'uniqueSubfamily',
        'fullName',
        'version',
        'postscriptName',
        'trademark',
        'manufacturer',
        'designer',
        'description',
        'vendorURL',
        'designerURL',
        'license',
        'licenseURL',
        null,
        'preferredFamily',
        'preferredSubfamily',
        'compatibleFull',
        'sampleText',
        'postscriptCIDFontName',
        'wwsFamilyName',
        'wwsSubfamilyName'
    ];
NameTable.process = function (stream) {
    var records = {};
    for (var _iterator = this.records, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length)
                break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done)
                break;
            _ref = _i.value;
        }
        var record = _ref;
        var language = LANGUAGES[record.platformID][record.languageID];
        if (language == null && this.langTags != null && record.languageID >= 32768) {
            language = this.langTags[record.languageID - 32768].tag;
        }
        if (language == null) {
            language = record.platformID + '-' + record.languageID;
        }
        var key = record.nameID >= 256 ? 'fontFeatures' : NAMES[record.nameID] || record.nameID;
        if (records[key] == null) {
            records[key] = {};
        }
        var obj = records[key];
        if (record.nameID >= 256) {
            obj = obj[record.nameID] || (obj[record.nameID] = {});
        }
        if (typeof record.string === 'string' || typeof obj[language] !== 'string') {
            obj[language] = record.string;
        }
    }
    this.records = records;
};
NameTable.preEncode = function () {
    if (Array.isArray(this.records))
        return;
    this.version = 0;
    var records = [];
    for (var key in this.records) {
        var val = this.records[key];
        if (key === 'fontFeatures')
            continue;
        records.push({
            platformID: 3,
            encodingID: 1,
            languageID: 1033,
            nameID: NAMES.indexOf(key),
            length: Buffer.byteLength(val.en, 'utf16le'),
            string: val.en
        });
        if (key === 'postscriptName') {
            records.push({
                platformID: 1,
                encodingID: 0,
                languageID: 0,
                nameID: NAMES.indexOf(key),
                length: val.en.length,
                string: val.en
            });
        }
    }
    this.records = records;
    this.count = records.length;
    this.stringOffset = NameTable.size(this, null, false);
};
var OS2 = new r.VersionedStruct(r.uint16, {
        header: {
            xAvgCharWidth: r.int16,
            usWeightClass: r.uint16,
            usWidthClass: r.uint16,
            fsType: new r.Bitfield(r.uint16, [
                null,
                'noEmbedding',
                'viewOnly',
                'editable',
                null,
                null,
                null,
                null,
                'noSubsetting',
                'bitmapOnly'
            ]),
            ySubscriptXSize: r.int16,
            ySubscriptYSize: r.int16,
            ySubscriptXOffset: r.int16,
            ySubscriptYOffset: r.int16,
            ySuperscriptXSize: r.int16,
            ySuperscriptYSize: r.int16,
            ySuperscriptXOffset: r.int16,
            ySuperscriptYOffset: r.int16,
            yStrikeoutSize: r.int16,
            yStrikeoutPosition: r.int16,
            sFamilyClass: r.int16,
            panose: new r.Array(r.uint8, 10),
            ulCharRange: new r.Array(r.uint32, 4),
            vendorID: new r.String(4),
            fsSelection: new r.Bitfield(r.uint16, [
                'italic',
                'underscore',
                'negative',
                'outlined',
                'strikeout',
                'bold',
                'regular',
                'useTypoMetrics',
                'wws',
                'oblique'
            ]),
            usFirstCharIndex: r.uint16,
            usLastCharIndex: r.uint16
        },
        0: {},
        1: {
            typoAscender: r.int16,
            typoDescender: r.int16,
            typoLineGap: r.int16,
            winAscent: r.uint16,
            winDescent: r.uint16,
            codePageRange: new r.Array(r.uint32, 2)
        },
        2: {
            typoAscender: r.int16,
            typoDescender: r.int16,
            typoLineGap: r.int16,
            winAscent: r.uint16,
            winDescent: r.uint16,
            codePageRange: new r.Array(r.uint32, 2),
            xHeight: r.int16,
            capHeight: r.int16,
            defaultChar: r.uint16,
            breakChar: r.uint16,
            maxContent: r.uint16
        },
        5: {
            typoAscender: r.int16,
            typoDescender: r.int16,
            typoLineGap: r.int16,
            winAscent: r.uint16,
            winDescent: r.uint16,
            codePageRange: new r.Array(r.uint32, 2),
            xHeight: r.int16,
            capHeight: r.int16,
            defaultChar: r.uint16,
            breakChar: r.uint16,
            maxContent: r.uint16,
            usLowerOpticalPointSize: r.uint16,
            usUpperOpticalPointSize: r.uint16
        }
    });
var versions = OS2.versions;
versions[3] = versions[4] = versions[2];
var post = new r.VersionedStruct(r.fixed32, {
        header: {
            italicAngle: r.fixed32,
            underlinePosition: r.int16,
            underlineThickness: r.int16,
            isFixedPitch: r.uint32,
            minMemType42: r.uint32,
            maxMemType42: r.uint32,
            minMemType1: r.uint32,
            maxMemType1: r.uint32
        },
        1: {},
        2: {
            numberOfGlyphs: r.uint16,
            glyphNameIndex: new r.Array(r.uint16, 'numberOfGlyphs'),
            names: new r.Array(new r.String(r.uint8))
        },
        2.5: {
            numberOfGlyphs: r.uint16,
            offsets: new r.Array(r.uint8, 'numberOfGlyphs')
        },
        3: {},
        4: {
            map: new r.Array(r.uint32, function (t) {
                return t.parent.maxp.numGlyphs;
            })
        }
    });
var cvt = new r.Struct({ controlValues: new r.Array(r.int16) });
var fpgm = new r.Struct({ instructions: new r.Array(r.uint8) });
var loca = new r.VersionedStruct('head.indexToLocFormat', {
        0: { offsets: new r.Array(r.uint16) },
        1: { offsets: new r.Array(r.uint32) }
    });
loca.process = function () {
    if (this.version === 0) {
        for (var i = 0; i < this.offsets.length; i++) {
            this.offsets[i] <<= 1;
        }
    }
};
loca.preEncode = function () {
    if (this.version === 0) {
        for (var i = 0; i < this.offsets.length; i++) {
            this.offsets[i] >>>= 1;
        }
    }
};
var prep = new r.Struct({ controlValueProgram: new r.Array(r.uint8) });
var glyf = new r.Array(new r.Buffer());
var CFFIndex = function () {
        function CFFIndex(type) {
            _classCallCheck(this, CFFIndex);
            this.type = type;
        }
        CFFIndex.prototype.getCFFVersion = function getCFFVersion(ctx) {
            while (ctx && !ctx.hdrSize) {
                ctx = ctx.parent;
            }
            return ctx ? ctx.version : -1;
        };
        CFFIndex.prototype.decode = function decode(stream, parent) {
            var version = this.getCFFVersion(parent);
            var count = version >= 2 ? stream.readUInt32BE() : stream.readUInt16BE();
            if (count === 0) {
                return [];
            }
            var offSize = stream.readUInt8();
            var offsetType = void 0;
            if (offSize === 1) {
                offsetType = r.uint8;
            } else if (offSize === 2) {
                offsetType = r.uint16;
            } else if (offSize === 3) {
                offsetType = r.uint24;
            } else if (offSize === 4) {
                offsetType = r.uint32;
            } else {
                throw new Error('Bad offset size in CFFIndex: ' + offSize + ' ' + stream.pos);
            }
            var ret = [];
            var startPos = stream.pos + (count + 1) * offSize - 1;
            var start = offsetType.decode(stream);
            for (var i = 0; i < count; i++) {
                var end = offsetType.decode(stream);
                if (this.type != null) {
                    var pos = stream.pos;
                    stream.pos = startPos + start;
                    parent.length = end - start;
                    ret.push(this.type.decode(stream, parent));
                    stream.pos = pos;
                } else {
                    ret.push({
                        offset: startPos + start,
                        length: end - start
                    });
                }
                start = end;
            }
            stream.pos = startPos + start;
            return ret;
        };
        CFFIndex.prototype.size = function size(arr, parent) {
            var size = 2;
            if (arr.length === 0) {
                return size;
            }
            var type = this.type || new r.Buffer();
            var offset = 1;
            for (var i = 0; i < arr.length; i++) {
                var item = arr[i];
                offset += type.size(item, parent);
            }
            var offsetType = void 0;
            if (offset <= 255) {
                offsetType = r.uint8;
            } else if (offset <= 65535) {
                offsetType = r.uint16;
            } else if (offset <= 16777215) {
                offsetType = r.uint24;
            } else if (offset <= 4294967295) {
                offsetType = r.uint32;
            } else {
                throw new Error('Bad offset in CFFIndex');
            }
            size += 1 + offsetType.size() * (arr.length + 1);
            size += offset - 1;
            return size;
        };
        CFFIndex.prototype.encode = function encode(stream, arr, parent) {
            stream.writeUInt16BE(arr.length);
            if (arr.length === 0) {
                return;
            }
            var type = this.type || new r.Buffer();
            var sizes = [];
            var offset = 1;
            for (var _iterator = arr, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var item = _ref;
                var s = type.size(item, parent);
                sizes.push(s);
                offset += s;
            }
            var offsetType = void 0;
            if (offset <= 255) {
                offsetType = r.uint8;
            } else if (offset <= 65535) {
                offsetType = r.uint16;
            } else if (offset <= 16777215) {
                offsetType = r.uint24;
            } else if (offset <= 4294967295) {
                offsetType = r.uint32;
            } else {
                throw new Error('Bad offset in CFFIndex');
            }
            stream.writeUInt8(offsetType.size());
            offset = 1;
            offsetType.encode(stream, offset);
            for (var _iterator2 = sizes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var size = _ref2;
                offset += size;
                offsetType.encode(stream, offset);
            }
            for (var _iterator3 = arr, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length)
                        break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done)
                        break;
                    _ref3 = _i3.value;
                }
                var _item = _ref3;
                type.encode(stream, _item, parent);
            }
            return;
        };
        return CFFIndex;
    }();
var FLOAT_EOF = 15;
var FLOAT_LOOKUP = [
        '0',
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9',
        '.',
        'E',
        'E-',
        null,
        '-'
    ];
var FLOAT_ENCODE_LOOKUP = {
        '.': 10,
        'E': 11,
        'E-': 12,
        '-': 14
    };
var CFFOperand = function () {
        function CFFOperand() {
            _classCallCheck(this, CFFOperand);
        }
        CFFOperand.decode = function decode(stream, value) {
            if (32 <= value && value <= 246) {
                return value - 139;
            }
            if (247 <= value && value <= 250) {
                return (value - 247) * 256 + stream.readUInt8() + 108;
            }
            if (251 <= value && value <= 254) {
                return -(value - 251) * 256 - stream.readUInt8() - 108;
            }
            if (value === 28) {
                return stream.readInt16BE();
            }
            if (value === 29) {
                return stream.readInt32BE();
            }
            if (value === 30) {
                var str = '';
                while (true) {
                    var b = stream.readUInt8();
                    var n1 = b >> 4;
                    if (n1 === FLOAT_EOF) {
                        break;
                    }
                    str += FLOAT_LOOKUP[n1];
                    var n2 = b & 15;
                    if (n2 === FLOAT_EOF) {
                        break;
                    }
                    str += FLOAT_LOOKUP[n2];
                }
                return parseFloat(str);
            }
            return null;
        };
        CFFOperand.size = function size(value) {
            if (value.forceLarge) {
                value = 32768;
            }
            if ((value | 0) !== value) {
                var str = '' + value;
                return 1 + Math.ceil((str.length + 1) / 2);
            } else if (-107 <= value && value <= 107) {
                return 1;
            } else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) {
                return 2;
            } else if (-32768 <= value && value <= 32767) {
                return 3;
            } else {
                return 5;
            }
        };
        CFFOperand.encode = function encode(stream, value) {
            var val = Number(value);
            if (value.forceLarge) {
                stream.writeUInt8(29);
                return stream.writeInt32BE(val);
            } else if ((val | 0) !== val) {
                stream.writeUInt8(30);
                var str = '' + val;
                for (var i = 0; i < str.length; i += 2) {
                    var c1 = str[i];
                    var n1 = FLOAT_ENCODE_LOOKUP[c1] || +c1;
                    if (i === str.length - 1) {
                        var n2 = FLOAT_EOF;
                    } else {
                        var c2 = str[i + 1];
                        var n2 = FLOAT_ENCODE_LOOKUP[c2] || +c2;
                    }
                    stream.writeUInt8(n1 << 4 | n2 & 15);
                }
                if (n2 !== FLOAT_EOF) {
                    return stream.writeUInt8(FLOAT_EOF << 4);
                }
            } else if (-107 <= val && val <= 107) {
                return stream.writeUInt8(val + 139);
            } else if (108 <= val && val <= 1131) {
                val -= 108;
                stream.writeUInt8((val >> 8) + 247);
                return stream.writeUInt8(val & 255);
            } else if (-1131 <= val && val <= -108) {
                val = -val - 108;
                stream.writeUInt8((val >> 8) + 251);
                return stream.writeUInt8(val & 255);
            } else if (-32768 <= val && val <= 32767) {
                stream.writeUInt8(28);
                return stream.writeInt16BE(val);
            } else {
                stream.writeUInt8(29);
                return stream.writeInt32BE(val);
            }
        };
        return CFFOperand;
    }();
var CFFDict = function () {
        function CFFDict() {
            var ops = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            _classCallCheck(this, CFFDict);
            this.ops = ops;
            this.fields = {};
            for (var _iterator = ops, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var field = _ref;
                var key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
                this.fields[key] = field;
            }
        }
        CFFDict.prototype.decodeOperands = function decodeOperands(type, stream, ret, operands) {
            var _this = this;
            if (Array.isArray(type)) {
                return operands.map(function (op, i) {
                    return _this.decodeOperands(type[i], stream, ret, [op]);
                });
            } else if (type.decode != null) {
                return type.decode(stream, ret, operands);
            } else {
                switch (type) {
                case 'number':
                case 'offset':
                case 'sid':
                    return operands[0];
                case 'boolean':
                    return !!operands[0];
                default:
                    return operands;
                }
            }
        };
        CFFDict.prototype.encodeOperands = function encodeOperands(type, stream, ctx, operands) {
            var _this2 = this;
            if (Array.isArray(type)) {
                return operands.map(function (op, i) {
                    return _this2.encodeOperands(type[i], stream, ctx, op)[0];
                });
            } else if (type.encode != null) {
                return type.encode(stream, operands, ctx);
            } else if (typeof operands === 'number') {
                return [operands];
            } else if (typeof operands === 'boolean') {
                return [+operands];
            } else if (Array.isArray(operands)) {
                return operands;
            } else {
                return [operands];
            }
        };
        CFFDict.prototype.decode = function decode(stream, parent) {
            var end = stream.pos + parent.length;
            var ret = {};
            var operands = [];
            _Object$defineProperties(ret, {
                parent: { value: parent },
                _startOffset: { value: stream.pos }
            });
            for (var key in this.fields) {
                var field = this.fields[key];
                ret[field[1]] = field[3];
            }
            while (stream.pos < end) {
                var b = stream.readUInt8();
                if (b < 28) {
                    if (b === 12) {
                        b = b << 8 | stream.readUInt8();
                    }
                    var _field = this.fields[b];
                    if (!_field) {
                        throw new Error('Unknown operator ' + b);
                    }
                    var val = this.decodeOperands(_field[2], stream, ret, operands);
                    if (val != null) {
                        if (val instanceof restructure_src_utils.PropertyDescriptor) {
                            _Object$defineProperty(ret, _field[1], val);
                        } else {
                            ret[_field[1]] = val;
                        }
                    }
                    operands = [];
                } else {
                    operands.push(CFFOperand.decode(stream, b));
                }
            }
            return ret;
        };
        CFFDict.prototype.size = function size(dict, parent) {
            var includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            var ctx = {
                    parent: parent,
                    val: dict,
                    pointerSize: 0,
                    startOffset: parent.startOffset || 0
                };
            var len = 0;
            for (var k in this.fields) {
                var field = this.fields[k];
                var val = dict[field[1]];
                if (val == null || isEqual(val, field[3])) {
                    continue;
                }
                var operands = this.encodeOperands(field[2], null, ctx, val);
                for (var _iterator2 = operands, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length)
                            break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        _i2 = _iterator2.next();
                        if (_i2.done)
                            break;
                        _ref2 = _i2.value;
                    }
                    var op = _ref2;
                    len += CFFOperand.size(op);
                }
                var key = Array.isArray(field[0]) ? field[0] : [field[0]];
                len += key.length;
            }
            if (includePointers) {
                len += ctx.pointerSize;
            }
            return len;
        };
        CFFDict.prototype.encode = function encode(stream, dict, parent) {
            var ctx = {
                    pointers: [],
                    startOffset: stream.pos,
                    parent: parent,
                    val: dict,
                    pointerSize: 0
                };
            ctx.pointerOffset = stream.pos + this.size(dict, ctx, false);
            for (var _iterator3 = this.ops, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length)
                        break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done)
                        break;
                    _ref3 = _i3.value;
                }
                var field = _ref3;
                var val = dict[field[1]];
                if (val == null || isEqual(val, field[3])) {
                    continue;
                }
                var operands = this.encodeOperands(field[2], stream, ctx, val);
                for (var _iterator4 = operands, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length)
                            break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        _i4 = _iterator4.next();
                        if (_i4.done)
                            break;
                        _ref4 = _i4.value;
                    }
                    var op = _ref4;
                    CFFOperand.encode(stream, op);
                }
                var key = Array.isArray(field[0]) ? field[0] : [field[0]];
                for (var _iterator5 = key, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length)
                            break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        _i5 = _iterator5.next();
                        if (_i5.done)
                            break;
                        _ref5 = _i5.value;
                    }
                    var _op = _ref5;
                    stream.writeUInt8(_op);
                }
            }
            var i = 0;
            while (i < ctx.pointers.length) {
                var ptr = ctx.pointers[i++];
                ptr.type.encode(stream, ptr.val, ptr.parent);
            }
            return;
        };
        return CFFDict;
    }();
var CFFPointer = function (_r$Pointer) {
        _inherits(CFFPointer, _r$Pointer);
        function CFFPointer(type) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, CFFPointer);
            if (options.type == null) {
                options.type = 'global';
            }
            return _possibleConstructorReturn(this, _r$Pointer.call(this, null, type, options));
        }
        CFFPointer.prototype.decode = function decode(stream, parent, operands) {
            this.offsetType = {
                decode: function decode() {
                    return operands[0];
                }
            };
            return _r$Pointer.prototype.decode.call(this, stream, parent, operands);
        };
        CFFPointer.prototype.encode = function encode(stream, value, ctx) {
            if (!stream) {
                this.offsetType = {
                    size: function size() {
                        return 0;
                    }
                };
                this.size(value, ctx);
                return [new Ptr(0)];
            }
            var ptr = null;
            this.offsetType = {
                encode: function encode(stream, val) {
                    return ptr = val;
                }
            };
            _r$Pointer.prototype.encode.call(this, stream, value, ctx);
            return [new Ptr(ptr)];
        };
        return CFFPointer;
    }(r.Pointer);
var Ptr = function () {
        function Ptr(val) {
            _classCallCheck(this, Ptr);
            this.val = val;
            this.forceLarge = true;
        }
        Ptr.prototype.valueOf = function valueOf() {
            return this.val;
        };
        return Ptr;
    }();
var CFFBlendOp = function () {
        function CFFBlendOp() {
            _classCallCheck(this, CFFBlendOp);
        }
        CFFBlendOp.decode = function decode(stream, parent, operands) {
            var numBlends = operands.pop();
            while (operands.length > numBlends) {
                operands.pop();
            }
        };
        return CFFBlendOp;
    }();
var CFFPrivateDict = new CFFDict([
        [
            6,
            'BlueValues',
            'delta',
            null
        ],
        [
            7,
            'OtherBlues',
            'delta',
            null
        ],
        [
            8,
            'FamilyBlues',
            'delta',
            null
        ],
        [
            9,
            'FamilyOtherBlues',
            'delta',
            null
        ],
        [
            [
                12,
                9
            ],
            'BlueScale',
            'number',
            0.039625
        ],
        [
            [
                12,
                10
            ],
            'BlueShift',
            'number',
            7
        ],
        [
            [
                12,
                11
            ],
            'BlueFuzz',
            'number',
            1
        ],
        [
            10,
            'StdHW',
            'number',
            null
        ],
        [
            11,
            'StdVW',
            'number',
            null
        ],
        [
            [
                12,
                12
            ],
            'StemSnapH',
            'delta',
            null
        ],
        [
            [
                12,
                13
            ],
            'StemSnapV',
            'delta',
            null
        ],
        [
            [
                12,
                14
            ],
            'ForceBold',
            'boolean',
            false
        ],
        [
            [
                12,
                17
            ],
            'LanguageGroup',
            'number',
            0
        ],
        [
            [
                12,
                18
            ],
            'ExpansionFactor',
            'number',
            0.06
        ],
        [
            [
                12,
                19
            ],
            'initialRandomSeed',
            'number',
            0
        ],
        [
            20,
            'defaultWidthX',
            'number',
            0
        ],
        [
            21,
            'nominalWidthX',
            'number',
            0
        ],
        [
            22,
            'vsindex',
            'number',
            0
        ],
        [
            23,
            'blend',
            CFFBlendOp,
            null
        ],
        [
            19,
            'Subrs',
            new CFFPointer(new CFFIndex(), { type: 'local' }),
            null
        ]
    ]);
var standardStrings = [
        '.notdef',
        'space',
        'exclam',
        'quotedbl',
        'numbersign',
        'dollar',
        'percent',
        'ampersand',
        'quoteright',
        'parenleft',
        'parenright',
        'asterisk',
        'plus',
        'comma',
        'hyphen',
        'period',
        'slash',
        'zero',
        'one',
        'two',
        'three',
        'four',
        'five',
        'six',
        'seven',
        'eight',
        'nine',
        'colon',
        'semicolon',
        'less',
        'equal',
        'greater',
        'question',
        'at',
        'A',
        'B',
        'C',
        'D',
        'E',
        'F',
        'G',
        'H',
        'I',
        'J',
        'K',
        'L',
        'M',
        'N',
        'O',
        'P',
        'Q',
        'R',
        'S',
        'T',
        'U',
        'V',
        'W',
        'X',
        'Y',
        'Z',
        'bracketleft',
        'backslash',
        'bracketright',
        'asciicircum',
        'underscore',
        'quoteleft',
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
        'braceleft',
        'bar',
        'braceright',
        'asciitilde',
        'exclamdown',
        'cent',
        'sterling',
        'fraction',
        'yen',
        'florin',
        'section',
        'currency',
        'quotesingle',
        'quotedblleft',
        'guillemotleft',
        'guilsinglleft',
        'guilsinglright',
        'fi',
        'fl',
        'endash',
        'dagger',
        'daggerdbl',
        'periodcentered',
        'paragraph',
        'bullet',
        'quotesinglbase',
        'quotedblbase',
        'quotedblright',
        'guillemotright',
        'ellipsis',
        'perthousand',
        'questiondown',
        'grave',
        'acute',
        'circumflex',
        'tilde',
        'macron',
        'breve',
        'dotaccent',
        'dieresis',
        'ring',
        'cedilla',
        'hungarumlaut',
        'ogonek',
        'caron',
        'emdash',
        'AE',
        'ordfeminine',
        'Lslash',
        'Oslash',
        'OE',
        'ordmasculine',
        'ae',
        'dotlessi',
        'lslash',
        'oslash',
        'oe',
        'germandbls',
        'onesuperior',
        'logicalnot',
        'mu',
        'trademark',
        'Eth',
        'onehalf',
        'plusminus',
        'Thorn',
        'onequarter',
        'divide',
        'brokenbar',
        'degree',
        'thorn',
        'threequarters',
        'twosuperior',
        'registered',
        'minus',
        'eth',
        'multiply',
        'threesuperior',
        'copyright',
        'Aacute',
        'Acircumflex',
        'Adieresis',
        'Agrave',
        'Aring',
        'Atilde',
        'Ccedilla',
        'Eacute',
        'Ecircumflex',
        'Edieresis',
        'Egrave',
        'Iacute',
        'Icircumflex',
        'Idieresis',
        'Igrave',
        'Ntilde',
        'Oacute',
        'Ocircumflex',
        'Odieresis',
        'Ograve',
        'Otilde',
        'Scaron',
        'Uacute',
        'Ucircumflex',
        'Udieresis',
        'Ugrave',
        'Yacute',
        'Ydieresis',
        'Zcaron',
        'aacute',
        'acircumflex',
        'adieresis',
        'agrave',
        'aring',
        'atilde',
        'ccedilla',
        'eacute',
        'ecircumflex',
        'edieresis',
        'egrave',
        'iacute',
        'icircumflex',
        'idieresis',
        'igrave',
        'ntilde',
        'oacute',
        'ocircumflex',
        'odieresis',
        'ograve',
        'otilde',
        'scaron',
        'uacute',
        'ucircumflex',
        'udieresis',
        'ugrave',
        'yacute',
        'ydieresis',
        'zcaron',
        'exclamsmall',
        'Hungarumlautsmall',
        'dollaroldstyle',
        'dollarsuperior',
        'ampersandsmall',
        'Acutesmall',
        'parenleftsuperior',
        'parenrightsuperior',
        'twodotenleader',
        'onedotenleader',
        'zerooldstyle',
        'oneoldstyle',
        'twooldstyle',
        'threeoldstyle',
        'fouroldstyle',
        'fiveoldstyle',
        'sixoldstyle',
        'sevenoldstyle',
        'eightoldstyle',
        'nineoldstyle',
        'commasuperior',
        'threequartersemdash',
        'periodsuperior',
        'questionsmall',
        'asuperior',
        'bsuperior',
        'centsuperior',
        'dsuperior',
        'esuperior',
        'isuperior',
        'lsuperior',
        'msuperior',
        'nsuperior',
        'osuperior',
        'rsuperior',
        'ssuperior',
        'tsuperior',
        'ff',
        'ffi',
        'ffl',
        'parenleftinferior',
        'parenrightinferior',
        'Circumflexsmall',
        'hyphensuperior',
        'Gravesmall',
        'Asmall',
        'Bsmall',
        'Csmall',
        'Dsmall',
        'Esmall',
        'Fsmall',
        'Gsmall',
        'Hsmall',
        'Ismall',
        'Jsmall',
        'Ksmall',
        'Lsmall',
        'Msmall',
        'Nsmall',
        'Osmall',
        'Psmall',
        'Qsmall',
        'Rsmall',
        'Ssmall',
        'Tsmall',
        'Usmall',
        'Vsmall',
        'Wsmall',
        'Xsmall',
        'Ysmall',
        'Zsmall',
        'colonmonetary',
        'onefitted',
        'rupiah',
        'Tildesmall',
        'exclamdownsmall',
        'centoldstyle',
        'Lslashsmall',
        'Scaronsmall',
        'Zcaronsmall',
        'Dieresissmall',
        'Brevesmall',
        'Caronsmall',
        'Dotaccentsmall',
        'Macronsmall',
        'figuredash',
        'hypheninferior',
        'Ogoneksmall',
        'Ringsmall',
        'Cedillasmall',
        'questiondownsmall',
        'oneeighth',
        'threeeighths',
        'fiveeighths',
        'seveneighths',
        'onethird',
        'twothirds',
        'zerosuperior',
        'foursuperior',
        'fivesuperior',
        'sixsuperior',
        'sevensuperior',
        'eightsuperior',
        'ninesuperior',
        'zeroinferior',
        'oneinferior',
        'twoinferior',
        'threeinferior',
        'fourinferior',
        'fiveinferior',
        'sixinferior',
        'seveninferior',
        'eightinferior',
        'nineinferior',
        'centinferior',
        'dollarinferior',
        'periodinferior',
        'commainferior',
        'Agravesmall',
        'Aacutesmall',
        'Acircumflexsmall',
        'Atildesmall',
        'Adieresissmall',
        'Aringsmall',
        'AEsmall',
        'Ccedillasmall',
        'Egravesmall',
        'Eacutesmall',
        'Ecircumflexsmall',
        'Edieresissmall',
        'Igravesmall',
        'Iacutesmall',
        'Icircumflexsmall',
        'Idieresissmall',
        'Ethsmall',
        'Ntildesmall',
        'Ogravesmall',
        'Oacutesmall',
        'Ocircumflexsmall',
        'Otildesmall',
        'Odieresissmall',
        'OEsmall',
        'Oslashsmall',
        'Ugravesmall',
        'Uacutesmall',
        'Ucircumflexsmall',
        'Udieresissmall',
        'Yacutesmall',
        'Thornsmall',
        'Ydieresissmall',
        '001.000',
        '001.001',
        '001.002',
        '001.003',
        'Black',
        'Bold',
        'Book',
        'Light',
        'Medium',
        'Regular',
        'Roman',
        'Semibold'
    ];
var StandardEncoding = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        'space',
        'exclam',
        'quotedbl',
        'numbersign',
        'dollar',
        'percent',
        'ampersand',
        'quoteright',
        'parenleft',
        'parenright',
        'asterisk',
        'plus',
        'comma',
        'hyphen',
        'period',
        'slash',
        'zero',
        'one',
        'two',
        'three',
        'four',
        'five',
        'six',
        'seven',
        'eight',
        'nine',
        'colon',
        'semicolon',
        'less',
        'equal',
        'greater',
        'question',
        'at',
        'A',
        'B',
        'C',
        'D',
        'E',
        'F',
        'G',
        'H',
        'I',
        'J',
        'K',
        'L',
        'M',
        'N',
        'O',
        'P',
        'Q',
        'R',
        'S',
        'T',
        'U',
        'V',
        'W',
        'X',
        'Y',
        'Z',
        'bracketleft',
        'backslash',
        'bracketright',
        'asciicircum',
        'underscore',
        'quoteleft',
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
        'braceleft',
        'bar',
        'braceright',
        'asciitilde',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        'exclamdown',
        'cent',
        'sterling',
        'fraction',
        'yen',
        'florin',
        'section',
        'currency',
        'quotesingle',
        'quotedblleft',
        'guillemotleft',
        'guilsinglleft',
        'guilsinglright',
        'fi',
        'fl',
        '',
        'endash',
        'dagger',
        'daggerdbl',
        'periodcentered',
        '',
        'paragraph',
        'bullet',
        'quotesinglbase',
        'quotedblbase',
        'quotedblright',
        'guillemotright',
        'ellipsis',
        'perthousand',
        '',
        'questiondown',
        '',
        'grave',
        'acute',
        'circumflex',
        'tilde',
        'macron',
        'breve',
        'dotaccent',
        'dieresis',
        '',
        'ring',
        'cedilla',
        '',
        'hungarumlaut',
        'ogonek',
        'caron',
        'emdash',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        'AE',
        '',
        'ordfeminine',
        '',
        '',
        '',
        '',
        'Lslash',
        'Oslash',
        'OE',
        'ordmasculine',
        '',
        '',
        '',
        '',
        '',
        'ae',
        '',
        '',
        '',
        'dotlessi',
        '',
        '',
        'lslash',
        'oslash',
        'oe',
        'germandbls'
    ];
var ExpertEncoding = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        'space',
        'exclamsmall',
        'Hungarumlautsmall',
        '',
        'dollaroldstyle',
        'dollarsuperior',
        'ampersandsmall',
        'Acutesmall',
        'parenleftsuperior',
        'parenrightsuperior',
        'twodotenleader',
        'onedotenleader',
        'comma',
        'hyphen',
        'period',
        'fraction',
        'zerooldstyle',
        'oneoldstyle',
        'twooldstyle',
        'threeoldstyle',
        'fouroldstyle',
        'fiveoldstyle',
        'sixoldstyle',
        'sevenoldstyle',
        'eightoldstyle',
        'nineoldstyle',
        'colon',
        'semicolon',
        'commasuperior',
        'threequartersemdash',
        'periodsuperior',
        'questionsmall',
        '',
        'asuperior',
        'bsuperior',
        'centsuperior',
        'dsuperior',
        'esuperior',
        '',
        '',
        'isuperior',
        '',
        '',
        'lsuperior',
        'msuperior',
        'nsuperior',
        'osuperior',
        '',
        '',
        'rsuperior',
        'ssuperior',
        'tsuperior',
        '',
        'ff',
        'fi',
        'fl',
        'ffi',
        'ffl',
        'parenleftinferior',
        '',
        'parenrightinferior',
        'Circumflexsmall',
        'hyphensuperior',
        'Gravesmall',
        'Asmall',
        'Bsmall',
        'Csmall',
        'Dsmall',
        'Esmall',
        'Fsmall',
        'Gsmall',
        'Hsmall',
        'Ismall',
        'Jsmall',
        'Ksmall',
        'Lsmall',
        'Msmall',
        'Nsmall',
        'Osmall',
        'Psmall',
        'Qsmall',
        'Rsmall',
        'Ssmall',
        'Tsmall',
        'Usmall',
        'Vsmall',
        'Wsmall',
        'Xsmall',
        'Ysmall',
        'Zsmall',
        'colonmonetary',
        'onefitted',
        'rupiah',
        'Tildesmall',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        'exclamdownsmall',
        'centoldstyle',
        'Lslashsmall',
        '',
        '',
        'Scaronsmall',
        'Zcaronsmall',
        'Dieresissmall',
        'Brevesmall',
        'Caronsmall',
        '',
        'Dotaccentsmall',
        '',
        '',
        'Macronsmall',
        '',
        '',
        'figuredash',
        'hypheninferior',
        '',
        '',
        'Ogoneksmall',
        'Ringsmall',
        'Cedillasmall',
        '',
        '',
        '',
        'onequarter',
        'onehalf',
        'threequarters',
        'questiondownsmall',
        'oneeighth',
        'threeeighths',
        'fiveeighths',
        'seveneighths',
        'onethird',
        'twothirds',
        '',
        '',
        'zerosuperior',
        'onesuperior',
        'twosuperior',
        'threesuperior',
        'foursuperior',
        'fivesuperior',
        'sixsuperior',
        'sevensuperior',
        'eightsuperior',
        'ninesuperior',
        'zeroinferior',
        'oneinferior',
        'twoinferior',
        'threeinferior',
        'fourinferior',
        'fiveinferior',
        'sixinferior',
        'seveninferior',
        'eightinferior',
        'nineinferior',
        'centinferior',
        'dollarinferior',
        'periodinferior',
        'commainferior',
        'Agravesmall',
        'Aacutesmall',
        'Acircumflexsmall',
        'Atildesmall',
        'Adieresissmall',
        'Aringsmall',
        'AEsmall',
        'Ccedillasmall',
        'Egravesmall',
        'Eacutesmall',
        'Ecircumflexsmall',
        'Edieresissmall',
        'Igravesmall',
        'Iacutesmall',
        'Icircumflexsmall',
        'Idieresissmall',
        'Ethsmall',
        'Ntildesmall',
        'Ogravesmall',
        'Oacutesmall',
        'Ocircumflexsmall',
        'Otildesmall',
        'Odieresissmall',
        'OEsmall',
        'Oslashsmall',
        'Ugravesmall',
        'Uacutesmall',
        'Ucircumflexsmall',
        'Udieresissmall',
        'Yacutesmall',
        'Thornsmall',
        'Ydieresissmall'
    ];
var ISOAdobeCharset = [
        '.notdef',
        'space',
        'exclam',
        'quotedbl',
        'numbersign',
        'dollar',
        'percent',
        'ampersand',
        'quoteright',
        'parenleft',
        'parenright',
        'asterisk',
        'plus',
        'comma',
        'hyphen',
        'period',
        'slash',
        'zero',
        'one',
        'two',
        'three',
        'four',
        'five',
        'six',
        'seven',
        'eight',
        'nine',
        'colon',
        'semicolon',
        'less',
        'equal',
        'greater',
        'question',
        'at',
        'A',
        'B',
        'C',
        'D',
        'E',
        'F',
        'G',
        'H',
        'I',
        'J',
        'K',
        'L',
        'M',
        'N',
        'O',
        'P',
        'Q',
        'R',
        'S',
        'T',
        'U',
        'V',
        'W',
        'X',
        'Y',
        'Z',
        'bracketleft',
        'backslash',
        'bracketright',
        'asciicircum',
        'underscore',
        'quoteleft',
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
        'braceleft',
        'bar',
        'braceright',
        'asciitilde',
        'exclamdown',
        'cent',
        'sterling',
        'fraction',
        'yen',
        'florin',
        'section',
        'currency',
        'quotesingle',
        'quotedblleft',
        'guillemotleft',
        'guilsinglleft',
        'guilsinglright',
        'fi',
        'fl',
        'endash',
        'dagger',
        'daggerdbl',
        'periodcentered',
        'paragraph',
        'bullet',
        'quotesinglbase',
        'quotedblbase',
        'quotedblright',
        'guillemotright',
        'ellipsis',
        'perthousand',
        'questiondown',
        'grave',
        'acute',
        'circumflex',
        'tilde',
        'macron',
        'breve',
        'dotaccent',
        'dieresis',
        'ring',
        'cedilla',
        'hungarumlaut',
        'ogonek',
        'caron',
        'emdash',
        'AE',
        'ordfeminine',
        'Lslash',
        'Oslash',
        'OE',
        'ordmasculine',
        'ae',
        'dotlessi',
        'lslash',
        'oslash',
        'oe',
        'germandbls',
        'onesuperior',
        'logicalnot',
        'mu',
        'trademark',
        'Eth',
        'onehalf',
        'plusminus',
        'Thorn',
        'onequarter',
        'divide',
        'brokenbar',
        'degree',
        'thorn',
        'threequarters',
        'twosuperior',
        'registered',
        'minus',
        'eth',
        'multiply',
        'threesuperior',
        'copyright',
        'Aacute',
        'Acircumflex',
        'Adieresis',
        'Agrave',
        'Aring',
        'Atilde',
        'Ccedilla',
        'Eacute',
        'Ecircumflex',
        'Edieresis',
        'Egrave',
        'Iacute',
        'Icircumflex',
        'Idieresis',
        'Igrave',
        'Ntilde',
        'Oacute',
        'Ocircumflex',
        'Odieresis',
        'Ograve',
        'Otilde',
        'Scaron',
        'Uacute',
        'Ucircumflex',
        'Udieresis',
        'Ugrave',
        'Yacute',
        'Ydieresis',
        'Zcaron',
        'aacute',
        'acircumflex',
        'adieresis',
        'agrave',
        'aring',
        'atilde',
        'ccedilla',
        'eacute',
        'ecircumflex',
        'edieresis',
        'egrave',
        'iacute',
        'icircumflex',
        'idieresis',
        'igrave',
        'ntilde',
        'oacute',
        'ocircumflex',
        'odieresis',
        'ograve',
        'otilde',
        'scaron',
        'uacute',
        'ucircumflex',
        'udieresis',
        'ugrave',
        'yacute',
        'ydieresis',
        'zcaron'
    ];
var ExpertCharset = [
        '.notdef',
        'space',
        'exclamsmall',
        'Hungarumlautsmall',
        'dollaroldstyle',
        'dollarsuperior',
        'ampersandsmall',
        'Acutesmall',
        'parenleftsuperior',
        'parenrightsuperior',
        'twodotenleader',
        'onedotenleader',
        'comma',
        'hyphen',
        'period',
        'fraction',
        'zerooldstyle',
        'oneoldstyle',
        'twooldstyle',
        'threeoldstyle',
        'fouroldstyle',
        'fiveoldstyle',
        'sixoldstyle',
        'sevenoldstyle',
        'eightoldstyle',
        'nineoldstyle',
        'colon',
        'semicolon',
        'commasuperior',
        'threequartersemdash',
        'periodsuperior',
        'questionsmall',
        'asuperior',
        'bsuperior',
        'centsuperior',
        'dsuperior',
        'esuperior',
        'isuperior',
        'lsuperior',
        'msuperior',
        'nsuperior',
        'osuperior',
        'rsuperior',
        'ssuperior',
        'tsuperior',
        'ff',
        'fi',
        'fl',
        'ffi',
        'ffl',
        'parenleftinferior',
        'parenrightinferior',
        'Circumflexsmall',
        'hyphensuperior',
        'Gravesmall',
        'Asmall',
        'Bsmall',
        'Csmall',
        'Dsmall',
        'Esmall',
        'Fsmall',
        'Gsmall',
        'Hsmall',
        'Ismall',
        'Jsmall',
        'Ksmall',
        'Lsmall',
        'Msmall',
        'Nsmall',
        'Osmall',
        'Psmall',
        'Qsmall',
        'Rsmall',
        'Ssmall',
        'Tsmall',
        'Usmall',
        'Vsmall',
        'Wsmall',
        'Xsmall',
        'Ysmall',
        'Zsmall',
        'colonmonetary',
        'onefitted',
        'rupiah',
        'Tildesmall',
        'exclamdownsmall',
        'centoldstyle',
        'Lslashsmall',
        'Scaronsmall',
        'Zcaronsmall',
        'Dieresissmall',
        'Brevesmall',
        'Caronsmall',
        'Dotaccentsmall',
        'Macronsmall',
        'figuredash',
        'hypheninferior',
        'Ogoneksmall',
        'Ringsmall',
        'Cedillasmall',
        'onequarter',
        'onehalf',
        'threequarters',
        'questiondownsmall',
        'oneeighth',
        'threeeighths',
        'fiveeighths',
        'seveneighths',
        'onethird',
        'twothirds',
        'zerosuperior',
        'onesuperior',
        'twosuperior',
        'threesuperior',
        'foursuperior',
        'fivesuperior',
        'sixsuperior',
        'sevensuperior',
        'eightsuperior',
        'ninesuperior',
        'zeroinferior',
        'oneinferior',
        'twoinferior',
        'threeinferior',
        'fourinferior',
        'fiveinferior',
        'sixinferior',
        'seveninferior',
        'eightinferior',
        'nineinferior',
        'centinferior',
        'dollarinferior',
        'periodinferior',
        'commainferior',
        'Agravesmall',
        'Aacutesmall',
        'Acircumflexsmall',
        'Atildesmall',
        'Adieresissmall',
        'Aringsmall',
        'AEsmall',
        'Ccedillasmall',
        'Egravesmall',
        'Eacutesmall',
        'Ecircumflexsmall',
        'Edieresissmall',
        'Igravesmall',
        'Iacutesmall',
        'Icircumflexsmall',
        'Idieresissmall',
        'Ethsmall',
        'Ntildesmall',
        'Ogravesmall',
        'Oacutesmall',
        'Ocircumflexsmall',
        'Otildesmall',
        'Odieresissmall',
        'OEsmall',
        'Oslashsmall',
        'Ugravesmall',
        'Uacutesmall',
        'Ucircumflexsmall',
        'Udieresissmall',
        'Yacutesmall',
        'Thornsmall',
        'Ydieresissmall'
    ];
var ExpertSubsetCharset = [
        '.notdef',
        'space',
        'dollaroldstyle',
        'dollarsuperior',
        'parenleftsuperior',
        'parenrightsuperior',
        'twodotenleader',
        'onedotenleader',
        'comma',
        'hyphen',
        'period',
        'fraction',
        'zerooldstyle',
        'oneoldstyle',
        'twooldstyle',
        'threeoldstyle',
        'fouroldstyle',
        'fiveoldstyle',
        'sixoldstyle',
        'sevenoldstyle',
        'eightoldstyle',
        'nineoldstyle',
        'colon',
        'semicolon',
        'commasuperior',
        'threequartersemdash',
        'periodsuperior',
        'asuperior',
        'bsuperior',
        'centsuperior',
        'dsuperior',
        'esuperior',
        'isuperior',
        'lsuperior',
        'msuperior',
        'nsuperior',
        'osuperior',
        'rsuperior',
        'ssuperior',
        'tsuperior',
        'ff',
        'fi',
        'fl',
        'ffi',
        'ffl',
        'parenleftinferior',
        'parenrightinferior',
        'hyphensuperior',
        'colonmonetary',
        'onefitted',
        'rupiah',
        'centoldstyle',
        'figuredash',
        'hypheninferior',
        'onequarter',
        'onehalf',
        'threequarters',
        'oneeighth',
        'threeeighths',
        'fiveeighths',
        'seveneighths',
        'onethird',
        'twothirds',
        'zerosuperior',
        'onesuperior',
        'twosuperior',
        'threesuperior',
        'foursuperior',
        'fivesuperior',
        'sixsuperior',
        'sevensuperior',
        'eightsuperior',
        'ninesuperior',
        'zeroinferior',
        'oneinferior',
        'twoinferior',
        'threeinferior',
        'fourinferior',
        'fiveinferior',
        'sixinferior',
        'seveninferior',
        'eightinferior',
        'nineinferior',
        'centinferior',
        'dollarinferior',
        'periodinferior',
        'commainferior'
    ];
var LangSysTable = new r.Struct({
        reserved: new r.Reserved(r.uint16),
        reqFeatureIndex: r.uint16,
        featureCount: r.uint16,
        featureIndexes: new r.Array(r.uint16, 'featureCount')
    });
var LangSysRecord = new r.Struct({
        tag: new r.String(4),
        langSys: new r.Pointer(r.uint16, LangSysTable, { type: 'parent' })
    });
var Script = new r.Struct({
        defaultLangSys: new r.Pointer(r.uint16, LangSysTable),
        count: r.uint16,
        langSysRecords: new r.Array(LangSysRecord, 'count')
    });
var ScriptRecord = new r.Struct({
        tag: new r.String(4),
        script: new r.Pointer(r.uint16, Script, { type: 'parent' })
    });
var ScriptList = new r.Array(ScriptRecord, r.uint16);
var Feature = new r.Struct({
        featureParams: r.uint16,
        lookupCount: r.uint16,
        lookupListIndexes: new r.Array(r.uint16, 'lookupCount')
    });
var FeatureRecord = new r.Struct({
        tag: new r.String(4),
        feature: new r.Pointer(r.uint16, Feature, { type: 'parent' })
    });
var FeatureList = new r.Array(FeatureRecord, r.uint16);
var LookupFlags = new r.Struct({
        markAttachmentType: r.uint8,
        flags: new r.Bitfield(r.uint8, [
            'rightToLeft',
            'ignoreBaseGlyphs',
            'ignoreLigatures',
            'ignoreMarks',
            'useMarkFilteringSet'
        ])
    });
function LookupList(SubTable) {
    var Lookup = new r.Struct({
            lookupType: r.uint16,
            flags: LookupFlags,
            subTableCount: r.uint16,
            subTables: new r.Array(new r.Pointer(r.uint16, SubTable), 'subTableCount'),
            markFilteringSet: new r.Optional(r.uint16, function (t) {
                return t.flags.flags.useMarkFilteringSet;
            })
        });
    return new r.LazyArray(new r.Pointer(r.uint16, Lookup), r.uint16);
}
var RangeRecord = new r.Struct({
        start: r.uint16,
        end: r.uint16,
        startCoverageIndex: r.uint16
    });
var Coverage = new r.VersionedStruct(r.uint16, {
        1: {
            glyphCount: r.uint16,
            glyphs: new r.Array(r.uint16, 'glyphCount')
        },
        2: {
            rangeCount: r.uint16,
            rangeRecords: new r.Array(RangeRecord, 'rangeCount')
        }
    });
var ClassRangeRecord = new r.Struct({
        start: r.uint16,
        end: r.uint16,
        class: r.uint16
    });
var ClassDef = new r.VersionedStruct(r.uint16, {
        1: {
            startGlyph: r.uint16,
            glyphCount: r.uint16,
            classValueArray: new r.Array(r.uint16, 'glyphCount')
        },
        2: {
            classRangeCount: r.uint16,
            classRangeRecord: new r.Array(ClassRangeRecord, 'classRangeCount')
        }
    });
var Device = new r.Struct({
        a: r.uint16,
        b: r.uint16,
        deltaFormat: r.uint16
    });
var LookupRecord = new r.Struct({
        sequenceIndex: r.uint16,
        lookupListIndex: r.uint16
    });
var Rule = new r.Struct({
        glyphCount: r.uint16,
        lookupCount: r.uint16,
        input: new r.Array(r.uint16, function (t) {
            return t.glyphCount - 1;
        }),
        lookupRecords: new r.Array(LookupRecord, 'lookupCount')
    });
var RuleSet = new r.Array(new r.Pointer(r.uint16, Rule), r.uint16);
var ClassRule = new r.Struct({
        glyphCount: r.uint16,
        lookupCount: r.uint16,
        classes: new r.Array(r.uint16, function (t) {
            return t.glyphCount - 1;
        }),
        lookupRecords: new r.Array(LookupRecord, 'lookupCount')
    });
var ClassSet = new r.Array(new r.Pointer(r.uint16, ClassRule), r.uint16);
var Context = new r.VersionedStruct(r.uint16, {
        1: {
            coverage: new r.Pointer(r.uint16, Coverage),
            ruleSetCount: r.uint16,
            ruleSets: new r.Array(new r.Pointer(r.uint16, RuleSet), 'ruleSetCount')
        },
        2: {
            coverage: new r.Pointer(r.uint16, Coverage),
            classDef: new r.Pointer(r.uint16, ClassDef),
            classSetCnt: r.uint16,
            classSet: new r.Array(new r.Pointer(r.uint16, ClassSet), 'classSetCnt')
        },
        3: {
            glyphCount: r.uint16,
            lookupCount: r.uint16,
            coverages: new r.Array(new r.Pointer(r.uint16, Coverage), 'glyphCount'),
            lookupRecords: new r.Array(LookupRecord, 'lookupCount')
        }
    });
var ChainRule = new r.Struct({
        backtrackGlyphCount: r.uint16,
        backtrack: new r.Array(r.uint16, 'backtrackGlyphCount'),
        inputGlyphCount: r.uint16,
        input: new r.Array(r.uint16, function (t) {
            return t.inputGlyphCount - 1;
        }),
        lookaheadGlyphCount: r.uint16,
        lookahead: new r.Array(r.uint16, 'lookaheadGlyphCount'),
        lookupCount: r.uint16,
        lookupRecords: new r.Array(LookupRecord, 'lookupCount')
    });
var ChainRuleSet = new r.Array(new r.Pointer(r.uint16, ChainRule), r.uint16);
var ChainingContext = new r.VersionedStruct(r.uint16, {
        1: {
            coverage: new r.Pointer(r.uint16, Coverage),
            chainCount: r.uint16,
            chainRuleSets: new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')
        },
        2: {
            coverage: new r.Pointer(r.uint16, Coverage),
            backtrackClassDef: new r.Pointer(r.uint16, ClassDef),
            inputClassDef: new r.Pointer(r.uint16, ClassDef),
            lookaheadClassDef: new r.Pointer(r.uint16, ClassDef),
            chainCount: r.uint16,
            chainClassSet: new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')
        },
        3: {
            backtrackGlyphCount: r.uint16,
            backtrackCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),
            inputGlyphCount: r.uint16,
            inputCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'inputGlyphCount'),
            lookaheadGlyphCount: r.uint16,
            lookaheadCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),
            lookupCount: r.uint16,
            lookupRecords: new r.Array(LookupRecord, 'lookupCount')
        }
    });
var _;
var F2DOT14 = new r.Fixed(16, 'BE', 14);
var RegionAxisCoordinates = new r.Struct({
        startCoord: F2DOT14,
        peakCoord: F2DOT14,
        endCoord: F2DOT14
    });
var VariationRegionList = new r.Struct({
        axisCount: r.uint16,
        regionCount: r.uint16,
        variationRegions: new r.Array(new r.Array(RegionAxisCoordinates, 'axisCount'), 'regionCount')
    });
var DeltaSet = new r.Struct({
        shortDeltas: new r.Array(r.int16, function (t) {
            return t.parent.shortDeltaCount;
        }),
        regionDeltas: new r.Array(r.int8, function (t) {
            return t.parent.regionIndexCount - t.parent.shortDeltaCount;
        }),
        deltas: function deltas(t) {
            return t.shortDeltas.concat(t.regionDeltas);
        }
    });
var ItemVariationData = new r.Struct({
        itemCount: r.uint16,
        shortDeltaCount: r.uint16,
        regionIndexCount: r.uint16,
        regionIndexes: new r.Array(r.uint16, 'regionIndexCount'),
        deltaSets: new r.Array(DeltaSet, 'itemCount')
    });
var ItemVariationStore = new r.Struct({
        format: r.uint16,
        variationRegionList: new r.Pointer(r.uint32, VariationRegionList),
        variationDataCount: r.uint16,
        itemVariationData: new r.Array(new r.Pointer(r.uint32, ItemVariationData), 'variationDataCount')
    });
var ConditionTable = new r.VersionedStruct(r.uint16, { 1: (_ = { axisIndex: r.uint16 }, _['axisIndex'] = r.uint16, _.filterRangeMinValue = F2DOT14, _.filterRangeMaxValue = F2DOT14, _) });
var ConditionSet = new r.Struct({
        conditionCount: r.uint16,
        conditionTable: new r.Array(new r.Pointer(r.uint32, ConditionTable), 'conditionCount')
    });
var FeatureTableSubstitutionRecord = new r.Struct({
        featureIndex: r.uint16,
        alternateFeatureTable: new r.Pointer(r.uint32, Feature, { type: 'parent' })
    });
var FeatureTableSubstitution = new r.Struct({
        version: r.fixed32,
        substitutionCount: r.uint16,
        substitutions: new r.Array(FeatureTableSubstitutionRecord, 'substitutionCount')
    });
var FeatureVariationRecord = new r.Struct({
        conditionSet: new r.Pointer(r.uint32, ConditionSet, { type: 'parent' }),
        featureTableSubstitution: new r.Pointer(r.uint32, FeatureTableSubstitution, { type: 'parent' })
    });
var FeatureVariations = new r.Struct({
        majorVersion: r.uint16,
        minorVersion: r.uint16,
        featureVariationRecordCount: r.uint32,
        featureVariationRecords: new r.Array(FeatureVariationRecord, 'featureVariationRecordCount')
    });
var PredefinedOp = function () {
        function PredefinedOp(predefinedOps, type) {
            _classCallCheck(this, PredefinedOp);
            this.predefinedOps = predefinedOps;
            this.type = type;
        }
        PredefinedOp.prototype.decode = function decode(stream, parent, operands) {
            if (this.predefinedOps[operands[0]]) {
                return this.predefinedOps[operands[0]];
            }
            return this.type.decode(stream, parent, operands);
        };
        PredefinedOp.prototype.size = function size(value, ctx) {
            return this.type.size(value, ctx);
        };
        PredefinedOp.prototype.encode = function encode(stream, value, ctx) {
            var index = this.predefinedOps.indexOf(value);
            if (index !== -1) {
                return index;
            }
            return this.type.encode(stream, value, ctx);
        };
        return PredefinedOp;
    }();
var CFFEncodingVersion = function (_r$Number) {
        _inherits(CFFEncodingVersion, _r$Number);
        function CFFEncodingVersion() {
            _classCallCheck(this, CFFEncodingVersion);
            return _possibleConstructorReturn(this, _r$Number.call(this, 'UInt8'));
        }
        CFFEncodingVersion.prototype.decode = function decode(stream) {
            return r.uint8.decode(stream) & 127;
        };
        return CFFEncodingVersion;
    }(r.Number);
var Range1 = new r.Struct({
        first: r.uint16,
        nLeft: r.uint8
    });
var Range2 = new r.Struct({
        first: r.uint16,
        nLeft: r.uint16
    });
var CFFCustomEncoding = new r.VersionedStruct(new CFFEncodingVersion(), {
        0: {
            nCodes: r.uint8,
            codes: new r.Array(r.uint8, 'nCodes')
        },
        1: {
            nRanges: r.uint8,
            ranges: new r.Array(Range1, 'nRanges')
        }
    });
var CFFEncoding = new PredefinedOp([
        StandardEncoding,
        ExpertEncoding
    ], new CFFPointer(CFFCustomEncoding, { lazy: true }));
var RangeArray = function (_r$Array) {
        _inherits(RangeArray, _r$Array);
        function RangeArray() {
            _classCallCheck(this, RangeArray);
            return _possibleConstructorReturn(this, _r$Array.apply(this, arguments));
        }
        RangeArray.prototype.decode = function decode(stream, parent) {
            var length = restructure_src_utils.resolveLength(this.length, stream, parent);
            var count = 0;
            var res = [];
            while (count < length) {
                var range = this.type.decode(stream, parent);
                range.offset = count;
                count += range.nLeft + 1;
                res.push(range);
            }
            return res;
        };
        return RangeArray;
    }(r.Array);
var CFFCustomCharset = new r.VersionedStruct(r.uint8, {
        0: {
            glyphs: new r.Array(r.uint16, function (t) {
                return t.parent.CharStrings.length - 1;
            })
        },
        1: {
            ranges: new RangeArray(Range1, function (t) {
                return t.parent.CharStrings.length - 1;
            })
        },
        2: {
            ranges: new RangeArray(Range2, function (t) {
                return t.parent.CharStrings.length - 1;
            })
        }
    });
var CFFCharset = new PredefinedOp([
        ISOAdobeCharset,
        ExpertCharset,
        ExpertSubsetCharset
    ], new CFFPointer(CFFCustomCharset, { lazy: true }));
var FDRange3 = new r.Struct({
        first: r.uint16,
        fd: r.uint8
    });
var FDRange4 = new r.Struct({
        first: r.uint32,
        fd: r.uint16
    });
var FDSelect = new r.VersionedStruct(r.uint8, {
        0: {
            fds: new r.Array(r.uint8, function (t) {
                return t.parent.CharStrings.length;
            })
        },
        3: {
            nRanges: r.uint16,
            ranges: new r.Array(FDRange3, 'nRanges'),
            sentinel: r.uint16
        },
        4: {
            nRanges: r.uint32,
            ranges: new r.Array(FDRange4, 'nRanges'),
            sentinel: r.uint32
        }
    });
var ptr = new CFFPointer(CFFPrivateDict);
var CFFPrivateOp = function () {
        function CFFPrivateOp() {
            _classCallCheck(this, CFFPrivateOp);
        }
        CFFPrivateOp.prototype.decode = function decode(stream, parent, operands) {
            parent.length = operands[0];
            return ptr.decode(stream, parent, [operands[1]]);
        };
        CFFPrivateOp.prototype.size = function size(dict, ctx) {
            return [
                CFFPrivateDict.size(dict, ctx, false),
                ptr.size(dict, ctx)[0]
            ];
        };
        CFFPrivateOp.prototype.encode = function encode(stream, dict, ctx) {
            return [
                CFFPrivateDict.size(dict, ctx, false),
                ptr.encode(stream, dict, ctx)[0]
            ];
        };
        return CFFPrivateOp;
    }();
var FontDict = new CFFDict([
        [
            18,
            'Private',
            new CFFPrivateOp(),
            null
        ],
        [
            [
                12,
                38
            ],
            'FontName',
            'sid',
            null
        ]
    ]);
var CFFTopDict = new CFFDict([
        [
            [
                12,
                30
            ],
            'ROS',
            [
                'sid',
                'sid',
                'number'
            ],
            null
        ],
        [
            0,
            'version',
            'sid',
            null
        ],
        [
            1,
            'Notice',
            'sid',
            null
        ],
        [
            [
                12,
                0
            ],
            'Copyright',
            'sid',
            null
        ],
        [
            2,
            'FullName',
            'sid',
            null
        ],
        [
            3,
            'FamilyName',
            'sid',
            null
        ],
        [
            4,
            'Weight',
            'sid',
            null
        ],
        [
            [
                12,
                1
            ],
            'isFixedPitch',
            'boolean',
            false
        ],
        [
            [
                12,
                2
            ],
            'ItalicAngle',
            'number',
            0
        ],
        [
            [
                12,
                3
            ],
            'UnderlinePosition',
            'number',
            -100
        ],
        [
            [
                12,
                4
            ],
            'UnderlineThickness',
            'number',
            50
        ],
        [
            [
                12,
                5
            ],
            'PaintType',
            'number',
            0
        ],
        [
            [
                12,
                6
            ],
            'CharstringType',
            'number',
            2
        ],
        [
            [
                12,
                7
            ],
            'FontMatrix',
            'array',
            [
                0.001,
                0,
                0,
                0.001,
                0,
                0
            ]
        ],
        [
            13,
            'UniqueID',
            'number',
            null
        ],
        [
            5,
            'FontBBox',
            'array',
            [
                0,
                0,
                0,
                0
            ]
        ],
        [
            [
                12,
                8
            ],
            'StrokeWidth',
            'number',
            0
        ],
        [
            14,
            'XUID',
            'array',
            null
        ],
        [
            15,
            'charset',
            CFFCharset,
            ISOAdobeCharset
        ],
        [
            16,
            'Encoding',
            CFFEncoding,
            StandardEncoding
        ],
        [
            17,
            'CharStrings',
            new CFFPointer(new CFFIndex()),
            null
        ],
        [
            18,
            'Private',
            new CFFPrivateOp(),
            null
        ],
        [
            [
                12,
                20
            ],
            'SyntheticBase',
            'number',
            null
        ],
        [
            [
                12,
                21
            ],
            'PostScript',
            'sid',
            null
        ],
        [
            [
                12,
                22
            ],
            'BaseFontName',
            'sid',
            null
        ],
        [
            [
                12,
                23
            ],
            'BaseFontBlend',
            'delta',
            null
        ],
        [
            [
                12,
                31
            ],
            'CIDFontVersion',
            'number',
            0
        ],
        [
            [
                12,
                32
            ],
            'CIDFontRevision',
            'number',
            0
        ],
        [
            [
                12,
                33
            ],
            'CIDFontType',
            'number',
            0
        ],
        [
            [
                12,
                34
            ],
            'CIDCount',
            'number',
            8720
        ],
        [
            [
                12,
                35
            ],
            'UIDBase',
            'number',
            null
        ],
        [
            [
                12,
                37
            ],
            'FDSelect',
            new CFFPointer(FDSelect),
            null
        ],
        [
            [
                12,
                36
            ],
            'FDArray',
            new CFFPointer(new CFFIndex(FontDict)),
            null
        ],
        [
            [
                12,
                38
            ],
            'FontName',
            'sid',
            null
        ]
    ]);
var VariationStore = new r.Struct({
        length: r.uint16,
        itemVariationStore: ItemVariationStore
    });
var CFF2TopDict = new CFFDict([
        [
            [
                12,
                7
            ],
            'FontMatrix',
            'array',
            [
                0.001,
                0,
                0,
                0.001,
                0,
                0
            ]
        ],
        [
            17,
            'CharStrings',
            new CFFPointer(new CFFIndex()),
            null
        ],
        [
            [
                12,
                37
            ],
            'FDSelect',
            new CFFPointer(FDSelect),
            null
        ],
        [
            [
                12,
                36
            ],
            'FDArray',
            new CFFPointer(new CFFIndex(FontDict)),
            null
        ],
        [
            24,
            'vstore',
            new CFFPointer(VariationStore),
            null
        ],
        [
            25,
            'maxstack',
            'number',
            193
        ]
    ]);
var CFFTop = new r.VersionedStruct(r.fixed16, {
        1: {
            hdrSize: r.uint8,
            offSize: r.uint8,
            nameIndex: new CFFIndex(new r.String('length')),
            topDictIndex: new CFFIndex(CFFTopDict),
            stringIndex: new CFFIndex(new r.String('length')),
            globalSubrIndex: new CFFIndex()
        },
        2: {
            hdrSize: r.uint8,
            length: r.uint16,
            topDict: CFF2TopDict,
            globalSubrIndex: new CFFIndex()
        }
    });
var CFFFont = function () {
        function CFFFont(stream) {
            _classCallCheck(this, CFFFont);
            this.stream = stream;
            this.decode();
        }
        CFFFont.decode = function decode(stream) {
            return new CFFFont(stream);
        };
        CFFFont.prototype.decode = function decode() {
            var start = this.stream.pos;
            var top = CFFTop.decode(this.stream);
            for (var key in top) {
                var val = top[key];
                this[key] = val;
            }
            if (this.version < 2) {
                if (this.topDictIndex.length !== 1) {
                    throw new Error('Only a single font is allowed in CFF');
                }
                this.topDict = this.topDictIndex[0];
            }
            this.isCIDFont = this.topDict.ROS != null;
            return this;
        };
        CFFFont.prototype.string = function string(sid) {
            if (this.version >= 2) {
                return null;
            }
            if (sid < standardStrings.length) {
                return standardStrings[sid];
            }
            return this.stringIndex[sid - standardStrings.length];
        };
        CFFFont.prototype.getCharString = function getCharString(glyph) {
            this.stream.pos = this.topDict.CharStrings[glyph].offset;
            return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
        };
        CFFFont.prototype.getGlyphName = function getGlyphName(gid) {
            if (this.version >= 2) {
                return null;
            }
            if (this.isCIDFont) {
                return null;
            }
            var charset = this.topDict.charset;
            if (Array.isArray(charset)) {
                return charset[gid];
            }
            if (gid === 0) {
                return '.notdef';
            }
            gid -= 1;
            switch (charset.version) {
            case 0:
                return this.string(charset.glyphs[gid]);
            case 1:
            case 2:
                for (var i = 0; i < charset.ranges.length; i++) {
                    var range = charset.ranges[i];
                    if (range.offset <= gid && gid <= range.offset + range.nLeft) {
                        return this.string(range.first + (gid - range.offset));
                    }
                }
                break;
            }
            return null;
        };
        CFFFont.prototype.fdForGlyph = function fdForGlyph(gid) {
            if (!this.topDict.FDSelect) {
                return null;
            }
            switch (this.topDict.FDSelect.version) {
            case 0:
                return this.topDict.FDSelect.fds[gid];
            case 3:
            case 4:
                var ranges = this.topDict.FDSelect.ranges;
                var low = 0;
                var high = ranges.length - 1;
                while (low <= high) {
                    var mid = low + high >> 1;
                    if (gid < ranges[mid].first) {
                        high = mid - 1;
                    } else if (mid < high && gid > ranges[mid + 1].first) {
                        low = mid + 1;
                    } else {
                        return ranges[mid].fd;
                    }
                }
            default:
                throw new Error('Unknown FDSelect version: ' + this.topDict.FDSelect.version);
            }
        };
        CFFFont.prototype.privateDictForGlyph = function privateDictForGlyph(gid) {
            if (this.topDict.FDSelect) {
                var fd = this.fdForGlyph(gid);
                if (this.topDict.FDArray[fd]) {
                    return this.topDict.FDArray[fd].Private;
                }
                return null;
            }
            if (this.version < 2) {
                return this.topDict.Private;
            }
            return this.topDict.FDArray[0].Private;
        };
        _createClass(CFFFont, [
            {
                key: 'postscriptName',
                get: function get() {
                    if (this.version < 2) {
                        return this.nameIndex[0];
                    }
                    return null;
                }
            },
            {
                key: 'fullName',
                get: function get() {
                    return this.string(this.topDict.FullName);
                }
            },
            {
                key: 'familyName',
                get: function get() {
                    return this.string(this.topDict.FamilyName);
                }
            }
        ]);
        return CFFFont;
    }();
var VerticalOrigin = new r.Struct({
        glyphIndex: r.uint16,
        vertOriginY: r.int16
    });
var VORG = new r.Struct({
        majorVersion: r.uint16,
        minorVersion: r.uint16,
        defaultVertOriginY: r.int16,
        numVertOriginYMetrics: r.uint16,
        metrics: new r.Array(VerticalOrigin, 'numVertOriginYMetrics')
    });
var BigMetrics = new r.Struct({
        height: r.uint8,
        width: r.uint8,
        horiBearingX: r.int8,
        horiBearingY: r.int8,
        horiAdvance: r.uint8,
        vertBearingX: r.int8,
        vertBearingY: r.int8,
        vertAdvance: r.uint8
    });
var SmallMetrics = new r.Struct({
        height: r.uint8,
        width: r.uint8,
        bearingX: r.int8,
        bearingY: r.int8,
        advance: r.uint8
    });
var EBDTComponent = new r.Struct({
        glyph: r.uint16,
        xOffset: r.int8,
        yOffset: r.int8
    });
var ByteAligned = function ByteAligned() {
    _classCallCheck(this, ByteAligned);
};
var BitAligned = function BitAligned() {
    _classCallCheck(this, BitAligned);
};
var glyph = new r.VersionedStruct('version', {
        1: {
            metrics: SmallMetrics,
            data: ByteAligned
        },
        2: {
            metrics: SmallMetrics,
            data: BitAligned
        },
        5: { data: BitAligned },
        6: {
            metrics: BigMetrics,
            data: ByteAligned
        },
        7: {
            metrics: BigMetrics,
            data: BitAligned
        },
        8: {
            metrics: SmallMetrics,
            pad: new r.Reserved(r.uint8),
            numComponents: r.uint16,
            components: new r.Array(EBDTComponent, 'numComponents')
        },
        9: {
            metrics: BigMetrics,
            pad: new r.Reserved(r.uint8),
            numComponents: r.uint16,
            components: new r.Array(EBDTComponent, 'numComponents')
        },
        17: {
            metrics: SmallMetrics,
            dataLen: r.uint32,
            data: new r.Buffer('dataLen')
        },
        18: {
            metrics: BigMetrics,
            dataLen: r.uint32,
            data: new r.Buffer('dataLen')
        },
        19: {
            dataLen: r.uint32,
            data: new r.Buffer('dataLen')
        }
    });
var SBitLineMetrics = new r.Struct({
        ascender: r.int8,
        descender: r.int8,
        widthMax: r.uint8,
        caretSlopeNumerator: r.int8,
        caretSlopeDenominator: r.int8,
        caretOffset: r.int8,
        minOriginSB: r.int8,
        minAdvanceSB: r.int8,
        maxBeforeBL: r.int8,
        minAfterBL: r.int8,
        pad: new r.Reserved(r.int8, 2)
    });
var CodeOffsetPair = new r.Struct({
        glyphCode: r.uint16,
        offset: r.uint16
    });
var IndexSubtable = new r.VersionedStruct(r.uint16, {
        header: {
            imageFormat: r.uint16,
            imageDataOffset: r.uint32
        },
        1: {
            offsetArray: new r.Array(r.uint32, function (t) {
                return t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1;
            })
        },
        2: {
            imageSize: r.uint32,
            bigMetrics: BigMetrics
        },
        3: {
            offsetArray: new r.Array(r.uint16, function (t) {
                return t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1;
            })
        },
        4: {
            numGlyphs: r.uint32,
            glyphArray: new r.Array(CodeOffsetPair, function (t) {
                return t.numGlyphs + 1;
            })
        },
        5: {
            imageSize: r.uint32,
            bigMetrics: BigMetrics,
            numGlyphs: r.uint32,
            glyphCodeArray: new r.Array(r.uint16, 'numGlyphs')
        }
    });
var IndexSubtableArray = new r.Struct({
        firstGlyphIndex: r.uint16,
        lastGlyphIndex: r.uint16,
        subtable: new r.Pointer(r.uint32, IndexSubtable)
    });
var BitmapSizeTable = new r.Struct({
        indexSubTableArray: new r.Pointer(r.uint32, new r.Array(IndexSubtableArray, 1), { type: 'parent' }),
        indexTablesSize: r.uint32,
        numberOfIndexSubTables: r.uint32,
        colorRef: r.uint32,
        hori: SBitLineMetrics,
        vert: SBitLineMetrics,
        startGlyphIndex: r.uint16,
        endGlyphIndex: r.uint16,
        ppemX: r.uint8,
        ppemY: r.uint8,
        bitDepth: r.uint8,
        flags: new r.Bitfield(r.uint8, [
            'horizontal',
            'vertical'
        ])
    });
var EBLC = new r.Struct({
        version: r.uint32,
        numSizes: r.uint32,
        sizes: new r.Array(BitmapSizeTable, 'numSizes')
    });
var ImageTable = new r.Struct({
        ppem: r.uint16,
        resolution: r.uint16,
        imageOffsets: new r.Array(new r.Pointer(r.uint32, 'void'), function (t) {
            return t.parent.parent.maxp.numGlyphs + 1;
        })
    });
var sbix = new r.Struct({
        version: r.uint16,
        flags: new r.Bitfield(r.uint16, ['renderOutlines']),
        numImgTables: r.uint32,
        imageTables: new r.Array(new r.Pointer(r.uint32, ImageTable), 'numImgTables')
    });
var LayerRecord = new r.Struct({
        gid: r.uint16,
        paletteIndex: r.uint16
    });
var BaseGlyphRecord = new r.Struct({
        gid: r.uint16,
        firstLayerIndex: r.uint16,
        numLayers: r.uint16
    });
var COLR = new r.Struct({
        version: r.uint16,
        numBaseGlyphRecords: r.uint16,
        baseGlyphRecord: new r.Pointer(r.uint32, new r.Array(BaseGlyphRecord, 'numBaseGlyphRecords')),
        layerRecords: new r.Pointer(r.uint32, new r.Array(LayerRecord, 'numLayerRecords'), { lazy: true }),
        numLayerRecords: r.uint16
    });
var ColorRecord = new r.Struct({
        blue: r.uint8,
        green: r.uint8,
        red: r.uint8,
        alpha: r.uint8
    });
var CPAL = new r.VersionedStruct(r.uint16, {
        header: {
            numPaletteEntries: r.uint16,
            numPalettes: r.uint16,
            numColorRecords: r.uint16,
            colorRecords: new r.Pointer(r.uint32, new r.Array(ColorRecord, 'numColorRecords')),
            colorRecordIndices: new r.Array(r.uint16, 'numPalettes')
        },
        0: {},
        1: {
            offsetPaletteTypeArray: new r.Pointer(r.uint32, new r.Array(r.uint32, 'numPalettes')),
            offsetPaletteLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPalettes')),
            offsetPaletteEntryLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPaletteEntries'))
        }
    });
var BaseCoord = new r.VersionedStruct(r.uint16, {
        1: { coordinate: r.int16 },
        2: {
            coordinate: r.int16,
            referenceGlyph: r.uint16,
            baseCoordPoint: r.uint16
        },
        3: {
            coordinate: r.int16,
            deviceTable: new r.Pointer(r.uint16, Device)
        }
    });
var BaseValues = new r.Struct({
        defaultIndex: r.uint16,
        baseCoordCount: r.uint16,
        baseCoords: new r.Array(new r.Pointer(r.uint16, BaseCoord), 'baseCoordCount')
    });
var FeatMinMaxRecord = new r.Struct({
        tag: new r.String(4),
        minCoord: new r.Pointer(r.uint16, BaseCoord, { type: 'parent' }),
        maxCoord: new r.Pointer(r.uint16, BaseCoord, { type: 'parent' })
    });
var MinMax = new r.Struct({
        minCoord: new r.Pointer(r.uint16, BaseCoord),
        maxCoord: new r.Pointer(r.uint16, BaseCoord),
        featMinMaxCount: r.uint16,
        featMinMaxRecords: new r.Array(FeatMinMaxRecord, 'featMinMaxCount')
    });
var BaseLangSysRecord = new r.Struct({
        tag: new r.String(4),
        minMax: new r.Pointer(r.uint16, MinMax, { type: 'parent' })
    });
var BaseScript = new r.Struct({
        baseValues: new r.Pointer(r.uint16, BaseValues),
        defaultMinMax: new r.Pointer(r.uint16, MinMax),
        baseLangSysCount: r.uint16,
        baseLangSysRecords: new r.Array(BaseLangSysRecord, 'baseLangSysCount')
    });
var BaseScriptRecord = new r.Struct({
        tag: new r.String(4),
        script: new r.Pointer(r.uint16, BaseScript, { type: 'parent' })
    });
var BaseScriptList = new r.Array(BaseScriptRecord, r.uint16);
var BaseTagList = new r.Array(new r.String(4), r.uint16);
var Axis = new r.Struct({
        baseTagList: new r.Pointer(r.uint16, BaseTagList),
        baseScriptList: new r.Pointer(r.uint16, BaseScriptList)
    });
var BASE = new r.VersionedStruct(r.uint32, {
        header: {
            horizAxis: new r.Pointer(r.uint16, Axis),
            vertAxis: new r.Pointer(r.uint16, Axis)
        },
        65536: {},
        65537: { itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore) }
    });
var AttachPoint = new r.Array(r.uint16, r.uint16);
var AttachList = new r.Struct({
        coverage: new r.Pointer(r.uint16, Coverage),
        glyphCount: r.uint16,
        attachPoints: new r.Array(new r.Pointer(r.uint16, AttachPoint), 'glyphCount')
    });
var CaretValue = new r.VersionedStruct(r.uint16, {
        1: { coordinate: r.int16 },
        2: { caretValuePoint: r.uint16 },
        3: {
            coordinate: r.int16,
            deviceTable: new r.Pointer(r.uint16, Device)
        }
    });
var LigGlyph = new r.Array(new r.Pointer(r.uint16, CaretValue), r.uint16);
var LigCaretList = new r.Struct({
        coverage: new r.Pointer(r.uint16, Coverage),
        ligGlyphCount: r.uint16,
        ligGlyphs: new r.Array(new r.Pointer(r.uint16, LigGlyph), 'ligGlyphCount')
    });
var MarkGlyphSetsDef = new r.Struct({
        markSetTableFormat: r.uint16,
        markSetCount: r.uint16,
        coverage: new r.Array(new r.Pointer(r.uint32, Coverage), 'markSetCount')
    });
var GDEF = new r.VersionedStruct(r.uint32, {
        header: {
            glyphClassDef: new r.Pointer(r.uint16, ClassDef),
            attachList: new r.Pointer(r.uint16, AttachList),
            ligCaretList: new r.Pointer(r.uint16, LigCaretList),
            markAttachClassDef: new r.Pointer(r.uint16, ClassDef)
        },
        65536: {},
        65538: { markGlyphSetsDef: new r.Pointer(r.uint16, MarkGlyphSetsDef) },
        65539: {
            markGlyphSetsDef: new r.Pointer(r.uint16, MarkGlyphSetsDef),
            itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)
        }
    });
var ValueFormat = new r.Bitfield(r.uint16, [
        'xPlacement',
        'yPlacement',
        'xAdvance',
        'yAdvance',
        'xPlaDevice',
        'yPlaDevice',
        'xAdvDevice',
        'yAdvDevice'
    ]);
var types = {
        xPlacement: r.int16,
        yPlacement: r.int16,
        xAdvance: r.int16,
        yAdvance: r.int16,
        xPlaDevice: new r.Pointer(r.uint16, Device, {
            type: 'global',
            relativeTo: 'rel'
        }),
        yPlaDevice: new r.Pointer(r.uint16, Device, {
            type: 'global',
            relativeTo: 'rel'
        }),
        xAdvDevice: new r.Pointer(r.uint16, Device, {
            type: 'global',
            relativeTo: 'rel'
        }),
        yAdvDevice: new r.Pointer(r.uint16, Device, {
            type: 'global',
            relativeTo: 'rel'
        })
    };
var ValueRecord = function () {
        function ValueRecord() {
            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'valueFormat';
            _classCallCheck(this, ValueRecord);
            this.key = key;
        }
        ValueRecord.prototype.buildStruct = function buildStruct(parent) {
            var struct = parent;
            while (!struct[this.key] && struct.parent) {
                struct = struct.parent;
            }
            if (!struct[this.key])
                return;
            var fields = {};
            fields.rel = function () {
                return struct._startOffset;
            };
            var format = struct[this.key];
            for (var key in format) {
                if (format[key]) {
                    fields[key] = types[key];
                }
            }
            return new r.Struct(fields);
        };
        ValueRecord.prototype.size = function size(val, ctx) {
            return this.buildStruct(ctx).size(val, ctx);
        };
        ValueRecord.prototype.decode = function decode(stream, parent) {
            var res = this.buildStruct(parent).decode(stream, parent);
            delete res.rel;
            return res;
        };
        return ValueRecord;
    }();
var PairValueRecord = new r.Struct({
        secondGlyph: r.uint16,
        value1: new ValueRecord('valueFormat1'),
        value2: new ValueRecord('valueFormat2')
    });
var PairSet = new r.Array(PairValueRecord, r.uint16);
var Class2Record = new r.Struct({
        value1: new ValueRecord('valueFormat1'),
        value2: new ValueRecord('valueFormat2')
    });
var Anchor = new r.VersionedStruct(r.uint16, {
        1: {
            xCoordinate: r.int16,
            yCoordinate: r.int16
        },
        2: {
            xCoordinate: r.int16,
            yCoordinate: r.int16,
            anchorPoint: r.uint16
        },
        3: {
            xCoordinate: r.int16,
            yCoordinate: r.int16,
            xDeviceTable: new r.Pointer(r.uint16, Device),
            yDeviceTable: new r.Pointer(r.uint16, Device)
        }
    });
var EntryExitRecord = new r.Struct({
        entryAnchor: new r.Pointer(r.uint16, Anchor, { type: 'parent' }),
        exitAnchor: new r.Pointer(r.uint16, Anchor, { type: 'parent' })
    });
var MarkRecord = new r.Struct({
        class: r.uint16,
        markAnchor: new r.Pointer(r.uint16, Anchor, { type: 'parent' })
    });
var MarkArray = new r.Array(MarkRecord, r.uint16);
var BaseRecord = new r.Array(new r.Pointer(r.uint16, Anchor), function (t) {
        return t.parent.classCount;
    });
var BaseArray = new r.Array(BaseRecord, r.uint16);
var ComponentRecord = new r.Array(new r.Pointer(r.uint16, Anchor), function (t) {
        return t.parent.parent.classCount;
    });
var LigatureAttach = new r.Array(ComponentRecord, r.uint16);
var LigatureArray = new r.Array(new r.Pointer(r.uint16, LigatureAttach), r.uint16);
var GPOSLookup = new r.VersionedStruct('lookupType', {
        1: new r.VersionedStruct(r.uint16, {
            1: {
                coverage: new r.Pointer(r.uint16, Coverage),
                valueFormat: ValueFormat,
                value: new ValueRecord()
            },
            2: {
                coverage: new r.Pointer(r.uint16, Coverage),
                valueFormat: ValueFormat,
                valueCount: r.uint16,
                values: new r.LazyArray(new ValueRecord(), 'valueCount')
            }
        }),
        2: new r.VersionedStruct(r.uint16, {
            1: {
                coverage: new r.Pointer(r.uint16, Coverage),
                valueFormat1: ValueFormat,
                valueFormat2: ValueFormat,
                pairSetCount: r.uint16,
                pairSets: new r.LazyArray(new r.Pointer(r.uint16, PairSet), 'pairSetCount')
            },
            2: {
                coverage: new r.Pointer(r.uint16, Coverage),
                valueFormat1: ValueFormat,
                valueFormat2: ValueFormat,
                classDef1: new r.Pointer(r.uint16, ClassDef),
                classDef2: new r.Pointer(r.uint16, ClassDef),
                class1Count: r.uint16,
                class2Count: r.uint16,
                classRecords: new r.LazyArray(new r.LazyArray(Class2Record, 'class2Count'), 'class1Count')
            }
        }),
        3: {
            format: r.uint16,
            coverage: new r.Pointer(r.uint16, Coverage),
            entryExitCount: r.uint16,
            entryExitRecords: new r.Array(EntryExitRecord, 'entryExitCount')
        },
        4: {
            format: r.uint16,
            markCoverage: new r.Pointer(r.uint16, Coverage),
            baseCoverage: new r.Pointer(r.uint16, Coverage),
            classCount: r.uint16,
            markArray: new r.Pointer(r.uint16, MarkArray),
            baseArray: new r.Pointer(r.uint16, BaseArray)
        },
        5: {
            format: r.uint16,
            markCoverage: new r.Pointer(r.uint16, Coverage),
            ligatureCoverage: new r.Pointer(r.uint16, Coverage),
            classCount: r.uint16,
            markArray: new r.Pointer(r.uint16, MarkArray),
            ligatureArray: new r.Pointer(r.uint16, LigatureArray)
        },
        6: {
            format: r.uint16,
            mark1Coverage: new r.Pointer(r.uint16, Coverage),
            mark2Coverage: new r.Pointer(r.uint16, Coverage),
            classCount: r.uint16,
            mark1Array: new r.Pointer(r.uint16, MarkArray),
            mark2Array: new r.Pointer(r.uint16, BaseArray)
        },
        7: Context,
        8: ChainingContext,
        9: {
            posFormat: r.uint16,
            lookupType: r.uint16,
            extension: new r.Pointer(r.uint32, GPOSLookup)
        }
    });
GPOSLookup.versions[9].extension.type = GPOSLookup;
var GPOS = new r.VersionedStruct(r.uint32, {
        header: {
            scriptList: new r.Pointer(r.uint16, ScriptList),
            featureList: new r.Pointer(r.uint16, FeatureList),
            lookupList: new r.Pointer(r.uint16, new LookupList(GPOSLookup))
        },
        65536: {},
        65537: { featureVariations: new r.Pointer(r.uint32, FeatureVariations) }
    });
var Sequence = new r.Array(r.uint16, r.uint16);
var AlternateSet = Sequence;
var Ligature = new r.Struct({
        glyph: r.uint16,
        compCount: r.uint16,
        components: new r.Array(r.uint16, function (t) {
            return t.compCount - 1;
        })
    });
var LigatureSet = new r.Array(new r.Pointer(r.uint16, Ligature), r.uint16);
var GSUBLookup = new r.VersionedStruct('lookupType', {
        1: new r.VersionedStruct(r.uint16, {
            1: {
                coverage: new r.Pointer(r.uint16, Coverage),
                deltaGlyphID: r.int16
            },
            2: {
                coverage: new r.Pointer(r.uint16, Coverage),
                glyphCount: r.uint16,
                substitute: new r.LazyArray(r.uint16, 'glyphCount')
            }
        }),
        2: {
            substFormat: r.uint16,
            coverage: new r.Pointer(r.uint16, Coverage),
            count: r.uint16,
            sequences: new r.LazyArray(new r.Pointer(r.uint16, Sequence), 'count')
        },
        3: {
            substFormat: r.uint16,
            coverage: new r.Pointer(r.uint16, Coverage),
            count: r.uint16,
            alternateSet: new r.LazyArray(new r.Pointer(r.uint16, AlternateSet), 'count')
        },
        4: {
            substFormat: r.uint16,
            coverage: new r.Pointer(r.uint16, Coverage),
            count: r.uint16,
            ligatureSets: new r.LazyArray(new r.Pointer(r.uint16, LigatureSet), 'count')
        },
        5: Context,
        6: ChainingContext,
        7: {
            substFormat: r.uint16,
            lookupType: r.uint16,
            extension: new r.Pointer(r.uint32, GSUBLookup)
        },
        8: {
            substFormat: r.uint16,
            coverage: new r.Pointer(r.uint16, Coverage),
            backtrackCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),
            lookaheadGlyphCount: r.uint16,
            lookaheadCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),
            glyphCount: r.uint16,
            substitutes: new r.Array(r.uint16, 'glyphCount')
        }
    });
GSUBLookup.versions[7].extension.type = GSUBLookup;
var GSUB = new r.VersionedStruct(r.uint32, {
        header: {
            scriptList: new r.Pointer(r.uint16, ScriptList),
            featureList: new r.Pointer(r.uint16, FeatureList),
            lookupList: new r.Pointer(r.uint16, new LookupList(GSUBLookup))
        },
        65536: {},
        65537: { featureVariations: new r.Pointer(r.uint32, FeatureVariations) }
    });
var JstfGSUBModList = new r.Array(r.uint16, r.uint16);
var JstfPriority = new r.Struct({
        shrinkageEnableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
        shrinkageDisableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
        shrinkageEnableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
        shrinkageDisableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
        shrinkageJstfMax: new r.Pointer(r.uint16, new LookupList(GPOSLookup)),
        extensionEnableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
        extensionDisableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
        extensionEnableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
        extensionDisableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
        extensionJstfMax: new r.Pointer(r.uint16, new LookupList(GPOSLookup))
    });
var JstfLangSys = new r.Array(new r.Pointer(r.uint16, JstfPriority), r.uint16);
var JstfLangSysRecord = new r.Struct({
        tag: new r.String(4),
        jstfLangSys: new r.Pointer(r.uint16, JstfLangSys)
    });
var JstfScript = new r.Struct({
        extenderGlyphs: new r.Pointer(r.uint16, new r.Array(r.uint16, r.uint16)),
        defaultLangSys: new r.Pointer(r.uint16, JstfLangSys),
        langSysCount: r.uint16,
        langSysRecords: new r.Array(JstfLangSysRecord, 'langSysCount')
    });
var JstfScriptRecord = new r.Struct({
        tag: new r.String(4),
        script: new r.Pointer(r.uint16, JstfScript, { type: 'parent' })
    });
var JSTF = new r.Struct({
        version: r.uint32,
        scriptCount: r.uint16,
        scriptList: new r.Array(JstfScriptRecord, 'scriptCount')
    });
var VariableSizeNumber = function () {
        function VariableSizeNumber(size) {
            _classCallCheck(this, VariableSizeNumber);
            this._size = size;
        }
        VariableSizeNumber.prototype.decode = function decode(stream, parent) {
            switch (this.size(0, parent)) {
            case 1:
                return stream.readUInt8();
            case 2:
                return stream.readUInt16BE();
            case 3:
                return stream.readUInt24BE();
            case 4:
                return stream.readUInt32BE();
            }
        };
        VariableSizeNumber.prototype.size = function size(val, parent) {
            return restructure_src_utils.resolveLength(this._size, null, parent);
        };
        return VariableSizeNumber;
    }();
var MapDataEntry = new r.Struct({
        entry: new VariableSizeNumber(function (t) {
            return ((t.parent.entryFormat & 48) >> 4) + 1;
        }),
        outerIndex: function outerIndex(t) {
            return t.entry >> (t.parent.entryFormat & 15) + 1;
        },
        innerIndex: function innerIndex(t) {
            return t.entry & (1 << (t.parent.entryFormat & 15) + 1) - 1;
        }
    });
var DeltaSetIndexMap = new r.Struct({
        entryFormat: r.uint16,
        mapCount: r.uint16,
        mapData: new r.Array(MapDataEntry, 'mapCount')
    });
var HVAR = new r.Struct({
        majorVersion: r.uint16,
        minorVersion: r.uint16,
        itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore),
        advanceWidthMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),
        LSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),
        RSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap)
    });
var Signature = new r.Struct({
        format: r.uint32,
        length: r.uint32,
        offset: r.uint32
    });
var SignatureBlock = new r.Struct({
        reserved: new r.Reserved(r.uint16, 2),
        cbSignature: r.uint32,
        signature: new r.Buffer('cbSignature')
    });
var DSIG = new r.Struct({
        ulVersion: r.uint32,
        usNumSigs: r.uint16,
        usFlag: r.uint16,
        signatures: new r.Array(Signature, 'usNumSigs'),
        signatureBlocks: new r.Array(SignatureBlock, 'usNumSigs')
    });
var GaspRange = new r.Struct({
        rangeMaxPPEM: r.uint16,
        rangeGaspBehavior: new r.Bitfield(r.uint16, [
            'grayscale',
            'gridfit',
            'symmetricSmoothing',
            'symmetricGridfit'
        ])
    });
var gasp = new r.Struct({
        version: r.uint16,
        numRanges: r.uint16,
        gaspRanges: new r.Array(GaspRange, 'numRanges')
    });
var DeviceRecord = new r.Struct({
        pixelSize: r.uint8,
        maximumWidth: r.uint8,
        widths: new r.Array(r.uint8, function (t) {
            return t.parent.parent.maxp.numGlyphs;
        })
    });
var hdmx = new r.Struct({
        version: r.uint16,
        numRecords: r.int16,
        sizeDeviceRecord: r.int32,
        records: new r.Array(DeviceRecord, 'numRecords')
    });
var KernPair = new r.Struct({
        left: r.uint16,
        right: r.uint16,
        value: r.int16
    });
var ClassTable = new r.Struct({
        firstGlyph: r.uint16,
        nGlyphs: r.uint16,
        offsets: new r.Array(r.uint16, 'nGlyphs'),
        max: function max(t) {
            return t.offsets.length && Math.max.apply(Math, t.offsets);
        }
    });
var Kern2Array = new r.Struct({
        off: function off(t) {
            return t._startOffset - t.parent.parent._startOffset;
        },
        len: function len(t) {
            return ((t.parent.leftTable.max - t.off) / t.parent.rowWidth + 1) * (t.parent.rowWidth / 2);
        },
        values: new r.LazyArray(r.int16, 'len')
    });
var KernSubtable = new r.VersionedStruct('format', {
        0: {
            nPairs: r.uint16,
            searchRange: r.uint16,
            entrySelector: r.uint16,
            rangeShift: r.uint16,
            pairs: new r.Array(KernPair, 'nPairs')
        },
        2: {
            rowWidth: r.uint16,
            leftTable: new r.Pointer(r.uint16, ClassTable, { type: 'parent' }),
            rightTable: new r.Pointer(r.uint16, ClassTable, { type: 'parent' }),
            array: new r.Pointer(r.uint16, Kern2Array, { type: 'parent' })
        },
        3: {
            glyphCount: r.uint16,
            kernValueCount: r.uint8,
            leftClassCount: r.uint8,
            rightClassCount: r.uint8,
            flags: r.uint8,
            kernValue: new r.Array(r.int16, 'kernValueCount'),
            leftClass: new r.Array(r.uint8, 'glyphCount'),
            rightClass: new r.Array(r.uint8, 'glyphCount'),
            kernIndex: new r.Array(r.uint8, function (t) {
                return t.leftClassCount * t.rightClassCount;
            })
        }
    });
var KernTable = new r.VersionedStruct('version', {
        0: {
            subVersion: r.uint16,
            length: r.uint16,
            format: r.uint8,
            coverage: new r.Bitfield(r.uint8, [
                'horizontal',
                'minimum',
                'crossStream',
                'override'
            ]),
            subtable: KernSubtable,
            padding: new r.Reserved(r.uint8, function (t) {
                return t.length - t._currentOffset;
            })
        },
        1: {
            length: r.uint32,
            coverage: new r.Bitfield(r.uint8, [
                null,
                null,
                null,
                null,
                null,
                'variation',
                'crossStream',
                'vertical'
            ]),
            format: r.uint8,
            tupleIndex: r.uint16,
            subtable: KernSubtable,
            padding: new r.Reserved(r.uint8, function (t) {
                return t.length - t._currentOffset;
            })
        }
    });
var kern = new r.VersionedStruct(r.uint16, {
        0: {
            nTables: r.uint16,
            tables: new r.Array(KernTable, 'nTables')
        },
        1: {
            reserved: new r.Reserved(r.uint16),
            nTables: r.uint32,
            tables: new r.Array(KernTable, 'nTables')
        }
    });
var LTSH = new r.Struct({
        version: r.uint16,
        numGlyphs: r.uint16,
        yPels: new r.Array(r.uint8, 'numGlyphs')
    });
var PCLT = new r.Struct({
        version: r.uint16,
        fontNumber: r.uint32,
        pitch: r.uint16,
        xHeight: r.uint16,
        style: r.uint16,
        typeFamily: r.uint16,
        capHeight: r.uint16,
        symbolSet: r.uint16,
        typeface: new r.String(16),
        characterComplement: new r.String(8),
        fileName: new r.String(6),
        strokeWeight: new r.String(1),
        widthType: new r.String(1),
        serifStyle: r.uint8,
        reserved: new r.Reserved(r.uint8)
    });
var Ratio = new r.Struct({
        bCharSet: r.uint8,
        xRatio: r.uint8,
        yStartRatio: r.uint8,
        yEndRatio: r.uint8
    });
var vTable = new r.Struct({
        yPelHeight: r.uint16,
        yMax: r.int16,
        yMin: r.int16
    });
var VdmxGroup = new r.Struct({
        recs: r.uint16,
        startsz: r.uint8,
        endsz: r.uint8,
        entries: new r.Array(vTable, 'recs')
    });
var VDMX = new r.Struct({
        version: r.uint16,
        numRecs: r.uint16,
        numRatios: r.uint16,
        ratioRanges: new r.Array(Ratio, 'numRatios'),
        offsets: new r.Array(r.uint16, 'numRatios'),
        groups: new r.Array(VdmxGroup, 'numRecs')
    });
var vhea = new r.Struct({
        version: r.uint16,
        ascent: r.int16,
        descent: r.int16,
        lineGap: r.int16,
        advanceHeightMax: r.int16,
        minTopSideBearing: r.int16,
        minBottomSideBearing: r.int16,
        yMaxExtent: r.int16,
        caretSlopeRise: r.int16,
        caretSlopeRun: r.int16,
        caretOffset: r.int16,
        reserved: new r.Reserved(r.int16, 4),
        metricDataFormat: r.int16,
        numberOfMetrics: r.uint16
    });
var VmtxEntry = new r.Struct({
        advance: r.uint16,
        bearing: r.int16
    });
var vmtx = new r.Struct({
        metrics: new r.LazyArray(VmtxEntry, function (t) {
            return t.parent.vhea.numberOfMetrics;
        }),
        bearings: new r.LazyArray(r.int16, function (t) {
            return t.parent.maxp.numGlyphs - t.parent.vhea.numberOfMetrics;
        })
    });
var shortFrac = new r.Fixed(16, 'BE', 14);
var Correspondence = new r.Struct({
        fromCoord: shortFrac,
        toCoord: shortFrac
    });
var Segment = new r.Struct({
        pairCount: r.uint16,
        correspondence: new r.Array(Correspondence, 'pairCount')
    });
var avar = new r.Struct({
        version: r.fixed32,
        axisCount: r.uint32,
        segment: new r.Array(Segment, 'axisCount')
    });
var UnboundedArrayAccessor = function () {
        function UnboundedArrayAccessor(type, stream, parent) {
            _classCallCheck(this, UnboundedArrayAccessor);
            this.type = type;
            this.stream = stream;
            this.parent = parent;
            this.base = this.stream.pos;
            this._items = [];
        }
        UnboundedArrayAccessor.prototype.getItem = function getItem(index) {
            if (this._items[index] == null) {
                var pos = this.stream.pos;
                this.stream.pos = this.base + this.type.size(null, this.parent) * index;
                this._items[index] = this.type.decode(this.stream, this.parent);
                this.stream.pos = pos;
            }
            return this._items[index];
        };
        UnboundedArrayAccessor.prototype.inspect = function inspect() {
            return '[UnboundedArray ' + this.type.constructor.name + ']';
        };
        return UnboundedArrayAccessor;
    }();
var UnboundedArray = function (_r$Array) {
        _inherits(UnboundedArray, _r$Array);
        function UnboundedArray(type) {
            _classCallCheck(this, UnboundedArray);
            return _possibleConstructorReturn(this, _r$Array.call(this, type, 0));
        }
        UnboundedArray.prototype.decode = function decode(stream, parent) {
            return new UnboundedArrayAccessor(this.type, stream, parent);
        };
        return UnboundedArray;
    }(r.Array);
var LookupTable = function LookupTable() {
    var ValueType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : r.uint16;
    var Shadow = function () {
            function Shadow(type) {
                _classCallCheck(this, Shadow);
                this.type = type;
            }
            Shadow.prototype.decode = function decode(stream, ctx) {
                ctx = ctx.parent.parent;
                return this.type.decode(stream, ctx);
            };
            Shadow.prototype.size = function size(val, ctx) {
                ctx = ctx.parent.parent;
                return this.type.size(val, ctx);
            };
            Shadow.prototype.encode = function encode(stream, val, ctx) {
                ctx = ctx.parent.parent;
                return this.type.encode(stream, val, ctx);
            };
            return Shadow;
        }();
    ValueType = new Shadow(ValueType);
    var BinarySearchHeader = new r.Struct({
            unitSize: r.uint16,
            nUnits: r.uint16,
            searchRange: r.uint16,
            entrySelector: r.uint16,
            rangeShift: r.uint16
        });
    var LookupSegmentSingle = new r.Struct({
            lastGlyph: r.uint16,
            firstGlyph: r.uint16,
            value: ValueType
        });
    var LookupSegmentArray = new r.Struct({
            lastGlyph: r.uint16,
            firstGlyph: r.uint16,
            values: new r.Pointer(r.uint16, new r.Array(ValueType, function (t) {
                return t.lastGlyph - t.firstGlyph + 1;
            }), { type: 'parent' })
        });
    var LookupSingle = new r.Struct({
            glyph: r.uint16,
            value: ValueType
        });
    return new r.VersionedStruct(r.uint16, {
        0: { values: new UnboundedArray(ValueType) },
        2: {
            binarySearchHeader: BinarySearchHeader,
            segments: new r.Array(LookupSegmentSingle, function (t) {
                return t.binarySearchHeader.nUnits;
            })
        },
        4: {
            binarySearchHeader: BinarySearchHeader,
            segments: new r.Array(LookupSegmentArray, function (t) {
                return t.binarySearchHeader.nUnits;
            })
        },
        6: {
            binarySearchHeader: BinarySearchHeader,
            segments: new r.Array(LookupSingle, function (t) {
                return t.binarySearchHeader.nUnits;
            })
        },
        8: {
            firstGlyph: r.uint16,
            count: r.uint16,
            values: new r.Array(ValueType, 'count')
        }
    });
};
function StateTable() {
    var entryData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var lookupType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : r.uint16;
    var entry = _Object$assign({
            newState: r.uint16,
            flags: r.uint16
        }, entryData);
    var Entry = new r.Struct(entry);
    var StateArray = new UnboundedArray(new r.Array(r.uint16, function (t) {
            return t.nClasses;
        }));
    var StateHeader = new r.Struct({
            nClasses: r.uint32,
            classTable: new r.Pointer(r.uint32, new LookupTable(lookupType)),
            stateArray: new r.Pointer(r.uint32, StateArray),
            entryTable: new r.Pointer(r.uint32, new UnboundedArray(Entry))
        });
    return StateHeader;
}
function StateTable1() {
    var entryData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var lookupType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : r.uint16;
    var ClassLookupTable = new r.Struct({
            version: function version() {
                return 8;
            },
            firstGlyph: r.uint16,
            values: new r.Array(r.uint8, r.uint16)
        });
    var entry = _Object$assign({
            newStateOffset: r.uint16,
            newState: function newState(t) {
                return (t.newStateOffset - (t.parent.stateArray.base - t.parent._startOffset)) / t.parent.nClasses;
            },
            flags: r.uint16
        }, entryData);
    var Entry = new r.Struct(entry);
    var StateArray = new UnboundedArray(new r.Array(r.uint8, function (t) {
            return t.nClasses;
        }));
    var StateHeader1 = new r.Struct({
            nClasses: r.uint16,
            classTable: new r.Pointer(r.uint16, ClassLookupTable),
            stateArray: new r.Pointer(r.uint16, StateArray),
            entryTable: new r.Pointer(r.uint16, new UnboundedArray(Entry))
        });
    return StateHeader1;
}
var BslnSubtable = new r.VersionedStruct('format', {
        0: { deltas: new r.Array(r.int16, 32) },
        1: {
            deltas: new r.Array(r.int16, 32),
            mappingData: new LookupTable(r.uint16)
        },
        2: {
            standardGlyph: r.uint16,
            controlPoints: new r.Array(r.uint16, 32)
        },
        3: {
            standardGlyph: r.uint16,
            controlPoints: new r.Array(r.uint16, 32),
            mappingData: new LookupTable(r.uint16)
        }
    });
var bsln = new r.Struct({
        version: r.fixed32,
        format: r.uint16,
        defaultBaseline: r.uint16,
        subtable: BslnSubtable
    });
var Setting = new r.Struct({
        setting: r.uint16,
        nameIndex: r.int16,
        name: function name(t) {
            return t.parent.parent.parent.name.records.fontFeatures[t.nameIndex];
        }
    });
var FeatureName = new r.Struct({
        feature: r.uint16,
        nSettings: r.uint16,
        settingTable: new r.Pointer(r.uint32, new r.Array(Setting, 'nSettings'), { type: 'parent' }),
        featureFlags: new r.Bitfield(r.uint8, [
            null,
            null,
            null,
            null,
            null,
            null,
            'hasDefault',
            'exclusive'
        ]),
        defaultSetting: r.uint8,
        nameIndex: r.int16,
        name: function name(t) {
            return t.parent.parent.name.records.fontFeatures[t.nameIndex];
        }
    });
var feat = new r.Struct({
        version: r.fixed32,
        featureNameCount: r.uint16,
        reserved1: new r.Reserved(r.uint16),
        reserved2: new r.Reserved(r.uint32),
        featureNames: new r.Array(FeatureName, 'featureNameCount')
    });
var Axis$1 = new r.Struct({
        axisTag: new r.String(4),
        minValue: r.fixed32,
        defaultValue: r.fixed32,
        maxValue: r.fixed32,
        flags: r.uint16,
        nameID: r.uint16,
        name: function name(t) {
            return t.parent.parent.name.records.fontFeatures[t.nameID];
        }
    });
var Instance = new r.Struct({
        nameID: r.uint16,
        name: function name(t) {
            return t.parent.parent.name.records.fontFeatures[t.nameID];
        },
        flags: r.uint16,
        coord: new r.Array(r.fixed32, function (t) {
            return t.parent.axisCount;
        }),
        postscriptNameID: new r.Optional(r.uint16, function (t) {
            return t.parent.instanceSize - t._currentOffset > 0;
        })
    });
var fvar = new r.Struct({
        version: r.fixed32,
        offsetToData: r.uint16,
        countSizePairs: r.uint16,
        axisCount: r.uint16,
        axisSize: r.uint16,
        instanceCount: r.uint16,
        instanceSize: r.uint16,
        axis: new r.Array(Axis$1, 'axisCount'),
        instance: new r.Array(Instance, 'instanceCount')
    });
var shortFrac$1 = new r.Fixed(16, 'BE', 14);
var Offset = function () {
        function Offset() {
            _classCallCheck(this, Offset);
        }
        Offset.decode = function decode(stream, parent) {
            return parent.flags ? stream.readUInt32BE() : stream.readUInt16BE() * 2;
        };
        return Offset;
    }();
var gvar = new r.Struct({
        version: r.uint16,
        reserved: new r.Reserved(r.uint16),
        axisCount: r.uint16,
        globalCoordCount: r.uint16,
        globalCoords: new r.Pointer(r.uint32, new r.Array(new r.Array(shortFrac$1, 'axisCount'), 'globalCoordCount')),
        glyphCount: r.uint16,
        flags: r.uint16,
        offsetToData: r.uint32,
        offsets: new r.Array(new r.Pointer(Offset, 'void', {
            relativeTo: 'offsetToData',
            allowNull: false
        }), function (t) {
            return t.glyphCount + 1;
        })
    });
var ClassTable$1 = new r.Struct({
        length: r.uint16,
        coverage: r.uint16,
        subFeatureFlags: r.uint32,
        stateTable: new StateTable1()
    });
var WidthDeltaRecord = new r.Struct({
        justClass: r.uint32,
        beforeGrowLimit: r.fixed32,
        beforeShrinkLimit: r.fixed32,
        afterGrowLimit: r.fixed32,
        afterShrinkLimit: r.fixed32,
        growFlags: r.uint16,
        shrinkFlags: r.uint16
    });
var WidthDeltaCluster = new r.Array(WidthDeltaRecord, r.uint32);
var ActionData = new r.VersionedStruct('actionType', {
        0: {
            lowerLimit: r.fixed32,
            upperLimit: r.fixed32,
            order: r.uint16,
            glyphs: new r.Array(r.uint16, r.uint16)
        },
        1: { addGlyph: r.uint16 },
        2: {
            substThreshold: r.fixed32,
            addGlyph: r.uint16,
            substGlyph: r.uint16
        },
        3: {},
        4: {
            variationAxis: r.uint32,
            minimumLimit: r.fixed32,
            noStretchValue: r.fixed32,
            maximumLimit: r.fixed32
        },
        5: {
            flags: r.uint16,
            glyph: r.uint16
        }
    });
var Action = new r.Struct({
        actionClass: r.uint16,
        actionType: r.uint16,
        actionLength: r.uint32,
        actionData: ActionData,
        padding: new r.Reserved(r.uint8, function (t) {
            return t.actionLength - t._currentOffset;
        })
    });
var PostcompensationAction = new r.Array(Action, r.uint32);
var PostCompensationTable = new r.Struct({ lookupTable: new LookupTable(new r.Pointer(r.uint16, PostcompensationAction)) });
var JustificationTable = new r.Struct({
        classTable: new r.Pointer(r.uint16, ClassTable$1, { type: 'parent' }),
        wdcOffset: r.uint16,
        postCompensationTable: new r.Pointer(r.uint16, PostCompensationTable, { type: 'parent' }),
        widthDeltaClusters: new LookupTable(new r.Pointer(r.uint16, WidthDeltaCluster, {
            type: 'parent',
            relativeTo: 'wdcOffset'
        }))
    });
var just = new r.Struct({
        version: r.uint32,
        format: r.uint16,
        horizontal: new r.Pointer(r.uint16, JustificationTable),
        vertical: new r.Pointer(r.uint16, JustificationTable)
    });
var LigatureData = { action: r.uint16 };
var ContextualData = {
        markIndex: r.uint16,
        currentIndex: r.uint16
    };
var InsertionData = {
        currentInsertIndex: r.uint16,
        markedInsertIndex: r.uint16
    };
var SubstitutionTable = new r.Struct({ items: new UnboundedArray(new r.Pointer(r.uint32, new LookupTable())) });
var SubtableData = new r.VersionedStruct('type', {
        0: { stateTable: new StateTable() },
        1: {
            stateTable: new StateTable(ContextualData),
            substitutionTable: new r.Pointer(r.uint32, SubstitutionTable)
        },
        2: {
            stateTable: new StateTable(LigatureData),
            ligatureActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint32)),
            components: new r.Pointer(r.uint32, new UnboundedArray(r.uint16)),
            ligatureList: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))
        },
        4: { lookupTable: new LookupTable() },
        5: {
            stateTable: new StateTable(InsertionData),
            insertionActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))
        }
    });
var Subtable = new r.Struct({
        length: r.uint32,
        coverage: r.uint24,
        type: r.uint8,
        subFeatureFlags: r.uint32,
        table: SubtableData,
        padding: new r.Reserved(r.uint8, function (t) {
            return t.length - t._currentOffset;
        })
    });
var FeatureEntry = new r.Struct({
        featureType: r.uint16,
        featureSetting: r.uint16,
        enableFlags: r.uint32,
        disableFlags: r.uint32
    });
var MorxChain = new r.Struct({
        defaultFlags: r.uint32,
        chainLength: r.uint32,
        nFeatureEntries: r.uint32,
        nSubtables: r.uint32,
        features: new r.Array(FeatureEntry, 'nFeatureEntries'),
        subtables: new r.Array(Subtable, 'nSubtables')
    });
var morx = new r.Struct({
        version: r.uint16,
        unused: new r.Reserved(r.uint16),
        nChains: r.uint32,
        chains: new r.Array(MorxChain, 'nChains')
    });
var OpticalBounds = new r.Struct({
        left: r.int16,
        top: r.int16,
        right: r.int16,
        bottom: r.int16
    });
var opbd = new r.Struct({
        version: r.fixed32,
        format: r.uint16,
        lookupTable: new LookupTable(OpticalBounds)
    });
var tables = {};
tables.cmap = cmap;
tables.head = head;
tables.hhea = hhea;
tables.hmtx = hmtx;
tables.maxp = maxp;
tables.name = NameTable;
tables['OS/2'] = OS2;
tables.post = post;
tables.fpgm = fpgm;
tables.loca = loca;
tables.prep = prep;
tables['cvt '] = cvt;
tables.glyf = glyf;
tables['CFF '] = CFFFont;
tables['CFF2'] = CFFFont;
tables.VORG = VORG;
tables.EBLC = EBLC;
tables.CBLC = tables.EBLC;
tables.sbix = sbix;
tables.COLR = COLR;
tables.CPAL = CPAL;
tables.BASE = BASE;
tables.GDEF = GDEF;
tables.GPOS = GPOS;
tables.GSUB = GSUB;
tables.JSTF = JSTF;
tables.HVAR = HVAR;
tables.DSIG = DSIG;
tables.gasp = gasp;
tables.hdmx = hdmx;
tables.kern = kern;
tables.LTSH = LTSH;
tables.PCLT = PCLT;
tables.VDMX = VDMX;
tables.vhea = vhea;
tables.vmtx = vmtx;
tables.avar = avar;
tables.bsln = bsln;
tables.feat = feat;
tables.fvar = fvar;
tables.gvar = gvar;
tables.just = just;
tables.morx = morx;
tables.opbd = opbd;
var TableEntry = new r.Struct({
        tag: new r.String(4),
        checkSum: r.uint32,
        offset: new r.Pointer(r.uint32, 'void', { type: 'global' }),
        length: r.uint32
    });
var Directory = new r.Struct({
        tag: new r.String(4),
        numTables: r.uint16,
        searchRange: r.uint16,
        entrySelector: r.uint16,
        rangeShift: r.uint16,
        tables: new r.Array(TableEntry, 'numTables')
    });
Directory.process = function () {
    var tables = {};
    for (var _iterator = this.tables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length)
                break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done)
                break;
            _ref = _i.value;
        }
        var table = _ref;
        tables[table.tag] = table;
    }
    this.tables = tables;
};
Directory.preEncode = function (stream) {
    var tables$$ = [];
    for (var tag in this.tables) {
        var table = this.tables[tag];
        if (table) {
            tables$$.push({
                tag: tag,
                checkSum: 0,
                offset: new r.VoidPointer(tables[tag], table),
                length: tables[tag].size(table)
            });
        }
    }
    this.tag = 'true';
    this.numTables = tables$$.length;
    this.tables = tables$$;
    var maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
    var maxPowerOf2 = Math.pow(2, maxExponentFor2);
    this.searchRange = maxPowerOf2 * 16;
    this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
    this.rangeShift = this.numTables * 16 - this.searchRange;
};
function binarySearch(arr, cmp) {
    var min = 0;
    var max = arr.length - 1;
    while (min <= max) {
        var mid = min + max >> 1;
        var res = cmp(arr[mid]);
        if (res < 0) {
            max = mid - 1;
        } else if (res > 0) {
            min = mid + 1;
        } else {
            return mid;
        }
    }
    return -1;
}
function range(index, end) {
    var range = [];
    while (index < end) {
        range.push(index++);
    }
    return range;
}
var _class$1;
function _applyDecoratedDescriptor$1(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }
    return desc;
}
try {
    var iconv = function () {
            throw new Error('Cannot find module \'iconv-lite\' from \'C:\\Users\\Jack W\\dev\\oss\\triangulator2\\node_modules\\.registry.npmjs.org\\svgdom\\0.0.20\\node_modules\\fontkit\'');
        }();
} catch (err) {
}
var CmapProcessor = (_class$1 = function () {
        function CmapProcessor(cmapTable) {
            _classCallCheck(this, CmapProcessor);
            this.encoding = null;
            this.cmap = this.findSubtable(cmapTable, [
                [
                    3,
                    10
                ],
                [
                    0,
                    6
                ],
                [
                    0,
                    4
                ],
                [
                    3,
                    1
                ],
                [
                    0,
                    3
                ],
                [
                    0,
                    2
                ],
                [
                    0,
                    1
                ],
                [
                    0,
                    0
                ]
            ]);
            if (!this.cmap && iconv) {
                for (var _iterator = cmapTable.tables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length)
                            break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done)
                            break;
                        _ref = _i.value;
                    }
                    var cmap = _ref;
                    var encoding = getEncoding(cmap.platformID, cmap.encodingID, cmap.table.language - 1);
                    if (iconv.encodingExists(encoding)) {
                        this.cmap = cmap.table;
                        this.encoding = encoding;
                    }
                }
            }
            if (!this.cmap) {
                throw new Error('Could not find a supported cmap table');
            }
            this.uvs = this.findSubtable(cmapTable, [[
                    0,
                    5
                ]]);
            if (this.uvs && this.uvs.version !== 14) {
                this.uvs = null;
            }
        }
        CmapProcessor.prototype.findSubtable = function findSubtable(cmapTable, pairs) {
            for (var _iterator2 = pairs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var _ref3 = _ref2, platformID = _ref3[0], encodingID = _ref3[1];
                for (var _iterator3 = cmapTable.tables, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                    var _ref4;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length)
                            break;
                        _ref4 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if (_i3.done)
                            break;
                        _ref4 = _i3.value;
                    }
                    var cmap = _ref4;
                    if (cmap.platformID === platformID && cmap.encodingID === encodingID) {
                        return cmap.table;
                    }
                }
            }
            return null;
        };
        CmapProcessor.prototype.lookup = function lookup(codepoint, variationSelector) {
            if (this.encoding) {
                var buf = iconv.encode(_String$fromCodePoint(codepoint), this.encoding);
                codepoint = 0;
                for (var i = 0; i < buf.length; i++) {
                    codepoint = codepoint << 8 | buf[i];
                }
            } else if (variationSelector) {
                var gid = this.getVariationSelector(codepoint, variationSelector);
                if (gid) {
                    return gid;
                }
            }
            var cmap = this.cmap;
            switch (cmap.version) {
            case 0:
                return cmap.codeMap.get(codepoint) || 0;
            case 4: {
                    var min = 0;
                    var max = cmap.segCount - 1;
                    while (min <= max) {
                        var mid = min + max >> 1;
                        if (codepoint < cmap.startCode.get(mid)) {
                            max = mid - 1;
                        } else if (codepoint > cmap.endCode.get(mid)) {
                            min = mid + 1;
                        } else {
                            var rangeOffset = cmap.idRangeOffset.get(mid);
                            var _gid = void 0;
                            if (rangeOffset === 0) {
                                _gid = codepoint + cmap.idDelta.get(mid);
                            } else {
                                var index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
                                _gid = cmap.glyphIndexArray.get(index) || 0;
                                if (_gid !== 0) {
                                    _gid += cmap.idDelta.get(mid);
                                }
                            }
                            return _gid & 65535;
                        }
                    }
                    return 0;
                }
            case 8:
                throw new Error('TODO: cmap format 8');
            case 6:
            case 10:
                return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
            case 12:
            case 13: {
                    var _min = 0;
                    var _max = cmap.nGroups - 1;
                    while (_min <= _max) {
                        var _mid = _min + _max >> 1;
                        var group = cmap.groups.get(_mid);
                        if (codepoint < group.startCharCode) {
                            _max = _mid - 1;
                        } else if (codepoint > group.endCharCode) {
                            _min = _mid + 1;
                        } else {
                            if (cmap.version === 12) {
                                return group.glyphID + (codepoint - group.startCharCode);
                            } else {
                                return group.glyphID;
                            }
                        }
                    }
                    return 0;
                }
            case 14:
                throw new Error('TODO: cmap format 14');
            default:
                throw new Error('Unknown cmap format ' + cmap.version);
            }
        };
        CmapProcessor.prototype.getVariationSelector = function getVariationSelector(codepoint, variationSelector) {
            if (!this.uvs) {
                return 0;
            }
            var selectors = this.uvs.varSelectors.toArray();
            var i = binarySearch(selectors, function (x) {
                    return variationSelector - x.varSelector;
                });
            var sel = selectors[i];
            if (i !== -1 && sel.defaultUVS) {
                i = binarySearch(sel.defaultUVS, function (x) {
                    return codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? +1 : 0;
                });
            }
            if (i !== -1 && sel.nonDefaultUVS) {
                i = binarySearch(sel.nonDefaultUVS, function (x) {
                    return codepoint - x.unicodeValue;
                });
                if (i !== -1) {
                    return sel.nonDefaultUVS[i].glyphID;
                }
            }
            return 0;
        };
        CmapProcessor.prototype.getCharacterSet = function getCharacterSet() {
            var cmap = this.cmap;
            switch (cmap.version) {
            case 0:
                return range(0, cmap.codeMap.length);
            case 4: {
                    var res = [];
                    var endCodes = cmap.endCode.toArray();
                    for (var i = 0; i < endCodes.length; i++) {
                        var tail = endCodes[i] + 1;
                        var start = cmap.startCode.get(i);
                        res.push.apply(res, range(start, tail));
                    }
                    return res;
                }
            case 8:
                throw new Error('TODO: cmap format 8');
            case 6:
            case 10:
                return range(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);
            case 12:
            case 13: {
                    var _res = [];
                    for (var _iterator4 = cmap.groups.toArray(), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
                        var _ref5;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length)
                                break;
                            _ref5 = _iterator4[_i4++];
                        } else {
                            _i4 = _iterator4.next();
                            if (_i4.done)
                                break;
                            _ref5 = _i4.value;
                        }
                        var group = _ref5;
                        _res.push.apply(_res, range(group.startCharCode, group.endCharCode + 1));
                    }
                    return _res;
                }
            case 14:
                throw new Error('TODO: cmap format 14');
            default:
                throw new Error('Unknown cmap format ' + cmap.version);
            }
        };
        CmapProcessor.prototype.codePointsForGlyph = function codePointsForGlyph(gid) {
            var cmap = this.cmap;
            switch (cmap.version) {
            case 0: {
                    var res = [];
                    for (var i = 0; i < 256; i++) {
                        if (cmap.codeMap.get(i) === gid) {
                            res.push(i);
                        }
                    }
                    return res;
                }
            case 4: {
                    var _res2 = [];
                    for (var _i5 = 0; _i5 < cmap.segCount; _i5++) {
                        var end = cmap.endCode.get(_i5);
                        var start = cmap.startCode.get(_i5);
                        var rangeOffset = cmap.idRangeOffset.get(_i5);
                        var delta = cmap.idDelta.get(_i5);
                        for (var c = start; c <= end; c++) {
                            var g = 0;
                            if (rangeOffset === 0) {
                                g = c + delta;
                            } else {
                                var index = rangeOffset / 2 + (c - start) - (cmap.segCount - _i5);
                                g = cmap.glyphIndexArray.get(index) || 0;
                                if (g !== 0) {
                                    g += delta;
                                }
                            }
                            if (g === gid) {
                                _res2.push(c);
                            }
                        }
                    }
                    return _res2;
                }
            case 12: {
                    var _res3 = [];
                    for (var _iterator5 = cmap.groups.toArray(), _isArray5 = Array.isArray(_iterator5), _i6 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
                        var _ref6;
                        if (_isArray5) {
                            if (_i6 >= _iterator5.length)
                                break;
                            _ref6 = _iterator5[_i6++];
                        } else {
                            _i6 = _iterator5.next();
                            if (_i6.done)
                                break;
                            _ref6 = _i6.value;
                        }
                        var group = _ref6;
                        if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) {
                            _res3.push(group.startCharCode + (gid - group.glyphID));
                        }
                    }
                    return _res3;
                }
            case 13: {
                    var _res4 = [];
                    for (var _iterator6 = cmap.groups.toArray(), _isArray6 = Array.isArray(_iterator6), _i7 = 0, _iterator6 = _isArray6 ? _iterator6 : _getIterator(_iterator6);;) {
                        var _ref7;
                        if (_isArray6) {
                            if (_i7 >= _iterator6.length)
                                break;
                            _ref7 = _iterator6[_i7++];
                        } else {
                            _i7 = _iterator6.next();
                            if (_i7.done)
                                break;
                            _ref7 = _i7.value;
                        }
                        var _group = _ref7;
                        if (gid === _group.glyphID) {
                            _res4.push.apply(_res4, range(_group.startCharCode, _group.endCharCode + 1));
                        }
                    }
                    return _res4;
                }
            default:
                throw new Error('Unknown cmap format ' + cmap.version);
            }
        };
        return CmapProcessor;
    }(), (_applyDecoratedDescriptor$1(_class$1.prototype, 'getCharacterSet', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'getCharacterSet'), _class$1.prototype), _applyDecoratedDescriptor$1(_class$1.prototype, 'codePointsForGlyph', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'codePointsForGlyph'), _class$1.prototype)), _class$1);
var KernProcessor = function () {
        function KernProcessor(font) {
            _classCallCheck(this, KernProcessor);
            this.kern = font.kern;
        }
        KernProcessor.prototype.process = function process(glyphs, positions) {
            for (var glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
                var left = glyphs[glyphIndex].id;
                var right = glyphs[glyphIndex + 1].id;
                positions[glyphIndex].xAdvance += this.getKerning(left, right);
            }
        };
        KernProcessor.prototype.getKerning = function getKerning(left, right) {
            var res = 0;
            for (var _iterator = this.kern.tables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var table = _ref;
                if (table.coverage.crossStream) {
                    continue;
                }
                switch (table.version) {
                case 0:
                    if (!table.coverage.horizontal) {
                        continue;
                    }
                    break;
                case 1:
                    if (table.coverage.vertical || table.coverage.variation) {
                        continue;
                    }
                    break;
                default:
                    throw new Error('Unsupported kerning table version ' + table.version);
                }
                var val = 0;
                var s = table.subtable;
                switch (table.format) {
                case 0:
                    var pairIdx = binarySearch(s.pairs, function (pair) {
                            return left - pair.left || right - pair.right;
                        });
                    if (pairIdx >= 0) {
                        val = s.pairs[pairIdx].value;
                    }
                    break;
                case 2:
                    var leftOffset = 0, rightOffset = 0;
                    if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) {
                        leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];
                    } else {
                        leftOffset = s.array.off;
                    }
                    if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) {
                        rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];
                    }
                    var index = (leftOffset + rightOffset - s.array.off) / 2;
                    val = s.array.values.get(index);
                    break;
                case 3:
                    if (left >= s.glyphCount || right >= s.glyphCount) {
                        return 0;
                    }
                    val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];
                    break;
                default:
                    throw new Error('Unsupported kerning sub-table format ' + table.format);
                }
                if (table.coverage.override) {
                    res = val;
                } else {
                    res += val;
                }
            }
            return res;
        };
        return KernProcessor;
    }();
var UnicodeLayoutEngine = function () {
        function UnicodeLayoutEngine(font) {
            _classCallCheck(this, UnicodeLayoutEngine);
            this.font = font;
        }
        UnicodeLayoutEngine.prototype.positionGlyphs = function positionGlyphs(glyphs, positions) {
            var clusterStart = 0;
            var clusterEnd = 0;
            for (var index = 0; index < glyphs.length; index++) {
                var glyph = glyphs[index];
                if (glyph.isMark) {
                    clusterEnd = index;
                } else {
                    if (clusterStart !== clusterEnd) {
                        this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
                    }
                    clusterStart = clusterEnd = index;
                }
            }
            if (clusterStart !== clusterEnd) {
                this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
            }
            return positions;
        };
        UnicodeLayoutEngine.prototype.positionCluster = function positionCluster(glyphs, positions, clusterStart, clusterEnd) {
            var base = glyphs[clusterStart];
            var baseBox = base.cbox.copy();
            if (base.codePoints.length > 1) {
                baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
            }
            var xOffset = -positions[clusterStart].xAdvance;
            var yOffset = 0;
            var yGap = this.font.unitsPerEm / 16;
            for (var index = clusterStart + 1; index <= clusterEnd; index++) {
                var mark = glyphs[index];
                var markBox = mark.cbox;
                var position = positions[index];
                var combiningClass = this.getCombiningClass(mark.codePoints[0]);
                if (combiningClass !== 'Not_Reordered') {
                    position.xOffset = position.yOffset = 0;
                    switch (combiningClass) {
                    case 'Double_Above':
                    case 'Double_Below':
                        position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
                        break;
                    case 'Attached_Below_Left':
                    case 'Below_Left':
                    case 'Above_Left':
                        position.xOffset += baseBox.minX - markBox.minX;
                        break;
                    case 'Attached_Above_Right':
                    case 'Below_Right':
                    case 'Above_Right':
                        position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
                        break;
                    default:
                        position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
                    }
                    switch (combiningClass) {
                    case 'Double_Below':
                    case 'Below_Left':
                    case 'Below':
                    case 'Below_Right':
                    case 'Attached_Below_Left':
                    case 'Attached_Below':
                        if (combiningClass === 'Attached_Below_Left' || combiningClass === 'Attached_Below') {
                            baseBox.minY += yGap;
                        }
                        position.yOffset = -baseBox.minY - markBox.maxY;
                        baseBox.minY += markBox.height;
                        break;
                    case 'Double_Above':
                    case 'Above_Left':
                    case 'Above':
                    case 'Above_Right':
                    case 'Attached_Above':
                    case 'Attached_Above_Right':
                        if (combiningClass === 'Attached_Above' || combiningClass === 'Attached_Above_Right') {
                            baseBox.maxY += yGap;
                        }
                        position.yOffset = baseBox.maxY - markBox.minY;
                        baseBox.maxY += markBox.height;
                        break;
                    }
                    position.xAdvance = position.yAdvance = 0;
                    position.xOffset += xOffset;
                    position.yOffset += yOffset;
                } else {
                    xOffset -= position.xAdvance;
                    yOffset -= position.yAdvance;
                }
            }
            return;
        };
        UnicodeLayoutEngine.prototype.getCombiningClass = function getCombiningClass(codePoint) {
            var combiningClass = unicode.getCombiningClass(codePoint);
            if ((codePoint & ~255) === 3584) {
                if (combiningClass === 'Not_Reordered') {
                    switch (codePoint) {
                    case 3633:
                    case 3636:
                    case 3637:
                    case 3638:
                    case 3639:
                    case 3655:
                    case 3660:
                    case 3645:
                    case 3662:
                        return 'Above_Right';
                    case 3761:
                    case 3764:
                    case 3765:
                    case 3766:
                    case 3767:
                    case 3771:
                    case 3788:
                    case 3789:
                        return 'Above';
                    case 3772:
                        return 'Below';
                    }
                } else if (codePoint === 3642) {
                    return 'Below_Right';
                }
            }
            switch (combiningClass) {
            case 'CCC10':
            case 'CCC11':
            case 'CCC12':
            case 'CCC13':
            case 'CCC14':
            case 'CCC15':
            case 'CCC16':
            case 'CCC17':
            case 'CCC18':
            case 'CCC20':
            case 'CCC22':
                return 'Below';
            case 'CCC23':
                return 'Attached_Above';
            case 'CCC24':
                return 'Above_Right';
            case 'CCC25':
            case 'CCC19':
                return 'Above_Left';
            case 'CCC26':
                return 'Above';
            case 'CCC21':
                break;
            case 'CCC27':
            case 'CCC28':
            case 'CCC30':
            case 'CCC31':
            case 'CCC33':
            case 'CCC34':
            case 'CCC35':
            case 'CCC36':
                return 'Above';
            case 'CCC29':
            case 'CCC32':
                return 'Below';
            case 'CCC103':
                return 'Below_Right';
            case 'CCC107':
                return 'Above_Right';
            case 'CCC118':
                return 'Below';
            case 'CCC122':
                return 'Above';
            case 'CCC129':
            case 'CCC132':
                return 'Below';
            case 'CCC130':
                return 'Above';
            }
            return combiningClass;
        };
        return UnicodeLayoutEngine;
    }();
var BBox = function () {
        function BBox() {
            var minX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;
            var minY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
            var maxX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -Infinity;
            var maxY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -Infinity;
            _classCallCheck(this, BBox);
            this.minX = minX;
            this.minY = minY;
            this.maxX = maxX;
            this.maxY = maxY;
        }
        BBox.prototype.addPoint = function addPoint(x, y) {
            if (Math.abs(x) !== Infinity) {
                if (x < this.minX) {
                    this.minX = x;
                }
                if (x > this.maxX) {
                    this.maxX = x;
                }
            }
            if (Math.abs(y) !== Infinity) {
                if (y < this.minY) {
                    this.minY = y;
                }
                if (y > this.maxY) {
                    this.maxY = y;
                }
            }
        };
        BBox.prototype.copy = function copy() {
            return new BBox(this.minX, this.minY, this.maxX, this.maxY);
        };
        _createClass(BBox, [
            {
                key: 'width',
                get: function get() {
                    return this.maxX - this.minX;
                }
            },
            {
                key: 'height',
                get: function get() {
                    return this.maxY - this.minY;
                }
            }
        ]);
        return BBox;
    }();
var UNICODE_SCRIPTS = {
        Caucasian_Albanian: 'aghb',
        Arabic: 'arab',
        Imperial_Aramaic: 'armi',
        Armenian: 'armn',
        Avestan: 'avst',
        Balinese: 'bali',
        Bamum: 'bamu',
        Bassa_Vah: 'bass',
        Batak: 'batk',
        Bengali: [
            'bng2',
            'beng'
        ],
        Bopomofo: 'bopo',
        Brahmi: 'brah',
        Braille: 'brai',
        Buginese: 'bugi',
        Buhid: 'buhd',
        Chakma: 'cakm',
        Canadian_Aboriginal: 'cans',
        Carian: 'cari',
        Cham: 'cham',
        Cherokee: 'cher',
        Coptic: 'copt',
        Cypriot: 'cprt',
        Cyrillic: 'cyrl',
        Devanagari: [
            'dev2',
            'deva'
        ],
        Deseret: 'dsrt',
        Duployan: 'dupl',
        Egyptian_Hieroglyphs: 'egyp',
        Elbasan: 'elba',
        Ethiopic: 'ethi',
        Georgian: 'geor',
        Glagolitic: 'glag',
        Gothic: 'goth',
        Grantha: 'gran',
        Greek: 'grek',
        Gujarati: [
            'gjr2',
            'gujr'
        ],
        Gurmukhi: [
            'gur2',
            'guru'
        ],
        Hangul: 'hang',
        Han: 'hani',
        Hanunoo: 'hano',
        Hebrew: 'hebr',
        Hiragana: 'hira',
        Pahawh_Hmong: 'hmng',
        Katakana_Or_Hiragana: 'hrkt',
        Old_Italic: 'ital',
        Javanese: 'java',
        Kayah_Li: 'kali',
        Katakana: 'kana',
        Kharoshthi: 'khar',
        Khmer: 'khmr',
        Khojki: 'khoj',
        Kannada: [
            'knd2',
            'knda'
        ],
        Kaithi: 'kthi',
        Tai_Tham: 'lana',
        Lao: 'lao ',
        Latin: 'latn',
        Lepcha: 'lepc',
        Limbu: 'limb',
        Linear_A: 'lina',
        Linear_B: 'linb',
        Lisu: 'lisu',
        Lycian: 'lyci',
        Lydian: 'lydi',
        Mahajani: 'mahj',
        Mandaic: 'mand',
        Manichaean: 'mani',
        Mende_Kikakui: 'mend',
        Meroitic_Cursive: 'merc',
        Meroitic_Hieroglyphs: 'mero',
        Malayalam: [
            'mlm2',
            'mlym'
        ],
        Modi: 'modi',
        Mongolian: 'mong',
        Mro: 'mroo',
        Meetei_Mayek: 'mtei',
        Myanmar: [
            'mym2',
            'mymr'
        ],
        Old_North_Arabian: 'narb',
        Nabataean: 'nbat',
        Nko: 'nko ',
        Ogham: 'ogam',
        Ol_Chiki: 'olck',
        Old_Turkic: 'orkh',
        Oriya: [
            'ory2',
            'orya'
        ],
        Osmanya: 'osma',
        Palmyrene: 'palm',
        Pau_Cin_Hau: 'pauc',
        Old_Permic: 'perm',
        Phags_Pa: 'phag',
        Inscriptional_Pahlavi: 'phli',
        Psalter_Pahlavi: 'phlp',
        Phoenician: 'phnx',
        Miao: 'plrd',
        Inscriptional_Parthian: 'prti',
        Rejang: 'rjng',
        Runic: 'runr',
        Samaritan: 'samr',
        Old_South_Arabian: 'sarb',
        Saurashtra: 'saur',
        Shavian: 'shaw',
        Sharada: 'shrd',
        Siddham: 'sidd',
        Khudawadi: 'sind',
        Sinhala: 'sinh',
        Sora_Sompeng: 'sora',
        Sundanese: 'sund',
        Syloti_Nagri: 'sylo',
        Syriac: 'syrc',
        Tagbanwa: 'tagb',
        Takri: 'takr',
        Tai_Le: 'tale',
        New_Tai_Lue: 'talu',
        Tamil: [
            'tml2',
            'taml'
        ],
        Tai_Viet: 'tavt',
        Telugu: [
            'tel2',
            'telu'
        ],
        Tifinagh: 'tfng',
        Tagalog: 'tglg',
        Thaana: 'thaa',
        Thai: 'thai',
        Tibetan: 'tibt',
        Tirhuta: 'tirh',
        Ugaritic: 'ugar',
        Vai: 'vai ',
        Warang_Citi: 'wara',
        Old_Persian: 'xpeo',
        Cuneiform: 'xsux',
        Yi: 'yi  ',
        Inherited: 'zinh',
        Common: 'zyyy',
        Unknown: 'zzzz'
    };
var OPENTYPE_SCRIPTS = {};
for (var script in UNICODE_SCRIPTS) {
    var tag = UNICODE_SCRIPTS[script];
    if (Array.isArray(tag)) {
        for (var _iterator = tag, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
            var _ref;
            if (_isArray) {
                if (_i >= _iterator.length)
                    break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done)
                    break;
                _ref = _i.value;
            }
            var t = _ref;
            OPENTYPE_SCRIPTS[t] = script;
        }
    } else {
        OPENTYPE_SCRIPTS[tag] = script;
    }
}
function fromOpenType(tag) {
    return OPENTYPE_SCRIPTS[tag];
}
function forString(string) {
    var len = string.length;
    var idx = 0;
    while (idx < len) {
        var code = string.charCodeAt(idx++);
        if (55296 <= code && code <= 56319 && idx < len) {
            var next = string.charCodeAt(idx);
            if (56320 <= next && next <= 57343) {
                idx++;
                code = ((code & 1023) << 10) + (next & 1023) + 65536;
            }
        }
        var _script = unicode.getScript(code);
        if (_script !== 'Common' && _script !== 'Inherited' && _script !== 'Unknown') {
            return UNICODE_SCRIPTS[_script];
        }
    }
    return UNICODE_SCRIPTS.Unknown;
}
function forCodePoints(codePoints) {
    for (var i = 0; i < codePoints.length; i++) {
        var codePoint = codePoints[i];
        var _script2 = unicode.getScript(codePoint);
        if (_script2 !== 'Common' && _script2 !== 'Inherited' && _script2 !== 'Unknown') {
            return UNICODE_SCRIPTS[_script2];
        }
    }
    return UNICODE_SCRIPTS.Unknown;
}
var RTL = {
        arab: true,
        hebr: true,
        syrc: true,
        thaa: true,
        cprt: true,
        khar: true,
        phnx: true,
        'nko ': true,
        lydi: true,
        avst: true,
        armi: true,
        phli: true,
        prti: true,
        sarb: true,
        orkh: true,
        samr: true,
        mand: true,
        merc: true,
        mero: true,
        mani: true,
        mend: true,
        nbat: true,
        narb: true,
        palm: true,
        phlp: true
    };
function direction(script) {
    if (RTL[script]) {
        return 'rtl';
    }
    return 'ltr';
}
var GlyphRun = function () {
        function GlyphRun(glyphs, features, script, language, direction$$) {
            _classCallCheck(this, GlyphRun);
            this.glyphs = glyphs;
            this.positions = null;
            this.script = script;
            this.language = language || null;
            this.direction = direction$$ || direction(script);
            this.features = {};
            if (Array.isArray(features)) {
                for (var _iterator = features, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length)
                            break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done)
                            break;
                        _ref = _i.value;
                    }
                    var tag = _ref;
                    this.features[tag] = true;
                }
            } else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {
                this.features = features;
            }
        }
        _createClass(GlyphRun, [
            {
                key: 'advanceWidth',
                get: function get() {
                    var width = 0;
                    for (var _iterator2 = this.positions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length)
                                break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            _i2 = _iterator2.next();
                            if (_i2.done)
                                break;
                            _ref2 = _i2.value;
                        }
                        var position = _ref2;
                        width += position.xAdvance;
                    }
                    return width;
                }
            },
            {
                key: 'advanceHeight',
                get: function get() {
                    var height = 0;
                    for (var _iterator3 = this.positions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length)
                                break;
                            _ref3 = _iterator3[_i3++];
                        } else {
                            _i3 = _iterator3.next();
                            if (_i3.done)
                                break;
                            _ref3 = _i3.value;
                        }
                        var position = _ref3;
                        height += position.yAdvance;
                    }
                    return height;
                }
            },
            {
                key: 'bbox',
                get: function get() {
                    var bbox = new BBox();
                    var x = 0;
                    var y = 0;
                    for (var index = 0; index < this.glyphs.length; index++) {
                        var glyph = this.glyphs[index];
                        var p = this.positions[index];
                        var b = glyph.bbox;
                        bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);
                        bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);
                        x += p.xAdvance;
                        y += p.yAdvance;
                    }
                    return bbox;
                }
            }
        ]);
        return GlyphRun;
    }();
var GlyphPosition = function GlyphPosition() {
    var xAdvance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var yAdvance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var xOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var yOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    _classCallCheck(this, GlyphPosition);
    this.xAdvance = xAdvance;
    this.yAdvance = yAdvance;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
};
var features = {
        allTypographicFeatures: {
            code: 0,
            exclusive: false,
            allTypeFeatures: 0
        },
        ligatures: {
            code: 1,
            exclusive: false,
            requiredLigatures: 0,
            commonLigatures: 2,
            rareLigatures: 4,
            rebusPictures: 8,
            diphthongLigatures: 10,
            squaredLigatures: 12,
            abbrevSquaredLigatures: 14,
            symbolLigatures: 16,
            contextualLigatures: 18,
            historicalLigatures: 20
        },
        cursiveConnection: {
            code: 2,
            exclusive: true,
            unconnected: 0,
            partiallyConnected: 1,
            cursive: 2
        },
        letterCase: {
            code: 3,
            exclusive: true
        },
        verticalSubstitution: {
            code: 4,
            exclusive: false,
            substituteVerticalForms: 0
        },
        linguisticRearrangement: {
            code: 5,
            exclusive: false,
            linguisticRearrangement: 0
        },
        numberSpacing: {
            code: 6,
            exclusive: true,
            monospacedNumbers: 0,
            proportionalNumbers: 1,
            thirdWidthNumbers: 2,
            quarterWidthNumbers: 3
        },
        smartSwash: {
            code: 8,
            exclusive: false,
            wordInitialSwashes: 0,
            wordFinalSwashes: 2,
            nonFinalSwashes: 8
        },
        diacritics: {
            code: 9,
            exclusive: true,
            showDiacritics: 0,
            hideDiacritics: 1,
            decomposeDiacritics: 2
        },
        verticalPosition: {
            code: 10,
            exclusive: true,
            normalPosition: 0,
            superiors: 1,
            inferiors: 2,
            ordinals: 3,
            scientificInferiors: 4
        },
        fractions: {
            code: 11,
            exclusive: true,
            noFractions: 0,
            verticalFractions: 1,
            diagonalFractions: 2
        },
        overlappingCharacters: {
            code: 13,
            exclusive: false,
            preventOverlap: 0
        },
        typographicExtras: {
            code: 14,
            exclusive: false,
            slashedZero: 4
        },
        mathematicalExtras: {
            code: 15,
            exclusive: false,
            mathematicalGreek: 10
        },
        ornamentSets: {
            code: 16,
            exclusive: true,
            noOrnaments: 0,
            dingbats: 1,
            piCharacters: 2,
            fleurons: 3,
            decorativeBorders: 4,
            internationalSymbols: 5,
            mathSymbols: 6
        },
        characterAlternatives: {
            code: 17,
            exclusive: true,
            noAlternates: 0
        },
        designComplexity: {
            code: 18,
            exclusive: true,
            designLevel1: 0,
            designLevel2: 1,
            designLevel3: 2,
            designLevel4: 3,
            designLevel5: 4
        },
        styleOptions: {
            code: 19,
            exclusive: true,
            noStyleOptions: 0,
            displayText: 1,
            engravedText: 2,
            illuminatedCaps: 3,
            titlingCaps: 4,
            tallCaps: 5
        },
        characterShape: {
            code: 20,
            exclusive: true,
            traditionalCharacters: 0,
            simplifiedCharacters: 1,
            JIS1978Characters: 2,
            JIS1983Characters: 3,
            JIS1990Characters: 4,
            traditionalAltOne: 5,
            traditionalAltTwo: 6,
            traditionalAltThree: 7,
            traditionalAltFour: 8,
            traditionalAltFive: 9,
            expertCharacters: 10,
            JIS2004Characters: 11,
            hojoCharacters: 12,
            NLCCharacters: 13,
            traditionalNamesCharacters: 14
        },
        numberCase: {
            code: 21,
            exclusive: true,
            lowerCaseNumbers: 0,
            upperCaseNumbers: 1
        },
        textSpacing: {
            code: 22,
            exclusive: true,
            proportionalText: 0,
            monospacedText: 1,
            halfWidthText: 2,
            thirdWidthText: 3,
            quarterWidthText: 4,
            altProportionalText: 5,
            altHalfWidthText: 6
        },
        transliteration: {
            code: 23,
            exclusive: true,
            noTransliteration: 0
        },
        annotation: {
            code: 24,
            exclusive: true,
            noAnnotation: 0,
            boxAnnotation: 1,
            roundedBoxAnnotation: 2,
            circleAnnotation: 3,
            invertedCircleAnnotation: 4,
            parenthesisAnnotation: 5,
            periodAnnotation: 6,
            romanNumeralAnnotation: 7,
            diamondAnnotation: 8,
            invertedBoxAnnotation: 9,
            invertedRoundedBoxAnnotation: 10
        },
        kanaSpacing: {
            code: 25,
            exclusive: true,
            fullWidthKana: 0,
            proportionalKana: 1
        },
        ideographicSpacing: {
            code: 26,
            exclusive: true,
            fullWidthIdeographs: 0,
            proportionalIdeographs: 1,
            halfWidthIdeographs: 2
        },
        unicodeDecomposition: {
            code: 27,
            exclusive: false,
            canonicalComposition: 0,
            compatibilityComposition: 2,
            transcodingComposition: 4
        },
        rubyKana: {
            code: 28,
            exclusive: false,
            rubyKana: 2
        },
        CJKSymbolAlternatives: {
            code: 29,
            exclusive: true,
            noCJKSymbolAlternatives: 0,
            CJKSymbolAltOne: 1,
            CJKSymbolAltTwo: 2,
            CJKSymbolAltThree: 3,
            CJKSymbolAltFour: 4,
            CJKSymbolAltFive: 5
        },
        ideographicAlternatives: {
            code: 30,
            exclusive: true,
            noIdeographicAlternatives: 0,
            ideographicAltOne: 1,
            ideographicAltTwo: 2,
            ideographicAltThree: 3,
            ideographicAltFour: 4,
            ideographicAltFive: 5
        },
        CJKVerticalRomanPlacement: {
            code: 31,
            exclusive: true,
            CJKVerticalRomanCentered: 0,
            CJKVerticalRomanHBaseline: 1
        },
        italicCJKRoman: {
            code: 32,
            exclusive: false,
            CJKItalicRoman: 2
        },
        caseSensitiveLayout: {
            code: 33,
            exclusive: false,
            caseSensitiveLayout: 0,
            caseSensitiveSpacing: 2
        },
        alternateKana: {
            code: 34,
            exclusive: false,
            alternateHorizKana: 0,
            alternateVertKana: 2
        },
        stylisticAlternatives: {
            code: 35,
            exclusive: false,
            noStylisticAlternates: 0,
            stylisticAltOne: 2,
            stylisticAltTwo: 4,
            stylisticAltThree: 6,
            stylisticAltFour: 8,
            stylisticAltFive: 10,
            stylisticAltSix: 12,
            stylisticAltSeven: 14,
            stylisticAltEight: 16,
            stylisticAltNine: 18,
            stylisticAltTen: 20,
            stylisticAltEleven: 22,
            stylisticAltTwelve: 24,
            stylisticAltThirteen: 26,
            stylisticAltFourteen: 28,
            stylisticAltFifteen: 30,
            stylisticAltSixteen: 32,
            stylisticAltSeventeen: 34,
            stylisticAltEighteen: 36,
            stylisticAltNineteen: 38,
            stylisticAltTwenty: 40
        },
        contextualAlternates: {
            code: 36,
            exclusive: false,
            contextualAlternates: 0,
            swashAlternates: 2,
            contextualSwashAlternates: 4
        },
        lowerCase: {
            code: 37,
            exclusive: true,
            defaultLowerCase: 0,
            lowerCaseSmallCaps: 1,
            lowerCasePetiteCaps: 2
        },
        upperCase: {
            code: 38,
            exclusive: true,
            defaultUpperCase: 0,
            upperCaseSmallCaps: 1,
            upperCasePetiteCaps: 2
        },
        languageTag: {
            code: 39,
            exclusive: true
        },
        CJKRomanSpacing: {
            code: 103,
            exclusive: true,
            halfWidthCJKRoman: 0,
            proportionalCJKRoman: 1,
            defaultCJKRoman: 2,
            fullWidthCJKRoman: 3
        }
    };
var feature = function feature(name, selector) {
    return [
        features[name].code,
        features[name][selector]
    ];
};
var OTMapping = {
        rlig: feature('ligatures', 'requiredLigatures'),
        clig: feature('ligatures', 'contextualLigatures'),
        dlig: feature('ligatures', 'rareLigatures'),
        hlig: feature('ligatures', 'historicalLigatures'),
        liga: feature('ligatures', 'commonLigatures'),
        hist: feature('ligatures', 'historicalLigatures'),
        smcp: feature('lowerCase', 'lowerCaseSmallCaps'),
        pcap: feature('lowerCase', 'lowerCasePetiteCaps'),
        frac: feature('fractions', 'diagonalFractions'),
        dnom: feature('fractions', 'diagonalFractions'),
        numr: feature('fractions', 'diagonalFractions'),
        afrc: feature('fractions', 'verticalFractions'),
        case: feature('caseSensitiveLayout', 'caseSensitiveLayout'),
        ccmp: feature('unicodeDecomposition', 'canonicalComposition'),
        cpct: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'),
        valt: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'),
        swsh: feature('contextualAlternates', 'swashAlternates'),
        cswh: feature('contextualAlternates', 'contextualSwashAlternates'),
        curs: feature('cursiveConnection', 'cursive'),
        c2pc: feature('upperCase', 'upperCasePetiteCaps'),
        c2sc: feature('upperCase', 'upperCaseSmallCaps'),
        init: feature('smartSwash', 'wordInitialSwashes'),
        fin2: feature('smartSwash', 'wordFinalSwashes'),
        medi: feature('smartSwash', 'nonFinalSwashes'),
        med2: feature('smartSwash', 'nonFinalSwashes'),
        fin3: feature('smartSwash', 'wordFinalSwashes'),
        fina: feature('smartSwash', 'wordFinalSwashes'),
        pkna: feature('kanaSpacing', 'proportionalKana'),
        half: feature('textSpacing', 'halfWidthText'),
        halt: feature('textSpacing', 'altHalfWidthText'),
        hkna: feature('alternateKana', 'alternateHorizKana'),
        vkna: feature('alternateKana', 'alternateVertKana'),
        ital: feature('italicCJKRoman', 'CJKItalicRoman'),
        lnum: feature('numberCase', 'upperCaseNumbers'),
        onum: feature('numberCase', 'lowerCaseNumbers'),
        mgrk: feature('mathematicalExtras', 'mathematicalGreek'),
        calt: feature('contextualAlternates', 'contextualAlternates'),
        vrt2: feature('verticalSubstitution', 'substituteVerticalForms'),
        vert: feature('verticalSubstitution', 'substituteVerticalForms'),
        tnum: feature('numberSpacing', 'monospacedNumbers'),
        pnum: feature('numberSpacing', 'proportionalNumbers'),
        sups: feature('verticalPosition', 'superiors'),
        subs: feature('verticalPosition', 'inferiors'),
        ordn: feature('verticalPosition', 'ordinals'),
        pwid: feature('textSpacing', 'proportionalText'),
        hwid: feature('textSpacing', 'halfWidthText'),
        qwid: feature('textSpacing', 'quarterWidthText'),
        twid: feature('textSpacing', 'thirdWidthText'),
        fwid: feature('textSpacing', 'proportionalText'),
        palt: feature('textSpacing', 'altProportionalText'),
        trad: feature('characterShape', 'traditionalCharacters'),
        smpl: feature('characterShape', 'simplifiedCharacters'),
        jp78: feature('characterShape', 'JIS1978Characters'),
        jp83: feature('characterShape', 'JIS1983Characters'),
        jp90: feature('characterShape', 'JIS1990Characters'),
        jp04: feature('characterShape', 'JIS2004Characters'),
        expt: feature('characterShape', 'expertCharacters'),
        hojo: feature('characterShape', 'hojoCharacters'),
        nlck: feature('characterShape', 'NLCCharacters'),
        tnam: feature('characterShape', 'traditionalNamesCharacters'),
        ruby: feature('rubyKana', 'rubyKana'),
        titl: feature('styleOptions', 'titlingCaps'),
        zero: feature('typographicExtras', 'slashedZero'),
        ss01: feature('stylisticAlternatives', 'stylisticAltOne'),
        ss02: feature('stylisticAlternatives', 'stylisticAltTwo'),
        ss03: feature('stylisticAlternatives', 'stylisticAltThree'),
        ss04: feature('stylisticAlternatives', 'stylisticAltFour'),
        ss05: feature('stylisticAlternatives', 'stylisticAltFive'),
        ss06: feature('stylisticAlternatives', 'stylisticAltSix'),
        ss07: feature('stylisticAlternatives', 'stylisticAltSeven'),
        ss08: feature('stylisticAlternatives', 'stylisticAltEight'),
        ss09: feature('stylisticAlternatives', 'stylisticAltNine'),
        ss10: feature('stylisticAlternatives', 'stylisticAltTen'),
        ss11: feature('stylisticAlternatives', 'stylisticAltEleven'),
        ss12: feature('stylisticAlternatives', 'stylisticAltTwelve'),
        ss13: feature('stylisticAlternatives', 'stylisticAltThirteen'),
        ss14: feature('stylisticAlternatives', 'stylisticAltFourteen'),
        ss15: feature('stylisticAlternatives', 'stylisticAltFifteen'),
        ss16: feature('stylisticAlternatives', 'stylisticAltSixteen'),
        ss17: feature('stylisticAlternatives', 'stylisticAltSeventeen'),
        ss18: feature('stylisticAlternatives', 'stylisticAltEighteen'),
        ss19: feature('stylisticAlternatives', 'stylisticAltNineteen'),
        ss20: feature('stylisticAlternatives', 'stylisticAltTwenty')
    };
for (var i = 1; i <= 99; i++) {
    OTMapping['cv' + ('00' + i).slice(-2)] = [
        features.characterAlternatives.code,
        i
    ];
}
var AATMapping = {};
for (var ot in OTMapping) {
    var aat = OTMapping[ot];
    if (AATMapping[aat[0]] == null) {
        AATMapping[aat[0]] = {};
    }
    AATMapping[aat[0]][aat[1]] = ot;
}
function mapOTToAAT(features) {
    var res = {};
    for (var k in features) {
        var r = void 0;
        if (r = OTMapping[k]) {
            if (res[r[0]] == null) {
                res[r[0]] = {};
            }
            res[r[0]][r[1]] = features[k];
        }
    }
    return res;
}
function mapFeatureStrings(f) {
    var type = f[0], setting = f[1];
    if (isNaN(type)) {
        var typeCode = features[type] && features[type].code;
    } else {
        var typeCode = type;
    }
    if (isNaN(setting)) {
        var settingCode = features[type] && features[type][setting];
    } else {
        var settingCode = setting;
    }
    return [
        typeCode,
        settingCode
    ];
}
function mapAATToOT(features) {
    var res = {};
    if (Array.isArray(features)) {
        for (var k = 0; k < features.length; k++) {
            var r = void 0;
            var f = mapFeatureStrings(features[k]);
            if (r = AATMapping[f[0]] && AATMapping[f[0]][f[1]]) {
                res[r] = true;
            }
        }
    } else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {
        for (var type in features) {
            var _feature = features[type];
            for (var setting in _feature) {
                var _r = void 0;
                var _f = mapFeatureStrings([
                        type,
                        setting
                    ]);
                if (_feature[setting] && (_r = AATMapping[_f[0]] && AATMapping[_f[0]][_f[1]])) {
                    res[_r] = true;
                }
            }
        }
    }
    return _Object$keys(res);
}
var _class$3;
function _applyDecoratedDescriptor$3(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }
    return desc;
}
var AATLookupTable = (_class$3 = function () {
        function AATLookupTable(table) {
            _classCallCheck(this, AATLookupTable);
            this.table = table;
        }
        AATLookupTable.prototype.lookup = function lookup(glyph) {
            switch (this.table.version) {
            case 0:
                return this.table.values.getItem(glyph);
            case 2:
            case 4: {
                    var min = 0;
                    var max = this.table.binarySearchHeader.nUnits - 1;
                    while (min <= max) {
                        var mid = min + max >> 1;
                        var seg = this.table.segments[mid];
                        if (seg.firstGlyph === 65535) {
                            return null;
                        }
                        if (glyph < seg.firstGlyph) {
                            max = mid - 1;
                        } else if (glyph > seg.lastGlyph) {
                            min = mid + 1;
                        } else {
                            if (this.table.version === 2) {
                                return seg.value;
                            } else {
                                return seg.values[glyph - seg.firstGlyph];
                            }
                        }
                    }
                    return null;
                }
            case 6: {
                    var _min = 0;
                    var _max = this.table.binarySearchHeader.nUnits - 1;
                    while (_min <= _max) {
                        var mid = _min + _max >> 1;
                        var seg = this.table.segments[mid];
                        if (seg.glyph === 65535) {
                            return null;
                        }
                        if (glyph < seg.glyph) {
                            _max = mid - 1;
                        } else if (glyph > seg.glyph) {
                            _min = mid + 1;
                        } else {
                            return seg.value;
                        }
                    }
                    return null;
                }
            case 8:
                return this.table.values[glyph - this.table.firstGlyph];
            default:
                throw new Error('Unknown lookup table format: ' + this.table.version);
            }
        };
        AATLookupTable.prototype.glyphsForValue = function glyphsForValue(classValue) {
            var res = [];
            switch (this.table.version) {
            case 2:
            case 4: {
                    for (var _iterator = this.table.segments, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length)
                                break;
                            _ref = _iterator[_i++];
                        } else {
                            _i = _iterator.next();
                            if (_i.done)
                                break;
                            _ref = _i.value;
                        }
                        var segment = _ref;
                        if (this.table.version === 2 && segment.value === classValue) {
                            res.push.apply(res, range(segment.firstGlyph, segment.lastGlyph + 1));
                        } else {
                            for (var index = 0; index < segment.values.length; index++) {
                                if (segment.values[index] === classValue) {
                                    res.push(segment.firstGlyph + index);
                                }
                            }
                        }
                    }
                    break;
                }
            case 6: {
                    for (var _iterator2 = this.table.segments, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length)
                                break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            _i2 = _iterator2.next();
                            if (_i2.done)
                                break;
                            _ref2 = _i2.value;
                        }
                        var _segment = _ref2;
                        if (_segment.value === classValue) {
                            res.push(_segment.glyph);
                        }
                    }
                    break;
                }
            case 8: {
                    for (var i = 0; i < this.table.values.length; i++) {
                        if (this.table.values[i] === classValue) {
                            res.push(this.table.firstGlyph + i);
                        }
                    }
                    break;
                }
            default:
                throw new Error('Unknown lookup table format: ' + this.table.version);
            }
            return res;
        };
        return AATLookupTable;
    }(), _applyDecoratedDescriptor$3(_class$3.prototype, 'glyphsForValue', [cache], _Object$getOwnPropertyDescriptor(_class$3.prototype, 'glyphsForValue'), _class$3.prototype), _class$3);
var START_OF_TEXT_STATE = 0;
var END_OF_TEXT_CLASS = 0;
var OUT_OF_BOUNDS_CLASS = 1;
var DELETED_GLYPH_CLASS = 2;
var DONT_ADVANCE = 16384;
var AATStateMachine = function () {
        function AATStateMachine(stateTable) {
            _classCallCheck(this, AATStateMachine);
            this.stateTable = stateTable;
            this.lookupTable = new AATLookupTable(stateTable.classTable);
        }
        AATStateMachine.prototype.process = function process(glyphs, reverse, processEntry) {
            var currentState = START_OF_TEXT_STATE;
            var index = reverse ? glyphs.length - 1 : 0;
            var dir = reverse ? -1 : 1;
            while (dir === 1 && index <= glyphs.length || dir === -1 && index >= -1) {
                var glyph = null;
                var classCode = OUT_OF_BOUNDS_CLASS;
                var shouldAdvance = true;
                if (index === glyphs.length || index === -1) {
                    classCode = END_OF_TEXT_CLASS;
                } else {
                    glyph = glyphs[index];
                    if (glyph.id === 65535) {
                        classCode = DELETED_GLYPH_CLASS;
                    } else {
                        classCode = this.lookupTable.lookup(glyph.id);
                        if (classCode == null) {
                            classCode = OUT_OF_BOUNDS_CLASS;
                        }
                    }
                }
                var row = this.stateTable.stateArray.getItem(currentState);
                var entryIndex = row[classCode];
                var entry = this.stateTable.entryTable.getItem(entryIndex);
                if (classCode !== END_OF_TEXT_CLASS && classCode !== DELETED_GLYPH_CLASS) {
                    processEntry(glyph, entry, index);
                    shouldAdvance = !(entry.flags & DONT_ADVANCE);
                }
                currentState = entry.newState;
                if (shouldAdvance) {
                    index += dir;
                }
            }
            return glyphs;
        };
        AATStateMachine.prototype.traverse = function traverse(opts) {
            var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var visited = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _Set();
            if (visited.has(state)) {
                return;
            }
            visited.add(state);
            var _stateTable = this.stateTable, nClasses = _stateTable.nClasses, stateArray = _stateTable.stateArray, entryTable = _stateTable.entryTable;
            var row = stateArray.getItem(state);
            for (var classCode = 4; classCode < nClasses; classCode++) {
                var entryIndex = row[classCode];
                var entry = entryTable.getItem(entryIndex);
                for (var _iterator = this.lookupTable.glyphsForValue(classCode), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length)
                            break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done)
                            break;
                        _ref = _i.value;
                    }
                    var glyph = _ref;
                    if (opts.enter) {
                        opts.enter(glyph, entry);
                    }
                    if (entry.newState !== 0) {
                        this.traverse(opts, entry.newState, visited);
                    }
                    if (opts.exit) {
                        opts.exit(glyph, entry);
                    }
                }
            }
        };
        return AATStateMachine;
    }();
var _class$2;
function _applyDecoratedDescriptor$2(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }
    return desc;
}
var MARK_FIRST = 32768;
var MARK_LAST = 8192;
var VERB = 15;
var SET_MARK = 32768;
var SET_COMPONENT = 32768;
var PERFORM_ACTION = 8192;
var LAST_MASK = 2147483648;
var STORE_MASK = 1073741824;
var OFFSET_MASK = 1073741823;
var REVERSE_DIRECTION = 4194304;
var CURRENT_INSERT_BEFORE = 2048;
var MARKED_INSERT_BEFORE = 1024;
var CURRENT_INSERT_COUNT = 992;
var MARKED_INSERT_COUNT = 31;
var AATMorxProcessor = (_class$2 = function () {
        function AATMorxProcessor(font) {
            _classCallCheck(this, AATMorxProcessor);
            this.processIndicRearragement = this.processIndicRearragement.bind(this);
            this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
            this.processLigature = this.processLigature.bind(this);
            this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
            this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
            this.font = font;
            this.morx = font.morx;
            this.inputCache = null;
        }
        AATMorxProcessor.prototype.process = function process(glyphs) {
            var features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            for (var _iterator = this.morx.chains, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var chain = _ref;
                var flags = chain.defaultFlags;
                for (var _iterator2 = chain.features, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length)
                            break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        _i2 = _iterator2.next();
                        if (_i2.done)
                            break;
                        _ref2 = _i2.value;
                    }
                    var feature = _ref2;
                    var f = void 0;
                    if ((f = features[feature.featureType]) && f[feature.featureSetting]) {
                        flags &= feature.disableFlags;
                        flags |= feature.enableFlags;
                    }
                }
                for (var _iterator3 = chain.subtables, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length)
                            break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if (_i3.done)
                            break;
                        _ref3 = _i3.value;
                    }
                    var subtable = _ref3;
                    if (subtable.subFeatureFlags & flags) {
                        this.processSubtable(subtable, glyphs);
                    }
                }
            }
            var index = glyphs.length - 1;
            while (index >= 0) {
                if (glyphs[index].id === 65535) {
                    glyphs.splice(index, 1);
                }
                index--;
            }
            return glyphs;
        };
        AATMorxProcessor.prototype.processSubtable = function processSubtable(subtable, glyphs) {
            this.subtable = subtable;
            this.glyphs = glyphs;
            if (this.subtable.type === 4) {
                this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
                return;
            }
            this.ligatureStack = [];
            this.markedGlyph = null;
            this.firstGlyph = null;
            this.lastGlyph = null;
            this.markedIndex = null;
            var stateMachine = this.getStateMachine(subtable);
            var process = this.getProcessor();
            var reverse = !!(this.subtable.coverage & REVERSE_DIRECTION);
            return stateMachine.process(this.glyphs, reverse, process);
        };
        AATMorxProcessor.prototype.getStateMachine = function getStateMachine(subtable) {
            return new AATStateMachine(subtable.table.stateTable);
        };
        AATMorxProcessor.prototype.getProcessor = function getProcessor() {
            switch (this.subtable.type) {
            case 0:
                return this.processIndicRearragement;
            case 1:
                return this.processContextualSubstitution;
            case 2:
                return this.processLigature;
            case 4:
                return this.processNoncontextualSubstitutions;
            case 5:
                return this.processGlyphInsertion;
            default:
                throw new Error('Invalid morx subtable type: ' + this.subtable.type);
            }
        };
        AATMorxProcessor.prototype.processIndicRearragement = function processIndicRearragement(glyph, entry, index) {
            if (entry.flags & MARK_FIRST) {
                this.firstGlyph = index;
            }
            if (entry.flags & MARK_LAST) {
                this.lastGlyph = index;
            }
            reorderGlyphs(this.glyphs, entry.flags & VERB, this.firstGlyph, this.lastGlyph);
        };
        AATMorxProcessor.prototype.processContextualSubstitution = function processContextualSubstitution(glyph, entry, index) {
            var subsitutions = this.subtable.table.substitutionTable.items;
            if (entry.markIndex !== 65535) {
                var lookup = subsitutions.getItem(entry.markIndex);
                var lookupTable = new AATLookupTable(lookup);
                glyph = this.glyphs[this.markedGlyph];
                var gid = lookupTable.lookup(glyph.id);
                if (gid) {
                    this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);
                }
            }
            if (entry.currentIndex !== 65535) {
                var _lookup = subsitutions.getItem(entry.currentIndex);
                var _lookupTable = new AATLookupTable(_lookup);
                glyph = this.glyphs[index];
                var gid = _lookupTable.lookup(glyph.id);
                if (gid) {
                    this.glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);
                }
            }
            if (entry.flags & SET_MARK) {
                this.markedGlyph = index;
            }
        };
        AATMorxProcessor.prototype.processLigature = function processLigature(glyph, entry, index) {
            if (entry.flags & SET_COMPONENT) {
                this.ligatureStack.push(index);
            }
            if (entry.flags & PERFORM_ACTION) {
                var _ligatureStack;
                var actions = this.subtable.table.ligatureActions;
                var components = this.subtable.table.components;
                var ligatureList = this.subtable.table.ligatureList;
                var actionIndex = entry.action;
                var last = false;
                var ligatureIndex = 0;
                var codePoints = [];
                var ligatureGlyphs = [];
                while (!last) {
                    var _codePoints;
                    var componentGlyph = this.ligatureStack.pop();
                    (_codePoints = codePoints).unshift.apply(_codePoints, this.glyphs[componentGlyph].codePoints);
                    var action = actions.getItem(actionIndex++);
                    last = !!(action & LAST_MASK);
                    var store = !!(action & STORE_MASK);
                    var offset = (action & OFFSET_MASK) << 2 >> 2;
                    offset += this.glyphs[componentGlyph].id;
                    var component = components.getItem(offset);
                    ligatureIndex += component;
                    if (last || store) {
                        var ligatureEntry = ligatureList.getItem(ligatureIndex);
                        this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
                        ligatureGlyphs.push(componentGlyph);
                        ligatureIndex = 0;
                        codePoints = [];
                    } else {
                        this.glyphs[componentGlyph] = this.font.getGlyph(65535);
                    }
                }
                (_ligatureStack = this.ligatureStack).push.apply(_ligatureStack, ligatureGlyphs);
            }
        };
        AATMorxProcessor.prototype.processNoncontextualSubstitutions = function processNoncontextualSubstitutions(subtable, glyphs, index) {
            var lookupTable = new AATLookupTable(subtable.table.lookupTable);
            for (index = 0; index < glyphs.length; index++) {
                var glyph = glyphs[index];
                if (glyph.id !== 65535) {
                    var gid = lookupTable.lookup(glyph.id);
                    if (gid) {
                        glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);
                    }
                }
            }
        };
        AATMorxProcessor.prototype._insertGlyphs = function _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {
            var _glyphs;
            var insertions = [];
            while (count--) {
                var gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
                insertions.push(this.font.getGlyph(gid));
            }
            if (!isBefore) {
                glyphIndex++;
            }
            (_glyphs = this.glyphs).splice.apply(_glyphs, [
                glyphIndex,
                0
            ].concat(insertions));
        };
        AATMorxProcessor.prototype.processGlyphInsertion = function processGlyphInsertion(glyph, entry, index) {
            if (entry.flags & SET_MARK) {
                this.markedIndex = index;
            }
            if (entry.markedInsertIndex !== 65535) {
                var count = (entry.flags & MARKED_INSERT_COUNT) >>> 5;
                var isBefore = !!(entry.flags & MARKED_INSERT_BEFORE);
                this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
            }
            if (entry.currentInsertIndex !== 65535) {
                var _count = (entry.flags & CURRENT_INSERT_COUNT) >>> 5;
                var _isBefore = !!(entry.flags & CURRENT_INSERT_BEFORE);
                this._insertGlyphs(index, entry.currentInsertIndex, _count, _isBefore);
            }
        };
        AATMorxProcessor.prototype.getSupportedFeatures = function getSupportedFeatures() {
            var features = [];
            for (var _iterator4 = this.morx.chains, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
                var _ref4;
                if (_isArray4) {
                    if (_i4 >= _iterator4.length)
                        break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    _i4 = _iterator4.next();
                    if (_i4.done)
                        break;
                    _ref4 = _i4.value;
                }
                var chain = _ref4;
                for (var _iterator5 = chain.features, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length)
                            break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        _i5 = _iterator5.next();
                        if (_i5.done)
                            break;
                        _ref5 = _i5.value;
                    }
                    var feature = _ref5;
                    features.push([
                        feature.featureType,
                        feature.featureSetting
                    ]);
                }
            }
            return features;
        };
        AATMorxProcessor.prototype.generateInputs = function generateInputs(gid) {
            if (!this.inputCache) {
                this.generateInputCache();
            }
            return this.inputCache[gid] || [];
        };
        AATMorxProcessor.prototype.generateInputCache = function generateInputCache() {
            this.inputCache = {};
            for (var _iterator6 = this.morx.chains, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _getIterator(_iterator6);;) {
                var _ref6;
                if (_isArray6) {
                    if (_i6 >= _iterator6.length)
                        break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    _i6 = _iterator6.next();
                    if (_i6.done)
                        break;
                    _ref6 = _i6.value;
                }
                var chain = _ref6;
                var flags = chain.defaultFlags;
                for (var _iterator7 = chain.subtables, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _getIterator(_iterator7);;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i7 >= _iterator7.length)
                            break;
                        _ref7 = _iterator7[_i7++];
                    } else {
                        _i7 = _iterator7.next();
                        if (_i7.done)
                            break;
                        _ref7 = _i7.value;
                    }
                    var subtable = _ref7;
                    if (subtable.subFeatureFlags & flags) {
                        this.generateInputsForSubtable(subtable);
                    }
                }
            }
        };
        AATMorxProcessor.prototype.generateInputsForSubtable = function generateInputsForSubtable(subtable) {
            var _this = this;
            if (subtable.type !== 2) {
                return;
            }
            var reverse = !!(subtable.coverage & REVERSE_DIRECTION);
            if (reverse) {
                throw new Error('Reverse subtable, not supported.');
            }
            this.subtable = subtable;
            this.ligatureStack = [];
            var stateMachine = this.getStateMachine(subtable);
            var process = this.getProcessor();
            var input = [];
            var stack = [];
            this.glyphs = [];
            stateMachine.traverse({
                enter: function enter(glyph, entry) {
                    var glyphs = _this.glyphs;
                    stack.push({
                        glyphs: glyphs.slice(),
                        ligatureStack: _this.ligatureStack.slice()
                    });
                    var g = _this.font.getGlyph(glyph);
                    input.push(g);
                    glyphs.push(input[input.length - 1]);
                    process(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
                    var count = 0;
                    var found = 0;
                    for (var i = 0; i < glyphs.length && count <= 1; i++) {
                        if (glyphs[i].id !== 65535) {
                            count++;
                            found = glyphs[i].id;
                        }
                    }
                    if (count === 1) {
                        var result = input.map(function (g) {
                                return g.id;
                            });
                        var _cache = _this.inputCache[found];
                        if (_cache) {
                            _cache.push(result);
                        } else {
                            _this.inputCache[found] = [result];
                        }
                    }
                },
                exit: function exit() {
                    var _stack$pop = stack.pop();
                    _this.glyphs = _stack$pop.glyphs;
                    _this.ligatureStack = _stack$pop.ligatureStack;
                    input.pop();
                }
            });
        };
        return AATMorxProcessor;
    }(), _applyDecoratedDescriptor$2(_class$2.prototype, 'getStateMachine', [cache], _Object$getOwnPropertyDescriptor(_class$2.prototype, 'getStateMachine'), _class$2.prototype), _class$2);
function swap(glyphs, rangeA, rangeB) {
    var reverseA = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var reverseB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
    if (reverseB) {
        end.reverse();
    }
    var start = glyphs.splice.apply(glyphs, [
            rangeA[0],
            rangeA[1]
        ].concat(end));
    if (reverseA) {
        start.reverse();
    }
    glyphs.splice.apply(glyphs, [
        rangeB[0] - (rangeA[1] - 1),
        0
    ].concat(start));
    return glyphs;
}
function reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
    var length = lastGlyph - firstGlyph + 1;
    switch (verb) {
    case 0:
        return glyphs;
    case 1:
        return swap(glyphs, [
            firstGlyph,
            1
        ], [
            lastGlyph,
            0
        ]);
    case 2:
        return swap(glyphs, [
            firstGlyph,
            0
        ], [
            lastGlyph,
            1
        ]);
    case 3:
        return swap(glyphs, [
            firstGlyph,
            1
        ], [
            lastGlyph,
            1
        ]);
    case 4:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            0
        ]);
    case 5:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            0
        ], true, false);
    case 6:
        return swap(glyphs, [
            firstGlyph,
            0
        ], [
            lastGlyph,
            2
        ]);
    case 7:
        return swap(glyphs, [
            firstGlyph,
            0
        ], [
            lastGlyph,
            2
        ], false, true);
    case 8:
        return swap(glyphs, [
            firstGlyph,
            1
        ], [
            lastGlyph,
            2
        ]);
    case 9:
        return swap(glyphs, [
            firstGlyph,
            1
        ], [
            lastGlyph,
            2
        ], false, true);
    case 10:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            1
        ]);
    case 11:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            1
        ], true, false);
    case 12:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            2
        ]);
    case 13:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            2
        ], true, false);
    case 14:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            2
        ], false, true);
    case 15:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            2
        ], true, true);
    default:
        throw new Error('Unknown verb: ' + verb);
    }
}
var AATLayoutEngine = function () {
        function AATLayoutEngine(font) {
            _classCallCheck(this, AATLayoutEngine);
            this.font = font;
            this.morxProcessor = new AATMorxProcessor(font);
            this.fallbackPosition = false;
        }
        AATLayoutEngine.prototype.substitute = function substitute(glyphRun) {
            if (glyphRun.direction === 'rtl') {
                glyphRun.glyphs.reverse();
            }
            this.morxProcessor.process(glyphRun.glyphs, mapOTToAAT(glyphRun.features));
        };
        AATLayoutEngine.prototype.getAvailableFeatures = function getAvailableFeatures(script, language) {
            return mapAATToOT(this.morxProcessor.getSupportedFeatures());
        };
        AATLayoutEngine.prototype.stringsForGlyph = function stringsForGlyph(gid) {
            var glyphStrings = this.morxProcessor.generateInputs(gid);
            var result = new _Set();
            for (var _iterator = glyphStrings, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var glyphs = _ref;
                this._addStrings(glyphs, 0, result, '');
            }
            return result;
        };
        AATLayoutEngine.prototype._addStrings = function _addStrings(glyphs, index, strings, string) {
            var codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index]);
            for (var _iterator2 = codePoints, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var codePoint = _ref2;
                var s = string + _String$fromCodePoint(codePoint);
                if (index < glyphs.length - 1) {
                    this._addStrings(glyphs, index + 1, strings, s);
                } else {
                    strings.add(s);
                }
            }
        };
        return AATLayoutEngine;
    }();
var ShapingPlan = function () {
        function ShapingPlan(font, script, direction) {
            _classCallCheck(this, ShapingPlan);
            this.font = font;
            this.script = script;
            this.direction = direction;
            this.stages = [];
            this.globalFeatures = {};
            this.allFeatures = {};
        }
        ShapingPlan.prototype._addFeatures = function _addFeatures(features, global) {
            var stageIndex = this.stages.length - 1;
            var stage = this.stages[stageIndex];
            for (var _iterator = features, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var feature = _ref;
                if (this.allFeatures[feature] == null) {
                    stage.push(feature);
                    this.allFeatures[feature] = stageIndex;
                    if (global) {
                        this.globalFeatures[feature] = true;
                    }
                }
            }
        };
        ShapingPlan.prototype.add = function add(arg) {
            var global = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            if (this.stages.length === 0) {
                this.stages.push([]);
            }
            if (typeof arg === 'string') {
                arg = [arg];
            }
            if (Array.isArray(arg)) {
                this._addFeatures(arg, global);
            } else if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object') {
                this._addFeatures(arg.global || [], true);
                this._addFeatures(arg.local || [], false);
            } else {
                throw new Error('Unsupported argument to ShapingPlan#add');
            }
        };
        ShapingPlan.prototype.addStage = function addStage(arg, global) {
            if (typeof arg === 'function') {
                this.stages.push(arg, []);
            } else {
                this.stages.push([]);
                this.add(arg, global);
            }
        };
        ShapingPlan.prototype.setFeatureOverrides = function setFeatureOverrides(features) {
            if (Array.isArray(features)) {
                this.add(features);
            } else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {
                for (var tag in features) {
                    if (features[tag]) {
                        this.add(tag);
                    } else if (this.allFeatures[tag] != null) {
                        var stage = this.stages[this.allFeatures[tag]];
                        stage.splice(stage.indexOf(tag), 1);
                        delete this.allFeatures[tag];
                        delete this.globalFeatures[tag];
                    }
                }
            }
        };
        ShapingPlan.prototype.assignGlobalFeatures = function assignGlobalFeatures(glyphs) {
            for (var _iterator2 = glyphs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var glyph = _ref2;
                for (var feature in this.globalFeatures) {
                    glyph.features[feature] = true;
                }
            }
        };
        ShapingPlan.prototype.process = function process(processor, glyphs, positions) {
            for (var _iterator3 = this.stages, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length)
                        break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done)
                        break;
                    _ref3 = _i3.value;
                }
                var stage = _ref3;
                if (typeof stage === 'function') {
                    if (!positions) {
                        stage(this.font, glyphs, this);
                    }
                } else if (stage.length > 0) {
                    processor.applyFeatures(stage, glyphs, positions);
                }
            }
        };
        return ShapingPlan;
    }();
var _class$4;
var _temp;
var VARIATION_FEATURES = ['rvrn'];
var COMMON_FEATURES = [
        'ccmp',
        'locl',
        'rlig',
        'mark',
        'mkmk'
    ];
var FRACTIONAL_FEATURES = [
        'frac',
        'numr',
        'dnom'
    ];
var HORIZONTAL_FEATURES = [
        'calt',
        'clig',
        'liga',
        'rclt',
        'curs',
        'kern'
    ];
var DIRECTIONAL_FEATURES = {
        ltr: [
            'ltra',
            'ltrm'
        ],
        rtl: [
            'rtla',
            'rtlm'
        ]
    };
var DefaultShaper = (_temp = _class$4 = function () {
        function DefaultShaper() {
            _classCallCheck(this, DefaultShaper);
        }
        DefaultShaper.plan = function plan(_plan, glyphs, features) {
            this.planPreprocessing(_plan);
            this.planFeatures(_plan);
            this.planPostprocessing(_plan, features);
            _plan.assignGlobalFeatures(glyphs);
            this.assignFeatures(_plan, glyphs);
        };
        DefaultShaper.planPreprocessing = function planPreprocessing(plan) {
            plan.add({
                global: [].concat(VARIATION_FEATURES, DIRECTIONAL_FEATURES[plan.direction]),
                local: FRACTIONAL_FEATURES
            });
        };
        DefaultShaper.planFeatures = function planFeatures(plan) {
        };
        DefaultShaper.planPostprocessing = function planPostprocessing(plan, userFeatures) {
            plan.add([].concat(COMMON_FEATURES, HORIZONTAL_FEATURES));
            plan.setFeatureOverrides(userFeatures);
        };
        DefaultShaper.assignFeatures = function assignFeatures(plan, glyphs) {
            for (var i = 0; i < glyphs.length; i++) {
                var glyph = glyphs[i];
                if (glyph.codePoints[0] === 8260) {
                    var start = i;
                    var end = i + 1;
                    while (start > 0 && unicode.isDigit(glyphs[start - 1].codePoints[0])) {
                        glyphs[start - 1].features.numr = true;
                        glyphs[start - 1].features.frac = true;
                        start--;
                    }
                    while (end < glyphs.length && unicode.isDigit(glyphs[end].codePoints[0])) {
                        glyphs[end].features.dnom = true;
                        glyphs[end].features.frac = true;
                        end++;
                    }
                    glyph.features.frac = true;
                    i = end - 1;
                }
            }
        };
        return DefaultShaper;
    }(), _class$4.zeroMarkWidths = 'AFTER_GPOS', _temp);
var trie = new UnicodeTrie(Buffer('AAEQAAAAAAAAADGgAZUBav7t2CtPA0EUBeDZB00pin9AJZIEgyUEj0QhweDAgQOJxCBRBElQSBwSicLgkOAwnNKZ5GaY2c7uzj4o5yZfZrrbefbuIx2nSq3CGmzAWH/+K+UO7MIe7MMhHMMpnMMFXMIVXIt2t3CnP088iPqjqNN8e4Ij7Rle4LUH82rLm6i/92A+RERERERERERNmfz/89GDeRARERERzbN8ceps2Iwt9H0C9/AJ6yOlDkbTczcot5VSm8Pm1vcFWfb7+BKOLTuOd2UlTX4wGP85Eg953lWPFbnuN7PkjtLmalOWbNenkHOSa7T3KmR9MVTZ2zZkVj1kHa68MueVKH0R4zqQ44WEXLM8VjcWHP0PtKLfPzQnMtGn3W4QYf6qxFxceVI394r2xnV+1rih0fV1Vzf3fO1n3evL5J78ruvZ5ptX2Rwy92Tfb1wlEqut3U+sZ3HXOeJ7/zDrbyuP6+Zz0fqa6Nv3vhY7Yu1xWnGevmsvsUpTT/RYIe8waUH/rvHMWKFzLfN8L+rTfp645mfX7ftlnfDtYxN59w0=', 'base64'));
var FEATURES = [
        'isol',
        'fina',
        'fin2',
        'fin3',
        'medi',
        'med2',
        'init'
    ];
var ShapingClasses = {
        Non_Joining: 0,
        Left_Joining: 1,
        Right_Joining: 2,
        Dual_Joining: 3,
        Join_Causing: 3,
        ALAPH: 4,
        'DALATH RISH': 5,
        Transparent: 6
    };
var ISOL = 'isol';
var FINA = 'fina';
var FIN2 = 'fin2';
var FIN3 = 'fin3';
var MEDI = 'medi';
var MED2 = 'med2';
var INIT = 'init';
var NONE = null;
var STATE_TABLE = [
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                NONE,
                ISOL,
                1
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                NONE,
                ISOL,
                1
            ],
            [
                NONE,
                ISOL,
                6
            ]
        ],
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                NONE,
                ISOL,
                1
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                NONE,
                FIN2,
                5
            ],
            [
                NONE,
                ISOL,
                6
            ]
        ],
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                INIT,
                FINA,
                1
            ],
            [
                INIT,
                FINA,
                3
            ],
            [
                INIT,
                FINA,
                4
            ],
            [
                INIT,
                FINA,
                6
            ]
        ],
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                MEDI,
                FINA,
                1
            ],
            [
                MEDI,
                FINA,
                3
            ],
            [
                MEDI,
                FINA,
                4
            ],
            [
                MEDI,
                FINA,
                6
            ]
        ],
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                MED2,
                ISOL,
                1
            ],
            [
                MED2,
                ISOL,
                2
            ],
            [
                MED2,
                FIN2,
                5
            ],
            [
                MED2,
                ISOL,
                6
            ]
        ],
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                ISOL,
                ISOL,
                1
            ],
            [
                ISOL,
                ISOL,
                2
            ],
            [
                ISOL,
                FIN2,
                5
            ],
            [
                ISOL,
                ISOL,
                6
            ]
        ],
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                NONE,
                ISOL,
                1
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                NONE,
                FIN3,
                5
            ],
            [
                NONE,
                ISOL,
                6
            ]
        ]
    ];
var ArabicShaper = function (_DefaultShaper) {
        _inherits(ArabicShaper, _DefaultShaper);
        function ArabicShaper() {
            _classCallCheck(this, ArabicShaper);
            return _possibleConstructorReturn(this, _DefaultShaper.apply(this, arguments));
        }
        ArabicShaper.planFeatures = function planFeatures(plan) {
            plan.add([
                'ccmp',
                'locl'
            ]);
            for (var i = 0; i < FEATURES.length; i++) {
                var feature = FEATURES[i];
                plan.addStage(feature, false);
            }
            plan.addStage('mset');
        };
        ArabicShaper.assignFeatures = function assignFeatures(plan, glyphs) {
            _DefaultShaper.assignFeatures.call(this, plan, glyphs);
            var prev = -1;
            var state = 0;
            var actions = [];
            for (var i = 0; i < glyphs.length; i++) {
                var curAction = void 0, prevAction = void 0;
                var glyph = glyphs[i];
                var type = getShapingClass(glyph.codePoints[0]);
                if (type === ShapingClasses.Transparent) {
                    actions[i] = NONE;
                    continue;
                }
                var _STATE_TABLE$state$ty = STATE_TABLE[state][type];
                prevAction = _STATE_TABLE$state$ty[0];
                curAction = _STATE_TABLE$state$ty[1];
                state = _STATE_TABLE$state$ty[2];
                if (prevAction !== NONE && prev !== -1) {
                    actions[prev] = prevAction;
                }
                actions[i] = curAction;
                prev = i;
            }
            for (var index = 0; index < glyphs.length; index++) {
                var feature = void 0;
                var glyph = glyphs[index];
                if (feature = actions[index]) {
                    glyph.features[feature] = true;
                }
            }
        };
        return ArabicShaper;
    }(DefaultShaper);
function getShapingClass(codePoint) {
    var res = trie.get(codePoint);
    if (res) {
        return res - 1;
    }
    var category = unicode.getCategory(codePoint);
    if (category === 'Mn' || category === 'Me' || category === 'Cf') {
        return ShapingClasses.Transparent;
    }
    return ShapingClasses.Non_Joining;
}
var GlyphIterator = function () {
        function GlyphIterator(glyphs, options) {
            _classCallCheck(this, GlyphIterator);
            this.glyphs = glyphs;
            this.reset(options);
        }
        GlyphIterator.prototype.reset = function reset() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            this.options = options;
            this.flags = options.flags || {};
            this.markAttachmentType = options.markAttachmentType || 0;
            this.index = index;
        };
        GlyphIterator.prototype.shouldIgnore = function shouldIgnore(glyph) {
            return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;
        };
        GlyphIterator.prototype.move = function move(dir) {
            this.index += dir;
            while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) {
                this.index += dir;
            }
            if (0 > this.index || this.index >= this.glyphs.length) {
                return null;
            }
            return this.glyphs[this.index];
        };
        GlyphIterator.prototype.next = function next() {
            return this.move(+1);
        };
        GlyphIterator.prototype.prev = function prev() {
            return this.move(-1);
        };
        GlyphIterator.prototype.peek = function peek() {
            var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var idx = this.index;
            var res = this.increment(count);
            this.index = idx;
            return res;
        };
        GlyphIterator.prototype.peekIndex = function peekIndex() {
            var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var idx = this.index;
            this.increment(count);
            var res = this.index;
            this.index = idx;
            return res;
        };
        GlyphIterator.prototype.increment = function increment() {
            var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var dir = count < 0 ? -1 : 1;
            count = Math.abs(count);
            while (count--) {
                this.move(dir);
            }
            return this.glyphs[this.index];
        };
        _createClass(GlyphIterator, [{
                key: 'cur',
                get: function get() {
                    return this.glyphs[this.index] || null;
                }
            }]);
        return GlyphIterator;
    }();
var DEFAULT_SCRIPTS = [
        'DFLT',
        'dflt',
        'latn'
    ];
var OTProcessor = function () {
        function OTProcessor(font, table) {
            _classCallCheck(this, OTProcessor);
            this.font = font;
            this.table = table;
            this.script = null;
            this.scriptTag = null;
            this.language = null;
            this.languageTag = null;
            this.features = {};
            this.lookups = {};
            this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1;
            this.selectScript();
            this.glyphs = [];
            this.positions = [];
            this.ligatureID = 1;
            this.currentFeature = null;
        }
        OTProcessor.prototype.findScript = function findScript(script) {
            if (this.table.scriptList == null) {
                return null;
            }
            if (!Array.isArray(script)) {
                script = [script];
            }
            for (var _iterator = script, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var s = _ref;
                for (var _iterator2 = this.table.scriptList, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length)
                            break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        _i2 = _iterator2.next();
                        if (_i2.done)
                            break;
                        _ref2 = _i2.value;
                    }
                    var entry = _ref2;
                    if (entry.tag === s) {
                        return entry;
                    }
                }
            }
            return null;
        };
        OTProcessor.prototype.selectScript = function selectScript(script, language, direction$$) {
            var changed = false;
            var entry = void 0;
            if (!this.script || script !== this.scriptTag) {
                entry = this.findScript(script);
                if (!entry) {
                    entry = this.findScript(DEFAULT_SCRIPTS);
                }
                if (!entry) {
                    return this.scriptTag;
                }
                this.scriptTag = entry.tag;
                this.script = entry.script;
                this.language = null;
                this.languageTag = null;
                changed = true;
            }
            if (!direction$$ || direction$$ !== this.direction) {
                this.direction = direction$$ || direction(script);
            }
            if (language && language.length < 4) {
                language += ' '.repeat(4 - language.length);
            }
            if (!language || language !== this.languageTag) {
                this.language = null;
                for (var _iterator3 = this.script.langSysRecords, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length)
                            break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if (_i3.done)
                            break;
                        _ref3 = _i3.value;
                    }
                    var lang = _ref3;
                    if (lang.tag === language) {
                        this.language = lang.langSys;
                        this.languageTag = lang.tag;
                        break;
                    }
                }
                if (!this.language) {
                    this.language = this.script.defaultLangSys;
                    this.languageTag = null;
                }
                changed = true;
            }
            if (changed) {
                this.features = {};
                if (this.language) {
                    for (var _iterator4 = this.language.featureIndexes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length)
                                break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            _i4 = _iterator4.next();
                            if (_i4.done)
                                break;
                            _ref4 = _i4.value;
                        }
                        var featureIndex = _ref4;
                        var record = this.table.featureList[featureIndex];
                        var substituteFeature = this.substituteFeatureForVariations(featureIndex);
                        this.features[record.tag] = substituteFeature || record.feature;
                    }
                }
            }
            return this.scriptTag;
        };
        OTProcessor.prototype.lookupsForFeatures = function lookupsForFeatures() {
            var userFeatures = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var exclude = arguments[1];
            var lookups = [];
            for (var _iterator5 = userFeatures, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
                var _ref5;
                if (_isArray5) {
                    if (_i5 >= _iterator5.length)
                        break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    _i5 = _iterator5.next();
                    if (_i5.done)
                        break;
                    _ref5 = _i5.value;
                }
                var tag = _ref5;
                var feature = this.features[tag];
                if (!feature) {
                    continue;
                }
                for (var _iterator6 = feature.lookupListIndexes, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _getIterator(_iterator6);;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length)
                            break;
                        _ref6 = _iterator6[_i6++];
                    } else {
                        _i6 = _iterator6.next();
                        if (_i6.done)
                            break;
                        _ref6 = _i6.value;
                    }
                    var lookupIndex = _ref6;
                    if (exclude && exclude.indexOf(lookupIndex) !== -1) {
                        continue;
                    }
                    lookups.push({
                        feature: tag,
                        index: lookupIndex,
                        lookup: this.table.lookupList.get(lookupIndex)
                    });
                }
            }
            lookups.sort(function (a, b) {
                return a.index - b.index;
            });
            return lookups;
        };
        OTProcessor.prototype.substituteFeatureForVariations = function substituteFeatureForVariations(featureIndex) {
            if (this.variationsIndex === -1) {
                return null;
            }
            var record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
            var substitutions = record.featureTableSubstitution.substitutions;
            for (var _iterator7 = substitutions, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _getIterator(_iterator7);;) {
                var _ref7;
                if (_isArray7) {
                    if (_i7 >= _iterator7.length)
                        break;
                    _ref7 = _iterator7[_i7++];
                } else {
                    _i7 = _iterator7.next();
                    if (_i7.done)
                        break;
                    _ref7 = _i7.value;
                }
                var substitution = _ref7;
                if (substitution.featureIndex === featureIndex) {
                    return substitution.alternateFeatureTable;
                }
            }
            return null;
        };
        OTProcessor.prototype.findVariationsIndex = function findVariationsIndex(coords) {
            var variations = this.table.featureVariations;
            if (!variations) {
                return -1;
            }
            var records = variations.featureVariationRecords;
            for (var i = 0; i < records.length; i++) {
                var conditions = records[i].conditionSet.conditionTable;
                if (this.variationConditionsMatch(conditions, coords)) {
                    return i;
                }
            }
            return -1;
        };
        OTProcessor.prototype.variationConditionsMatch = function variationConditionsMatch(conditions, coords) {
            return conditions.every(function (condition) {
                var coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
                return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
            });
        };
        OTProcessor.prototype.applyFeatures = function applyFeatures(userFeatures, glyphs, advances) {
            var lookups = this.lookupsForFeatures(userFeatures);
            this.applyLookups(lookups, glyphs, advances);
        };
        OTProcessor.prototype.applyLookups = function applyLookups(lookups, glyphs, positions) {
            this.glyphs = glyphs;
            this.positions = positions;
            this.glyphIterator = new GlyphIterator(glyphs);
            for (var _iterator8 = lookups, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _getIterator(_iterator8);;) {
                var _ref8;
                if (_isArray8) {
                    if (_i8 >= _iterator8.length)
                        break;
                    _ref8 = _iterator8[_i8++];
                } else {
                    _i8 = _iterator8.next();
                    if (_i8.done)
                        break;
                    _ref8 = _i8.value;
                }
                var _ref9 = _ref8, feature = _ref9.feature, lookup = _ref9.lookup;
                this.currentFeature = feature;
                this.glyphIterator.reset(lookup.flags);
                while (this.glyphIterator.index < glyphs.length) {
                    if (!(feature in this.glyphIterator.cur.features)) {
                        this.glyphIterator.next();
                        continue;
                    }
                    for (var _iterator9 = lookup.subTables, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _getIterator(_iterator9);;) {
                        var _ref10;
                        if (_isArray9) {
                            if (_i9 >= _iterator9.length)
                                break;
                            _ref10 = _iterator9[_i9++];
                        } else {
                            _i9 = _iterator9.next();
                            if (_i9.done)
                                break;
                            _ref10 = _i9.value;
                        }
                        var table = _ref10;
                        var res = this.applyLookup(lookup.lookupType, table);
                        if (res) {
                            break;
                        }
                    }
                    this.glyphIterator.next();
                }
            }
        };
        OTProcessor.prototype.applyLookup = function applyLookup(lookup, table) {
            throw new Error('applyLookup must be implemented by subclasses');
        };
        OTProcessor.prototype.applyLookupList = function applyLookupList(lookupRecords) {
            var options = this.glyphIterator.options;
            var glyphIndex = this.glyphIterator.index;
            for (var _iterator10 = lookupRecords, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _getIterator(_iterator10);;) {
                var _ref11;
                if (_isArray10) {
                    if (_i10 >= _iterator10.length)
                        break;
                    _ref11 = _iterator10[_i10++];
                } else {
                    _i10 = _iterator10.next();
                    if (_i10.done)
                        break;
                    _ref11 = _i10.value;
                }
                var lookupRecord = _ref11;
                this.glyphIterator.reset(options, glyphIndex);
                this.glyphIterator.increment(lookupRecord.sequenceIndex);
                var lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);
                this.glyphIterator.reset(lookup.flags, this.glyphIterator.index);
                for (var _iterator11 = lookup.subTables, _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _getIterator(_iterator11);;) {
                    var _ref12;
                    if (_isArray11) {
                        if (_i11 >= _iterator11.length)
                            break;
                        _ref12 = _iterator11[_i11++];
                    } else {
                        _i11 = _iterator11.next();
                        if (_i11.done)
                            break;
                        _ref12 = _i11.value;
                    }
                    var table = _ref12;
                    if (this.applyLookup(lookup.lookupType, table)) {
                        break;
                    }
                }
            }
            this.glyphIterator.reset(options, glyphIndex);
            return true;
        };
        OTProcessor.prototype.coverageIndex = function coverageIndex(coverage, glyph) {
            if (glyph == null) {
                glyph = this.glyphIterator.cur.id;
            }
            switch (coverage.version) {
            case 1:
                return coverage.glyphs.indexOf(glyph);
            case 2:
                for (var _iterator12 = coverage.rangeRecords, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _getIterator(_iterator12);;) {
                    var _ref13;
                    if (_isArray12) {
                        if (_i12 >= _iterator12.length)
                            break;
                        _ref13 = _iterator12[_i12++];
                    } else {
                        _i12 = _iterator12.next();
                        if (_i12.done)
                            break;
                        _ref13 = _i12.value;
                    }
                    var range = _ref13;
                    if (range.start <= glyph && glyph <= range.end) {
                        return range.startCoverageIndex + glyph - range.start;
                    }
                }
                break;
            }
            return -1;
        };
        OTProcessor.prototype.match = function match(sequenceIndex, sequence, fn, matched) {
            var pos = this.glyphIterator.index;
            var glyph = this.glyphIterator.increment(sequenceIndex);
            var idx = 0;
            while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {
                if (matched) {
                    matched.push(this.glyphIterator.index);
                }
                idx++;
                glyph = this.glyphIterator.next();
            }
            this.glyphIterator.index = pos;
            if (idx < sequence.length) {
                return false;
            }
            return matched || true;
        };
        OTProcessor.prototype.sequenceMatches = function sequenceMatches(sequenceIndex, sequence) {
            return this.match(sequenceIndex, sequence, function (component, glyph) {
                return component === glyph.id;
            });
        };
        OTProcessor.prototype.sequenceMatchIndices = function sequenceMatchIndices(sequenceIndex, sequence) {
            var _this = this;
            return this.match(sequenceIndex, sequence, function (component, glyph) {
                if (!(_this.currentFeature in glyph.features)) {
                    return false;
                }
                return component === glyph.id;
            }, []);
        };
        OTProcessor.prototype.coverageSequenceMatches = function coverageSequenceMatches(sequenceIndex, sequence) {
            var _this2 = this;
            return this.match(sequenceIndex, sequence, function (coverage, glyph) {
                return _this2.coverageIndex(coverage, glyph.id) >= 0;
            });
        };
        OTProcessor.prototype.getClassID = function getClassID(glyph, classDef) {
            switch (classDef.version) {
            case 1:
                var i = glyph - classDef.startGlyph;
                if (i >= 0 && i < classDef.classValueArray.length) {
                    return classDef.classValueArray[i];
                }
                break;
            case 2:
                for (var _iterator13 = classDef.classRangeRecord, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _getIterator(_iterator13);;) {
                    var _ref14;
                    if (_isArray13) {
                        if (_i13 >= _iterator13.length)
                            break;
                        _ref14 = _iterator13[_i13++];
                    } else {
                        _i13 = _iterator13.next();
                        if (_i13.done)
                            break;
                        _ref14 = _i13.value;
                    }
                    var range = _ref14;
                    if (range.start <= glyph && glyph <= range.end) {
                        return range.class;
                    }
                }
                break;
            }
            return 0;
        };
        OTProcessor.prototype.classSequenceMatches = function classSequenceMatches(sequenceIndex, sequence, classDef) {
            var _this3 = this;
            return this.match(sequenceIndex, sequence, function (classID, glyph) {
                return classID === _this3.getClassID(glyph.id, classDef);
            });
        };
        OTProcessor.prototype.applyContext = function applyContext(table) {
            switch (table.version) {
            case 1:
                var index = this.coverageIndex(table.coverage);
                if (index === -1) {
                    return false;
                }
                var set = table.ruleSets[index];
                for (var _iterator14 = set, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : _getIterator(_iterator14);;) {
                    var _ref15;
                    if (_isArray14) {
                        if (_i14 >= _iterator14.length)
                            break;
                        _ref15 = _iterator14[_i14++];
                    } else {
                        _i14 = _iterator14.next();
                        if (_i14.done)
                            break;
                        _ref15 = _i14.value;
                    }
                    var rule = _ref15;
                    if (this.sequenceMatches(1, rule.input)) {
                        return this.applyLookupList(rule.lookupRecords);
                    }
                }
                break;
            case 2:
                if (this.coverageIndex(table.coverage) === -1) {
                    return false;
                }
                index = this.getClassID(this.glyphIterator.cur.id, table.classDef);
                if (index === -1) {
                    return false;
                }
                set = table.classSet[index];
                for (var _iterator15 = set, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : _getIterator(_iterator15);;) {
                    var _ref16;
                    if (_isArray15) {
                        if (_i15 >= _iterator15.length)
                            break;
                        _ref16 = _iterator15[_i15++];
                    } else {
                        _i15 = _iterator15.next();
                        if (_i15.done)
                            break;
                        _ref16 = _i15.value;
                    }
                    var _rule = _ref16;
                    if (this.classSequenceMatches(1, _rule.classes, table.classDef)) {
                        return this.applyLookupList(_rule.lookupRecords);
                    }
                }
                break;
            case 3:
                if (this.coverageSequenceMatches(0, table.coverages)) {
                    return this.applyLookupList(table.lookupRecords);
                }
                break;
            }
            return false;
        };
        OTProcessor.prototype.applyChainingContext = function applyChainingContext(table) {
            switch (table.version) {
            case 1:
                var index = this.coverageIndex(table.coverage);
                if (index === -1) {
                    return false;
                }
                var set = table.chainRuleSets[index];
                for (var _iterator16 = set, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : _getIterator(_iterator16);;) {
                    var _ref17;
                    if (_isArray16) {
                        if (_i16 >= _iterator16.length)
                            break;
                        _ref17 = _iterator16[_i16++];
                    } else {
                        _i16 = _iterator16.next();
                        if (_i16.done)
                            break;
                        _ref17 = _i16.value;
                    }
                    var rule = _ref17;
                    if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) {
                        return this.applyLookupList(rule.lookupRecords);
                    }
                }
                break;
            case 2:
                if (this.coverageIndex(table.coverage) === -1) {
                    return false;
                }
                index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
                var rules = table.chainClassSet[index];
                if (!rules) {
                    return false;
                }
                for (var _iterator17 = rules, _isArray17 = Array.isArray(_iterator17), _i17 = 0, _iterator17 = _isArray17 ? _iterator17 : _getIterator(_iterator17);;) {
                    var _ref18;
                    if (_isArray17) {
                        if (_i17 >= _iterator17.length)
                            break;
                        _ref18 = _iterator17[_i17++];
                    } else {
                        _i17 = _iterator17.next();
                        if (_i17.done)
                            break;
                        _ref18 = _i17.value;
                    }
                    var _rule2 = _ref18;
                    if (this.classSequenceMatches(-_rule2.backtrack.length, _rule2.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, _rule2.input, table.inputClassDef) && this.classSequenceMatches(1 + _rule2.input.length, _rule2.lookahead, table.lookaheadClassDef)) {
                        return this.applyLookupList(_rule2.lookupRecords);
                    }
                }
                break;
            case 3:
                if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) {
                    return this.applyLookupList(table.lookupRecords);
                }
                break;
            }
            return false;
        };
        return OTProcessor;
    }();
var GlyphInfo = function () {
        function GlyphInfo(font, id) {
            var codePoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var features = arguments[3];
            _classCallCheck(this, GlyphInfo);
            this._font = font;
            this.codePoints = codePoints;
            this.id = id;
            this.features = {};
            if (Array.isArray(features)) {
                for (var i = 0; i < features.length; i++) {
                    var feature = features[i];
                    this.features[feature] = true;
                }
            } else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {
                _Object$assign(this.features, features);
            }
            this.ligatureID = null;
            this.ligatureComponent = null;
            this.isLigated = false;
            this.cursiveAttachment = null;
            this.markAttachment = null;
            this.shaperInfo = null;
            this.substituted = false;
            this.isMultiplied = false;
        }
        GlyphInfo.prototype.copy = function copy() {
            return new GlyphInfo(this._font, this.id, this.codePoints, this.features);
        };
        _createClass(GlyphInfo, [{
                key: 'id',
                get: function get() {
                    return this._id;
                },
                set: function set(id) {
                    this._id = id;
                    this.substituted = true;
                    var GDEF = this._font.GDEF;
                    if (GDEF && GDEF.glyphClassDef) {
                        var classID = OTProcessor.prototype.getClassID(id, GDEF.glyphClassDef);
                        this.isBase = classID === 1;
                        this.isLigature = classID === 2;
                        this.isMark = classID === 3;
                        this.markAttachmentType = GDEF.markAttachClassDef ? OTProcessor.prototype.getClassID(id, GDEF.markAttachClassDef) : 0;
                    } else {
                        this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);
                        this.isBase = !this.isMark;
                        this.isLigature = this.codePoints.length > 1;
                        this.markAttachmentType = 0;
                    }
                }
            }]);
        return GlyphInfo;
    }();
var _class$5;
var _temp$1;
var HangulShaper = (_temp$1 = _class$5 = function (_DefaultShaper) {
        _inherits(HangulShaper, _DefaultShaper);
        function HangulShaper() {
            _classCallCheck(this, HangulShaper);
            return _possibleConstructorReturn(this, _DefaultShaper.apply(this, arguments));
        }
        HangulShaper.planFeatures = function planFeatures(plan) {
            plan.add([
                'ljmo',
                'vjmo',
                'tjmo'
            ], false);
        };
        HangulShaper.assignFeatures = function assignFeatures(plan, glyphs) {
            var state = 0;
            var i = 0;
            while (i < glyphs.length) {
                var action = void 0;
                var glyph = glyphs[i];
                var code = glyph.codePoints[0];
                var type = getType(code);
                var _STATE_TABLE$state$ty = STATE_TABLE$1[state][type];
                action = _STATE_TABLE$state$ty[0];
                state = _STATE_TABLE$state$ty[1];
                switch (action) {
                case DECOMPOSE:
                    if (!plan.font.hasGlyphForCodePoint(code)) {
                        i = decompose(glyphs, i, plan.font);
                    }
                    break;
                case COMPOSE:
                    i = compose(glyphs, i, plan.font);
                    break;
                case TONE_MARK:
                    reorderToneMark(glyphs, i, plan.font);
                    break;
                case INVALID:
                    i = insertDottedCircle(glyphs, i, plan.font);
                    break;
                }
                i++;
            }
        };
        return HangulShaper;
    }(DefaultShaper), _class$5.zeroMarkWidths = 'NONE', _temp$1);
var HANGUL_BASE = 44032;
var HANGUL_END = 55204;
var HANGUL_COUNT = HANGUL_END - HANGUL_BASE + 1;
var L_BASE = 4352;
var V_BASE = 4449;
var T_BASE = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var L_END = L_BASE + L_COUNT - 1;
var V_END = V_BASE + V_COUNT - 1;
var T_END = T_BASE + T_COUNT - 1;
var DOTTED_CIRCLE = 9676;
var isL = function isL(code) {
    return 4352 <= code && code <= 4447 || 43360 <= code && code <= 43388;
};
var isV = function isV(code) {
    return 4448 <= code && code <= 4519 || 55216 <= code && code <= 55238;
};
var isT = function isT(code) {
    return 4520 <= code && code <= 4607 || 55243 <= code && code <= 55291;
};
var isTone = function isTone(code) {
    return 12334 <= code && code <= 12335;
};
var isLVT = function isLVT(code) {
    return HANGUL_BASE <= code && code <= HANGUL_END;
};
var isLV = function isLV(code) {
    return code - HANGUL_BASE < HANGUL_COUNT && (code - HANGUL_BASE) % T_COUNT === 0;
};
var isCombiningL = function isCombiningL(code) {
    return L_BASE <= code && code <= L_END;
};
var isCombiningV = function isCombiningV(code) {
    return V_BASE <= code && code <= V_END;
};
var isCombiningT = function isCombiningT(code) {
    return T_BASE + 1 && 1 <= code && code <= T_END;
};
var X = 0;
var L = 1;
var V = 2;
var T = 3;
var LV = 4;
var LVT = 5;
var M = 6;
function getType(code) {
    if (isL(code)) {
        return L;
    }
    if (isV(code)) {
        return V;
    }
    if (isT(code)) {
        return T;
    }
    if (isLV(code)) {
        return LV;
    }
    if (isLVT(code)) {
        return LVT;
    }
    if (isTone(code)) {
        return M;
    }
    return X;
}
var NO_ACTION = 0;
var DECOMPOSE = 1;
var COMPOSE = 2;
var TONE_MARK = 4;
var INVALID = 5;
var STATE_TABLE$1 = [
        [
            [
                NO_ACTION,
                0
            ],
            [
                NO_ACTION,
                1
            ],
            [
                NO_ACTION,
                0
            ],
            [
                NO_ACTION,
                0
            ],
            [
                DECOMPOSE,
                2
            ],
            [
                DECOMPOSE,
                3
            ],
            [
                INVALID,
                0
            ]
        ],
        [
            [
                NO_ACTION,
                0
            ],
            [
                NO_ACTION,
                1
            ],
            [
                COMPOSE,
                2
            ],
            [
                NO_ACTION,
                0
            ],
            [
                DECOMPOSE,
                2
            ],
            [
                DECOMPOSE,
                3
            ],
            [
                INVALID,
                0
            ]
        ],
        [
            [
                NO_ACTION,
                0
            ],
            [
                NO_ACTION,
                1
            ],
            [
                NO_ACTION,
                0
            ],
            [
                COMPOSE,
                3
            ],
            [
                DECOMPOSE,
                2
            ],
            [
                DECOMPOSE,
                3
            ],
            [
                TONE_MARK,
                0
            ]
        ],
        [
            [
                NO_ACTION,
                0
            ],
            [
                NO_ACTION,
                1
            ],
            [
                NO_ACTION,
                0
            ],
            [
                NO_ACTION,
                0
            ],
            [
                DECOMPOSE,
                2
            ],
            [
                DECOMPOSE,
                3
            ],
            [
                TONE_MARK,
                0
            ]
        ]
    ];
function getGlyph(font, code, features) {
    return new GlyphInfo(font, font.glyphForCodePoint(code).id, [code], features);
}
function decompose(glyphs, i, font) {
    var glyph = glyphs[i];
    var code = glyph.codePoints[0];
    var s = code - HANGUL_BASE;
    var t = T_BASE + s % T_COUNT;
    s = s / T_COUNT | 0;
    var l = L_BASE + s / V_COUNT | 0;
    var v = V_BASE + s % V_COUNT;
    if (!font.hasGlyphForCodePoint(l) || !font.hasGlyphForCodePoint(v) || t !== T_BASE && !font.hasGlyphForCodePoint(t)) {
        return i;
    }
    var ljmo = getGlyph(font, l, glyph.features);
    ljmo.features.ljmo = true;
    var vjmo = getGlyph(font, v, glyph.features);
    vjmo.features.vjmo = true;
    var insert = [
            ljmo,
            vjmo
        ];
    if (t > T_BASE) {
        var tjmo = getGlyph(font, t, glyph.features);
        tjmo.features.tjmo = true;
        insert.push(tjmo);
    }
    glyphs.splice.apply(glyphs, [
        i,
        1
    ].concat(insert));
    return i + insert.length - 1;
}
function compose(glyphs, i, font) {
    var glyph = glyphs[i];
    var code = glyphs[i].codePoints[0];
    var type = getType(code);
    var prev = glyphs[i - 1].codePoints[0];
    var prevType = getType(prev);
    var lv = void 0, ljmo = void 0, vjmo = void 0, tjmo = void 0;
    if (prevType === LV && type === T) {
        lv = prev;
        tjmo = glyph;
    } else {
        if (type === V) {
            ljmo = glyphs[i - 1];
            vjmo = glyph;
        } else {
            ljmo = glyphs[i - 2];
            vjmo = glyphs[i - 1];
            tjmo = glyph;
        }
        var l = ljmo.codePoints[0];
        var v = vjmo.codePoints[0];
        if (isCombiningL(l) && isCombiningV(v)) {
            lv = HANGUL_BASE + ((l - L_BASE) * V_COUNT + (v - V_BASE)) * T_COUNT;
        }
    }
    var t = tjmo && tjmo.codePoints[0] || T_BASE;
    if (lv != null && (t === T_BASE || isCombiningT(t))) {
        var s = lv + (t - T_BASE);
        if (font.hasGlyphForCodePoint(s)) {
            var del = prevType === V ? 3 : 2;
            glyphs.splice(i - del + 1, del, getGlyph(font, s, glyph.features));
            return i - del + 1;
        }
    }
    if (ljmo) {
        ljmo.features.ljmo = true;
    }
    if (vjmo) {
        vjmo.features.vjmo = true;
    }
    if (tjmo) {
        tjmo.features.tjmo = true;
    }
    if (prevType === LV) {
        decompose(glyphs, i - 1, font);
        return i + 1;
    }
    return i;
}
function getLength(code) {
    switch (getType(code)) {
    case LV:
    case LVT:
        return 1;
    case V:
        return 2;
    case T:
        return 3;
    }
}
function reorderToneMark(glyphs, i, font) {
    var glyph = glyphs[i];
    var code = glyphs[i].codePoints[0];
    if (font.glyphForCodePoint(code).advanceWidth === 0) {
        return;
    }
    var prev = glyphs[i - 1].codePoints[0];
    var len = getLength(prev);
    glyphs.splice(i, 1);
    return glyphs.splice(i - len, 0, glyph);
}
function insertDottedCircle(glyphs, i, font) {
    var glyph = glyphs[i];
    var code = glyphs[i].codePoints[0];
    if (font.hasGlyphForCodePoint(DOTTED_CIRCLE)) {
        var dottedCircle = getGlyph(font, DOTTED_CIRCLE, glyph.features);
        var idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;
        glyphs.splice(idx, 0, dottedCircle);
        i++;
    }
    return i;
}
var stateTable = [
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            0,
            10,
            11,
            11,
            12,
            13,
            14,
            15,
            16,
            17
        ],
        [
            0,
            0,
            0,
            18,
            19,
            20,
            21,
            22,
            23,
            0,
            24,
            0,
            0,
            25,
            26,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            28,
            29,
            30,
            31,
            32,
            33,
            0,
            34,
            0,
            0,
            35,
            36,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            38,
            5,
            7,
            7,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            13,
            0,
            0,
            16,
            0
        ],
        [
            0,
            39,
            0,
            0,
            0,
            40,
            41,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            39,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            43,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            12,
            43,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            43,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            0,
            43,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            45,
            46,
            47,
            48,
            49,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            50,
            0,
            0,
            51,
            0,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            52,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            53,
            54,
            55,
            56,
            57,
            58,
            0,
            59,
            0,
            0,
            60,
            61,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            4,
            5,
            7,
            7,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            13,
            0,
            0,
            16,
            0
        ],
        [
            0,
            63,
            64,
            0,
            0,
            40,
            41,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            63,
            0,
            0
        ],
        [
            0,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            0,
            10,
            11,
            11,
            12,
            13,
            0,
            2,
            16,
            0
        ],
        [
            0,
            0,
            0,
            18,
            65,
            20,
            21,
            22,
            23,
            0,
            24,
            0,
            0,
            25,
            26,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            66,
            67,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            68,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            69,
            0,
            70,
            70,
            0,
            71,
            0,
            72,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            73,
            19,
            74,
            74,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            26,
            0,
            0,
            27,
            0
        ],
        [
            0,
            75,
            0,
            0,
            0,
            76,
            77,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            75,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            79,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            25,
            79,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            18,
            19,
            20,
            74,
            22,
            23,
            0,
            24,
            0,
            0,
            25,
            26,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            81,
            82,
            83,
            84,
            85,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            86,
            0,
            0,
            87,
            0,
            24,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            88,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            18,
            19,
            74,
            74,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            26,
            0,
            0,
            27,
            0
        ],
        [
            0,
            89,
            90,
            0,
            0,
            76,
            77,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            89,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            91,
            92,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            93,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            94,
            29,
            95,
            31,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            36,
            0,
            0,
            37,
            0
        ],
        [
            0,
            96,
            0,
            0,
            0,
            97,
            98,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            96,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            100,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            35,
            100,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            100,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            100,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            102,
            103,
            104,
            105,
            106,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            107,
            0,
            0,
            108,
            0,
            34,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            109,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            28,
            29,
            95,
            31,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            36,
            0,
            0,
            37,
            0
        ],
        [
            0,
            110,
            111,
            0,
            0,
            97,
            98,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            110,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            112,
            113,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            114,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            5,
            7,
            7,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            13,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            115,
            116,
            117,
            118,
            8,
            9,
            0,
            10,
            0,
            0,
            119,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            39,
            0,
            122,
            0,
            123,
            123,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            39,
            0,
            0
        ],
        [
            0,
            124,
            64,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            124,
            0,
            0
        ],
        [
            0,
            39,
            0,
            0,
            0,
            121,
            125,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            39,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            126,
            126,
            8,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            46,
            47,
            48,
            49,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            47,
            47,
            49,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            127,
            127,
            49,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            128,
            127,
            127,
            49,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            129,
            130,
            131,
            132,
            133,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            50,
            0,
            0,
            0,
            0,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            134,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            135,
            54,
            56,
            56,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            61,
            0,
            0,
            62,
            0
        ],
        [
            0,
            136,
            0,
            0,
            0,
            137,
            138,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            136,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            140,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            60,
            140,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            140,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            0,
            140,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            142,
            143,
            144,
            145,
            146,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            147,
            0,
            0,
            148,
            0,
            59,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            149,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            53,
            54,
            56,
            56,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            61,
            0,
            0,
            62,
            0
        ],
        [
            0,
            150,
            151,
            0,
            0,
            137,
            138,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            150,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            152,
            153,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            154,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            155,
            116,
            156,
            157,
            8,
            9,
            0,
            10,
            0,
            0,
            158,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            75,
            3,
            4,
            5,
            159,
            160,
            8,
            161,
            0,
            162,
            0,
            11,
            12,
            163,
            0,
            75,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            40,
            164,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            165,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            0,
            165,
            0,
            0,
            0,
            0
        ],
        [
            0,
            124,
            64,
            0,
            0,
            40,
            164,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            124,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            70,
            70,
            0,
            71,
            0,
            72,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            71,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            166,
            0,
            0,
            167,
            0,
            72,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            168,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            19,
            74,
            74,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            26,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            79,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            0,
            79,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            169,
            170,
            171,
            172,
            22,
            23,
            0,
            24,
            0,
            0,
            173,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            75,
            0,
            176,
            0,
            177,
            177,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            75,
            0,
            0
        ],
        [
            0,
            178,
            90,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            178,
            0,
            0
        ],
        [
            0,
            75,
            0,
            0,
            0,
            175,
            179,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            75,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            180,
            180,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            82,
            83,
            84,
            85,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            83,
            83,
            85,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            181,
            181,
            85,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            182,
            181,
            181,
            85,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            183,
            184,
            185,
            186,
            187,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            24,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            86,
            0,
            0,
            0,
            0,
            24,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            188,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            189,
            170,
            190,
            191,
            22,
            23,
            0,
            24,
            0,
            0,
            192,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            76,
            193,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            194,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            0,
            194,
            0,
            0,
            0,
            0
        ],
        [
            0,
            178,
            90,
            0,
            0,
            76,
            193,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            178,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            29,
            95,
            31,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            36,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            100,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            100,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            195,
            196,
            197,
            198,
            32,
            33,
            0,
            34,
            0,
            0,
            199,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            96,
            0,
            202,
            0,
            203,
            203,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            96,
            0,
            0
        ],
        [
            0,
            204,
            111,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            204,
            0,
            0
        ],
        [
            0,
            96,
            0,
            0,
            0,
            201,
            205,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            96,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            206,
            206,
            32,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            103,
            104,
            105,
            106,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            104,
            104,
            106,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            207,
            207,
            106,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            208,
            207,
            207,
            106,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            209,
            210,
            211,
            212,
            213,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            34,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            107,
            0,
            0,
            0,
            0,
            34,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            214,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            215,
            196,
            216,
            217,
            32,
            33,
            0,
            34,
            0,
            0,
            218,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            97,
            219,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            220,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            220,
            0,
            0,
            0,
            0
        ],
        [
            0,
            204,
            111,
            0,
            0,
            97,
            219,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            204,
            0,
            0
        ],
        [
            0,
            0,
            0,
            221,
            116,
            222,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            223,
            0,
            0,
            0,
            40,
            224,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            223,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            225,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            119,
            225,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            115,
            116,
            117,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            119,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            115,
            116,
            222,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            226,
            64,
            0,
            0,
            40,
            224,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            226,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            39,
            0,
            0,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            39,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            227,
            0,
            228,
            229,
            0,
            9,
            0,
            10,
            0,
            0,
            230,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            39,
            0,
            122,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            39,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            8,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            231,
            231,
            49,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            232,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            130,
            131,
            132,
            133,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            131,
            131,
            133,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            233,
            233,
            133,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            234,
            233,
            233,
            133,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            235,
            236,
            237,
            238,
            239,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            54,
            56,
            56,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            61,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            240,
            241,
            242,
            243,
            57,
            58,
            0,
            59,
            0,
            0,
            244,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            136,
            0,
            247,
            0,
            248,
            248,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            136,
            0,
            0
        ],
        [
            0,
            249,
            151,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            249,
            0,
            0
        ],
        [
            0,
            136,
            0,
            0,
            0,
            246,
            250,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            136,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            251,
            251,
            57,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            143,
            144,
            145,
            146,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            144,
            144,
            146,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            252,
            252,
            146,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            253,
            252,
            252,
            146,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            254,
            255,
            256,
            257,
            258,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            59,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            147,
            0,
            0,
            0,
            0,
            59,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            259,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            260,
            241,
            261,
            262,
            57,
            58,
            0,
            59,
            0,
            0,
            263,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            137,
            264,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            265,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            0,
            265,
            0,
            0,
            0,
            0
        ],
        [
            0,
            249,
            151,
            0,
            0,
            137,
            264,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            249,
            0,
            0
        ],
        [
            0,
            0,
            0,
            221,
            116,
            222,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            225,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            158,
            225,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            155,
            116,
            156,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            158,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            155,
            116,
            222,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            43,
            266,
            266,
            8,
            161,
            0,
            24,
            0,
            0,
            12,
            267,
            0,
            0,
            0,
            0
        ],
        [
            0,
            75,
            0,
            176,
            43,
            268,
            268,
            269,
            161,
            0,
            24,
            0,
            0,
            0,
            267,
            0,
            75,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            270,
            0,
            0,
            271,
            0,
            162,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            272,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            273,
            274,
            0,
            0,
            40,
            41,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            273,
            0,
            0
        ],
        [
            0,
            0,
            0,
            40,
            0,
            123,
            123,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            121,
            275,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            72,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            166,
            0,
            0,
            0,
            0,
            72,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            276,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            277,
            170,
            278,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            279,
            0,
            0,
            0,
            76,
            280,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            279,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            281,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            173,
            281,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            169,
            170,
            171,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            173,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            169,
            170,
            278,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            282,
            90,
            0,
            0,
            76,
            280,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            282,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            75,
            0,
            0,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            75,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            283,
            0,
            284,
            285,
            0,
            23,
            0,
            24,
            0,
            0,
            286,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            75,
            0,
            176,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            75,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            287,
            287,
            85,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            288,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            184,
            185,
            186,
            187,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            185,
            185,
            187,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            289,
            289,
            187,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            290,
            289,
            289,
            187,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            291,
            292,
            293,
            294,
            295,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            277,
            170,
            278,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            281,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            192,
            281,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            189,
            170,
            190,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            192,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            189,
            170,
            278,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            76,
            0,
            177,
            177,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            175,
            296,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            297,
            196,
            298,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            299,
            0,
            0,
            0,
            97,
            300,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            299,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            301,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            199,
            301,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            195,
            196,
            197,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            199,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            195,
            196,
            298,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            302,
            111,
            0,
            0,
            97,
            300,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            302,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            96,
            0,
            0,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            96,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            303,
            0,
            304,
            305,
            0,
            33,
            0,
            34,
            0,
            0,
            306,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            96,
            0,
            202,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            96,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            32,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            307,
            307,
            106,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            308,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            210,
            211,
            212,
            213,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            211,
            211,
            213,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            309,
            309,
            213,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            310,
            309,
            309,
            213,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            311,
            312,
            313,
            314,
            315,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            297,
            196,
            298,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            301,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            218,
            301,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            215,
            196,
            216,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            218,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            215,
            196,
            298,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            97,
            0,
            203,
            203,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            201,
            316,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            116,
            222,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            225,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            0,
            225,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            317,
            318,
            319,
            320,
            8,
            9,
            0,
            10,
            0,
            0,
            321,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            223,
            0,
            323,
            0,
            123,
            123,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            223,
            0,
            0
        ],
        [
            0,
            223,
            0,
            0,
            0,
            121,
            324,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            223,
            0,
            0
        ],
        [
            0,
            0,
            0,
            325,
            318,
            326,
            327,
            8,
            9,
            0,
            10,
            0,
            0,
            328,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            64,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            9,
            0,
            0,
            0,
            0,
            230,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            227,
            0,
            228,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            230,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            227,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            49,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            46,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            329,
            329,
            133,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            330,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            236,
            237,
            238,
            239,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            237,
            237,
            239,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            331,
            331,
            239,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            332,
            331,
            331,
            239,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            333,
            40,
            121,
            334,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            335,
            241,
            336,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            337,
            0,
            0,
            0,
            137,
            338,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            337,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            339,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            244,
            339,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            240,
            241,
            242,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            244,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            240,
            241,
            336,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            340,
            151,
            0,
            0,
            137,
            338,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            340,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            136,
            0,
            0,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            136,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            341,
            0,
            342,
            343,
            0,
            58,
            0,
            59,
            0,
            0,
            344,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            136,
            0,
            247,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            136,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            57,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            345,
            345,
            146,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            346,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            255,
            256,
            257,
            258,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            256,
            256,
            258,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            347,
            347,
            258,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            348,
            347,
            347,
            258,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            349,
            350,
            351,
            352,
            353,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            335,
            241,
            336,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            339,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            263,
            339,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            260,
            241,
            261,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            263,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            260,
            241,
            336,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            137,
            0,
            248,
            248,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            246,
            354,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            126,
            126,
            8,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            355,
            90,
            0,
            0,
            121,
            125,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            355,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            356,
            356,
            269,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            357,
            358,
            359,
            360,
            361,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            162,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            270,
            0,
            0,
            0,
            0,
            162,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            363,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            364,
            116,
            365,
            366,
            8,
            161,
            0,
            162,
            0,
            0,
            367,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            368,
            368,
            0,
            161,
            0,
            162,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            40,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            170,
            278,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            281,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            0,
            281,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            369,
            370,
            371,
            372,
            22,
            23,
            0,
            24,
            0,
            0,
            373,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            279,
            0,
            375,
            0,
            177,
            177,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            279,
            0,
            0
        ],
        [
            0,
            279,
            0,
            0,
            0,
            175,
            376,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            279,
            0,
            0
        ],
        [
            0,
            0,
            0,
            377,
            370,
            378,
            379,
            22,
            23,
            0,
            24,
            0,
            0,
            380,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            90,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            286,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            283,
            0,
            284,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            286,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            283,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            85,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            82,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            381,
            381,
            187,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            382,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            292,
            293,
            294,
            295,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            293,
            293,
            295,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            383,
            383,
            295,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            384,
            383,
            383,
            295,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            385,
            76,
            175,
            386,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            76,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            196,
            298,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            301,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            301,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            387,
            388,
            389,
            390,
            32,
            33,
            0,
            34,
            0,
            0,
            391,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            299,
            0,
            393,
            0,
            203,
            203,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            299,
            0,
            0
        ],
        [
            0,
            299,
            0,
            0,
            0,
            201,
            394,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            299,
            0,
            0
        ],
        [
            0,
            0,
            0,
            395,
            388,
            396,
            397,
            32,
            33,
            0,
            34,
            0,
            0,
            398,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            111,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            33,
            0,
            0,
            0,
            0,
            306,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            303,
            0,
            304,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            306,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            303,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            106,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            103,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            399,
            399,
            213,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            400,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            312,
            313,
            314,
            315,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            313,
            313,
            315,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            401,
            401,
            315,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            402,
            401,
            401,
            315,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            403,
            97,
            201,
            404,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            97,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            405,
            318,
            406,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            407,
            0,
            0,
            0,
            40,
            408,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            407,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            409,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            321,
            409,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            317,
            318,
            319,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            321,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            317,
            318,
            406,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            410,
            64,
            0,
            0,
            40,
            408,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            410,
            0,
            0
        ],
        [
            0,
            223,
            0,
            0,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            223,
            0,
            0
        ],
        [
            0,
            223,
            0,
            323,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            223,
            0,
            0
        ],
        [
            0,
            0,
            0,
            405,
            318,
            406,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            409,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            328,
            409,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            325,
            318,
            326,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            328,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            325,
            318,
            406,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            133,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            130,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            411,
            411,
            239,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            412,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            40,
            121,
            334,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            413,
            0,
            0,
            0,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            241,
            336,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            339,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            0,
            339,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            414,
            415,
            416,
            417,
            57,
            58,
            0,
            59,
            0,
            0,
            418,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            337,
            0,
            420,
            0,
            248,
            248,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            337,
            0,
            0
        ],
        [
            0,
            337,
            0,
            0,
            0,
            246,
            421,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            337,
            0,
            0
        ],
        [
            0,
            0,
            0,
            422,
            415,
            423,
            424,
            57,
            58,
            0,
            59,
            0,
            0,
            425,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            151,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            58,
            0,
            0,
            0,
            0,
            344,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            341,
            0,
            342,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            344,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            341,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            146,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            143,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            426,
            426,
            258,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            427,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            350,
            351,
            352,
            353,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            351,
            351,
            353,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            428,
            428,
            353,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            429,
            428,
            428,
            353,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            430,
            137,
            246,
            431,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            137,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            432,
            116,
            433,
            434,
            8,
            161,
            0,
            162,
            0,
            0,
            435,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            180,
            180,
            269,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            358,
            359,
            360,
            361,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            359,
            359,
            361,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            436,
            436,
            361,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            437,
            436,
            436,
            361,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            438,
            439,
            440,
            441,
            442,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            443,
            274,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            443,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            444,
            116,
            445,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            225,
            44,
            44,
            8,
            161,
            0,
            0,
            0,
            0,
            367,
            225,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            364,
            116,
            365,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            367,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            364,
            116,
            445,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            446,
            370,
            447,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            448,
            0,
            0,
            0,
            76,
            449,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            448,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            450,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            373,
            450,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            369,
            370,
            371,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            373,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            369,
            370,
            447,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            451,
            90,
            0,
            0,
            76,
            449,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            451,
            0,
            0
        ],
        [
            0,
            279,
            0,
            0,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            279,
            0,
            0
        ],
        [
            0,
            279,
            0,
            375,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            279,
            0,
            0
        ],
        [
            0,
            0,
            0,
            446,
            370,
            447,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            450,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            380,
            450,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            377,
            370,
            378,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            380,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            377,
            370,
            447,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            187,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            184,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            452,
            452,
            295,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            453,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            76,
            175,
            386,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            454,
            0,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            455,
            388,
            456,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            457,
            0,
            0,
            0,
            97,
            458,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            457,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            459,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            391,
            459,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            387,
            388,
            389,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            391,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            387,
            388,
            456,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            460,
            111,
            0,
            0,
            97,
            458,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            460,
            0,
            0
        ],
        [
            0,
            299,
            0,
            0,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            299,
            0,
            0
        ],
        [
            0,
            299,
            0,
            393,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            299,
            0,
            0
        ],
        [
            0,
            0,
            0,
            455,
            388,
            456,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            459,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            398,
            459,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            395,
            388,
            396,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            398,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            395,
            388,
            456,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            213,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            210,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            461,
            461,
            315,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            462,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            97,
            201,
            404,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            463,
            0,
            0,
            0,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            318,
            406,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            409,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            0,
            409,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            464,
            465,
            466,
            467,
            8,
            9,
            0,
            10,
            0,
            0,
            468,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            407,
            0,
            470,
            0,
            123,
            123,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            407,
            0,
            0
        ],
        [
            0,
            407,
            0,
            0,
            0,
            121,
            471,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            407,
            0,
            0
        ],
        [
            0,
            0,
            0,
            472,
            465,
            473,
            474,
            8,
            9,
            0,
            10,
            0,
            0,
            475,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            239,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            236,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            476,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            477,
            415,
            478,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            479,
            0,
            0,
            0,
            137,
            480,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            479,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            481,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            418,
            481,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            414,
            415,
            416,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            418,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            414,
            415,
            478,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            482,
            151,
            0,
            0,
            137,
            480,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            482,
            0,
            0
        ],
        [
            0,
            337,
            0,
            0,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            337,
            0,
            0
        ],
        [
            0,
            337,
            0,
            420,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            337,
            0,
            0
        ],
        [
            0,
            0,
            0,
            477,
            415,
            478,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            481,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            425,
            481,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            422,
            415,
            423,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            425,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            422,
            415,
            478,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            258,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            255,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            483,
            483,
            353,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            484,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            137,
            246,
            431,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            485,
            0,
            0,
            0,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            444,
            116,
            445,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            225,
            44,
            44,
            8,
            161,
            0,
            0,
            0,
            0,
            435,
            225,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            432,
            116,
            433,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            435,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            432,
            116,
            445,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            486,
            486,
            361,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            487,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            439,
            440,
            441,
            442,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            440,
            440,
            442,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            488,
            488,
            442,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            489,
            488,
            488,
            442,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            490,
            491,
            492,
            493,
            494,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            495,
            0,
            496,
            497,
            0,
            161,
            0,
            162,
            0,
            0,
            498,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            116,
            445,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            225,
            44,
            44,
            8,
            161,
            0,
            0,
            0,
            0,
            0,
            225,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            370,
            447,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            450,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            0,
            450,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            499,
            500,
            501,
            502,
            22,
            23,
            0,
            24,
            0,
            0,
            503,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            448,
            0,
            505,
            0,
            177,
            177,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            448,
            0,
            0
        ],
        [
            0,
            448,
            0,
            0,
            0,
            175,
            506,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            448,
            0,
            0
        ],
        [
            0,
            0,
            0,
            507,
            500,
            508,
            509,
            22,
            23,
            0,
            24,
            0,
            0,
            510,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            295,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            292,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            511,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            388,
            456,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            459,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            459,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            512,
            513,
            514,
            515,
            32,
            33,
            0,
            34,
            0,
            0,
            516,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            457,
            0,
            518,
            0,
            203,
            203,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            457,
            0,
            0
        ],
        [
            0,
            457,
            0,
            0,
            0,
            201,
            519,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            457,
            0,
            0
        ],
        [
            0,
            0,
            0,
            520,
            513,
            521,
            522,
            32,
            33,
            0,
            34,
            0,
            0,
            523,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            315,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            312,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            524,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            525,
            465,
            526,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            527,
            0,
            0,
            0,
            40,
            528,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            527,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            529,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            468,
            529,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            464,
            465,
            466,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            468,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            464,
            465,
            526,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            530,
            64,
            0,
            0,
            40,
            528,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            530,
            0,
            0
        ],
        [
            0,
            407,
            0,
            0,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            407,
            0,
            0
        ],
        [
            0,
            407,
            0,
            470,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            407,
            0,
            0
        ],
        [
            0,
            0,
            0,
            525,
            465,
            526,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            529,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            475,
            529,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            472,
            465,
            473,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            475,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            472,
            465,
            526,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            40,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            415,
            478,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            481,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            0,
            481,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            531,
            532,
            533,
            534,
            57,
            58,
            0,
            59,
            0,
            0,
            535,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            479,
            0,
            537,
            0,
            248,
            248,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            479,
            0,
            0
        ],
        [
            0,
            479,
            0,
            0,
            0,
            246,
            538,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            479,
            0,
            0
        ],
        [
            0,
            0,
            0,
            539,
            532,
            540,
            541,
            57,
            58,
            0,
            59,
            0,
            0,
            542,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            353,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            350,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            543,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            361,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            358,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            544,
            544,
            442,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            545,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            491,
            492,
            493,
            494,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            492,
            492,
            494,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            546,
            546,
            494,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            547,
            546,
            546,
            494,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            548,
            549,
            368,
            550,
            0,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            274,
            0,
            368,
            368,
            0,
            161,
            0,
            162,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            161,
            0,
            0,
            0,
            0,
            498,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            495,
            0,
            496,
            368,
            0,
            161,
            0,
            162,
            0,
            0,
            498,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            495,
            0,
            368,
            368,
            0,
            161,
            0,
            162,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            551,
            500,
            552,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            553,
            0,
            0,
            0,
            76,
            554,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            553,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            555,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            503,
            555,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            499,
            500,
            501,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            503,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            499,
            500,
            552,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            556,
            90,
            0,
            0,
            76,
            554,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            556,
            0,
            0
        ],
        [
            0,
            448,
            0,
            0,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            448,
            0,
            0
        ],
        [
            0,
            448,
            0,
            505,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            448,
            0,
            0
        ],
        [
            0,
            0,
            0,
            551,
            500,
            552,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            555,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            510,
            555,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            507,
            500,
            508,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            510,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            507,
            500,
            552,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            76,
            0,
            0
        ],
        [
            0,
            0,
            0,
            557,
            513,
            558,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            559,
            0,
            0,
            0,
            97,
            560,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            559,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            561,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            516,
            561,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            512,
            513,
            514,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            516,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            512,
            513,
            558,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            562,
            111,
            0,
            0,
            97,
            560,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            562,
            0,
            0
        ],
        [
            0,
            457,
            0,
            0,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            457,
            0,
            0
        ],
        [
            0,
            457,
            0,
            518,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            457,
            0,
            0
        ],
        [
            0,
            0,
            0,
            557,
            513,
            558,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            561,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            523,
            561,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            520,
            513,
            521,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            523,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            520,
            513,
            558,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            97,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            465,
            526,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            529,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            0,
            529,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            563,
            66,
            564,
            565,
            8,
            9,
            0,
            10,
            0,
            0,
            566,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            527,
            0,
            567,
            0,
            123,
            123,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            527,
            0,
            0
        ],
        [
            0,
            527,
            0,
            0,
            0,
            121,
            568,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            527,
            0,
            0
        ],
        [
            0,
            0,
            0,
            569,
            66,
            570,
            571,
            8,
            9,
            0,
            10,
            0,
            0,
            572,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            573,
            532,
            574,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            575,
            0,
            0,
            0,
            137,
            576,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            575,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            577,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            535,
            577,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            531,
            532,
            533,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            535,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            531,
            532,
            574,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            578,
            151,
            0,
            0,
            137,
            576,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            578,
            0,
            0
        ],
        [
            0,
            479,
            0,
            0,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            479,
            0,
            0
        ],
        [
            0,
            479,
            0,
            537,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            479,
            0,
            0
        ],
        [
            0,
            0,
            0,
            573,
            532,
            574,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            577,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            542,
            577,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            539,
            532,
            540,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            542,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            539,
            532,
            574,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            137,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            442,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            439,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            579,
            579,
            494,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            580,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            549,
            368,
            550,
            0,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            368,
            368,
            0,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            581,
            0,
            0,
            0,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            500,
            552,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            555,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            0,
            555,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            582,
            91,
            583,
            584,
            22,
            23,
            0,
            24,
            0,
            0,
            585,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            553,
            0,
            586,
            0,
            177,
            177,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            553,
            0,
            0
        ],
        [
            0,
            553,
            0,
            0,
            0,
            175,
            587,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            553,
            0,
            0
        ],
        [
            0,
            0,
            0,
            588,
            91,
            589,
            590,
            22,
            23,
            0,
            24,
            0,
            0,
            591,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            513,
            558,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            561,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            561,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            592,
            112,
            593,
            594,
            32,
            33,
            0,
            34,
            0,
            0,
            595,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            559,
            0,
            596,
            0,
            203,
            203,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            559,
            0,
            0
        ],
        [
            0,
            559,
            0,
            0,
            0,
            201,
            597,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            559,
            0,
            0
        ],
        [
            0,
            0,
            0,
            598,
            112,
            599,
            600,
            32,
            33,
            0,
            34,
            0,
            0,
            601,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            602,
            66,
            67,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            165,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            566,
            165,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            563,
            66,
            564,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            566,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            563,
            66,
            67,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            527,
            0,
            0,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            527,
            0,
            0
        ],
        [
            0,
            527,
            0,
            567,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            527,
            0,
            0
        ],
        [
            0,
            0,
            0,
            602,
            66,
            67,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            165,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            572,
            165,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            569,
            66,
            570,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            572,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            569,
            66,
            67,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            532,
            574,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            577,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            0,
            577,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            603,
            152,
            604,
            605,
            57,
            58,
            0,
            59,
            0,
            0,
            606,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            575,
            0,
            607,
            0,
            248,
            248,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            575,
            0,
            0
        ],
        [
            0,
            575,
            0,
            0,
            0,
            246,
            608,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            575,
            0,
            0
        ],
        [
            0,
            0,
            0,
            609,
            152,
            610,
            611,
            57,
            58,
            0,
            59,
            0,
            0,
            612,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            494,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            491,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            613,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            614,
            91,
            92,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            194,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            585,
            194,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            582,
            91,
            583,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            585,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            582,
            91,
            92,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            553,
            0,
            0,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            553,
            0,
            0
        ],
        [
            0,
            553,
            0,
            586,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            553,
            0,
            0
        ],
        [
            0,
            0,
            0,
            614,
            91,
            92,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            194,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            591,
            194,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            588,
            91,
            589,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            591,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            588,
            91,
            92,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            615,
            112,
            113,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            220,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            595,
            220,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            592,
            112,
            593,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            595,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            592,
            112,
            113,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            559,
            0,
            0,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            559,
            0,
            0
        ],
        [
            0,
            559,
            0,
            596,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            559,
            0,
            0
        ],
        [
            0,
            0,
            0,
            615,
            112,
            113,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            220,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            601,
            220,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            598,
            112,
            599,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            601,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            598,
            112,
            113,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            66,
            67,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            616,
            152,
            153,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            265,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            606,
            265,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            603,
            152,
            604,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            606,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            603,
            152,
            153,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            575,
            0,
            0,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            575,
            0,
            0
        ],
        [
            0,
            575,
            0,
            607,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            575,
            0,
            0
        ],
        [
            0,
            0,
            0,
            616,
            152,
            153,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            265,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            612,
            265,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            609,
            152,
            610,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            612,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            609,
            152,
            153,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            549,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            91,
            92,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            112,
            113,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            152,
            153,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            154,
            0,
            0,
            62,
            0
        ]
    ];
var accepting = [
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        false,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        false,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        false,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        false,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        false,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true
    ];
var tags = [
        [],
        ['broken_cluster'],
        ['consonant_syllable'],
        ['vowel_syllable'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['standalone_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['consonant_syllable'],
        ['broken_cluster'],
        ['symbol_cluster'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['symbol_cluster'],
        [],
        ['symbol_cluster'],
        ['symbol_cluster'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['symbol_cluster'],
        ['symbol_cluster'],
        ['symbol_cluster'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        [],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        ['broken_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['broken_cluster'],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        ['broken_cluster'],
        ['symbol_cluster'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        [],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        [],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        [],
        [],
        ['broken_cluster'],
        [],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        [],
        [],
        ['consonant_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        [],
        [],
        ['vowel_syllable'],
        [],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        [],
        [],
        ['standalone_cluster'],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        [],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        [],
        [],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        [],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['broken_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['consonant_syllable'],
        ['vowel_syllable'],
        ['standalone_cluster']
    ];
var indicMachine = {
        stateTable: stateTable,
        accepting: accepting,
        tags: tags
    };
var categories = [
        'O',
        'IND',
        'S',
        'GB',
        'B',
        'FM',
        'CGJ',
        'VMAbv',
        'VMPst',
        'VAbv',
        'VPst',
        'CMBlw',
        'VPre',
        'VBlw',
        'H',
        'VMBlw',
        'CMAbv',
        'MBlw',
        'CS',
        'R',
        'SUB',
        'MPst',
        'MPre',
        'FAbv',
        'FPst',
        'FBlw',
        'SMAbv',
        'SMBlw',
        'VMPre',
        'ZWNJ',
        'ZWJ',
        'WJ',
        'VS',
        'N',
        'HN',
        'MAbv'
    ];
var decompositions$1 = {
        '2507': [
            2503,
            2494
        ],
        '2508': [
            2503,
            2519
        ],
        '2888': [
            2887,
            2902
        ],
        '2891': [
            2887,
            2878
        ],
        '2892': [
            2887,
            2903
        ],
        '3018': [
            3014,
            3006
        ],
        '3019': [
            3015,
            3006
        ],
        '3020': [
            3014,
            3031
        ],
        '3144': [
            3142,
            3158
        ],
        '3264': [
            3263,
            3285
        ],
        '3271': [
            3270,
            3285
        ],
        '3272': [
            3270,
            3286
        ],
        '3274': [
            3270,
            3266
        ],
        '3275': [
            3270,
            3266,
            3285
        ],
        '3402': [
            3398,
            3390
        ],
        '3403': [
            3399,
            3390
        ],
        '3404': [
            3398,
            3415
        ],
        '3546': [
            3545,
            3530
        ],
        '3548': [
            3545,
            3535
        ],
        '3549': [
            3545,
            3535,
            3530
        ],
        '3550': [
            3545,
            3551
        ],
        '3635': [
            3661,
            3634
        ],
        '3763': [
            3789,
            3762
        ],
        '3955': [
            3953,
            3954
        ],
        '3957': [
            3953,
            3956
        ],
        '3958': [
            4018,
            3968
        ],
        '3959': [
            4018,
            3953,
            3968
        ],
        '3960': [
            4019,
            3968
        ],
        '3961': [
            4019,
            3953,
            3968
        ],
        '3969': [
            3953,
            3968
        ],
        '6971': [
            6970,
            6965
        ],
        '6973': [
            6972,
            6965
        ],
        '6976': [
            6974,
            6965
        ],
        '6977': [
            6975,
            6965
        ],
        '6979': [
            6978,
            6965
        ],
        '69934': [
            69937,
            69927
        ],
        '69935': [
            69938,
            69927
        ],
        '70475': [
            70471,
            70462
        ],
        '70476': [
            70471,
            70487
        ],
        '70843': [
            70841,
            70842
        ],
        '70844': [
            70841,
            70832
        ],
        '70846': [
            70841,
            70845
        ],
        '71098': [
            71096,
            71087
        ],
        '71099': [
            71097,
            71087
        ]
    };
var stateTable$1 = [
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            2,
            2,
            3,
            4,
            4,
            5,
            0,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            0,
            17,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            2,
            0,
            24,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            26,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            27,
            28,
            0,
            0,
            0,
            0,
            27,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            0,
            0,
            41,
            35,
            42,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            39,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            0,
            0,
            0,
            0,
            0,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            7,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            0,
            0,
            12,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            0,
            9,
            0,
            0,
            0,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            0,
            16,
            0,
            0,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            0,
            11,
            12,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            0,
            9,
            0,
            0,
            12,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            18,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            7,
            0,
            0,
            0,
            0,
            0,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            0,
            0,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            0,
            11,
            12,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            11,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            4,
            4,
            5,
            0,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            0,
            0,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            48,
            11,
            12,
            13,
            14,
            48,
            16,
            0,
            0,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            49,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            0,
            11,
            12,
            0,
            14,
            0,
            16,
            0,
            0,
            0,
            11,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            21,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            21,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            0,
            0,
            0,
            0,
            0,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            50,
            0,
            51,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            0,
            11,
            12,
            0,
            14,
            0,
            16,
            0,
            0,
            0,
            11,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            27,
            28,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            28,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            0,
            0,
            0,
            0,
            0,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            0,
            31,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            0,
            0,
            36,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            0,
            33,
            0,
            0,
            0,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            0,
            40,
            0,
            0,
            41,
            35,
            42,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            0,
            35,
            36,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            0,
            33,
            0,
            0,
            36,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            41,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            0,
            31,
            0,
            0,
            0,
            0,
            0,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            0,
            0,
            41,
            35,
            42,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            0,
            35,
            36,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            35,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            52,
            35,
            36,
            37,
            38,
            52,
            40,
            0,
            0,
            41,
            35,
            42,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            53,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            0,
            35,
            36,
            0,
            38,
            0,
            40,
            0,
            0,
            0,
            35,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            44,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            44,
            45,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            0,
            0,
            0,
            0,
            0,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            0,
            35,
            36,
            0,
            38,
            0,
            40,
            0,
            0,
            0,
            35,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            48,
            11,
            12,
            13,
            14,
            0,
            16,
            0,
            0,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            48,
            11,
            12,
            13,
            14,
            48,
            16,
            0,
            0,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            51,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            54,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            52,
            35,
            36,
            37,
            38,
            0,
            40,
            0,
            0,
            41,
            35,
            42,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            52,
            35,
            36,
            37,
            38,
            52,
            40,
            0,
            0,
            41,
            35,
            42,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            50,
            0,
            51,
            0
        ]
    ];
var accepting$1 = [
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true
    ];
var tags$1 = [
        [],
        ['broken_cluster'],
        ['independent_cluster'],
        ['symbol_cluster'],
        ['standard_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['numeral_cluster'],
        ['broken_cluster'],
        ['independent_cluster'],
        ['symbol_cluster'],
        ['symbol_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['virama_terminated_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['numeral_cluster'],
        ['number_joiner_terminated_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['numeral_cluster']
    ];
var useData = {
        categories: categories,
        decompositions: decompositions$1,
        stateTable: stateTable$1,
        accepting: accepting$1,
        tags: tags$1
    };
var CATEGORIES = {
        X: 1 << 0,
        C: 1 << 1,
        V: 1 << 2,
        N: 1 << 3,
        H: 1 << 4,
        ZWNJ: 1 << 5,
        ZWJ: 1 << 6,
        M: 1 << 7,
        SM: 1 << 8,
        VD: 1 << 9,
        A: 1 << 10,
        Placeholder: 1 << 11,
        Dotted_Circle: 1 << 12,
        RS: 1 << 13,
        Coeng: 1 << 14,
        Repha: 1 << 15,
        Ra: 1 << 16,
        CM: 1 << 17,
        Symbol: 1 << 18
    };
var POSITIONS = {
        Start: 1 << 0,
        Ra_To_Become_Reph: 1 << 1,
        Pre_M: 1 << 2,
        Pre_C: 1 << 3,
        Base_C: 1 << 4,
        After_Main: 1 << 5,
        Above_C: 1 << 6,
        Before_Sub: 1 << 7,
        Below_C: 1 << 8,
        After_Sub: 1 << 9,
        Before_Post: 1 << 10,
        Post_C: 1 << 11,
        After_Post: 1 << 12,
        Final_C: 1 << 13,
        SMVD: 1 << 14,
        End: 1 << 15
    };
var CONSONANT_FLAGS = CATEGORIES.C | CATEGORIES.Ra | CATEGORIES.CM | CATEGORIES.V | CATEGORIES.Placeholder | CATEGORIES.Dotted_Circle;
var JOINER_FLAGS = CATEGORIES.ZWJ | CATEGORIES.ZWNJ;
var HALANT_OR_COENG_FLAGS = CATEGORIES.H | CATEGORIES.Coeng;
var INDIC_CONFIGS = {
        Default: {
            hasOldSpec: false,
            virama: 0,
            basePos: 'Last',
            rephPos: POSITIONS.Before_Post,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Devanagari: {
            hasOldSpec: true,
            virama: 2381,
            basePos: 'Last',
            rephPos: POSITIONS.Before_Post,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Bengali: {
            hasOldSpec: true,
            virama: 2509,
            basePos: 'Last',
            rephPos: POSITIONS.After_Sub,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Gurmukhi: {
            hasOldSpec: true,
            virama: 2637,
            basePos: 'Last',
            rephPos: POSITIONS.Before_Sub,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Gujarati: {
            hasOldSpec: true,
            virama: 2765,
            basePos: 'Last',
            rephPos: POSITIONS.Before_Post,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Oriya: {
            hasOldSpec: true,
            virama: 2893,
            basePos: 'Last',
            rephPos: POSITIONS.After_Main,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Tamil: {
            hasOldSpec: true,
            virama: 3021,
            basePos: 'Last',
            rephPos: POSITIONS.After_Post,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Telugu: {
            hasOldSpec: true,
            virama: 3149,
            basePos: 'Last',
            rephPos: POSITIONS.After_Post,
            rephMode: 'Explicit',
            blwfMode: 'Post_Only'
        },
        Kannada: {
            hasOldSpec: true,
            virama: 3277,
            basePos: 'Last',
            rephPos: POSITIONS.After_Post,
            rephMode: 'Implicit',
            blwfMode: 'Post_Only'
        },
        Malayalam: {
            hasOldSpec: true,
            virama: 3405,
            basePos: 'Last',
            rephPos: POSITIONS.After_Main,
            rephMode: 'Log_Repha',
            blwfMode: 'Pre_And_Post'
        },
        Khmer: {
            hasOldSpec: false,
            virama: 6098,
            basePos: 'First',
            rephPos: POSITIONS.Ra_To_Become_Reph,
            rephMode: 'Vis_Repha',
            blwfMode: 'Pre_And_Post'
        }
    };
var INDIC_DECOMPOSITIONS = {
        6078: [
            6081,
            6078
        ],
        6079: [
            6081,
            6079
        ],
        6080: [
            6081,
            6080
        ],
        6084: [
            6081,
            6084
        ],
        6085: [
            6081,
            6085
        ]
    };
var _class$6;
var _temp$2;
var decompositions = useData.decompositions;
var trie$1 = new UnicodeTrie(Buffer('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', 'base64'));
var stateMachine = new StateMachine(indicMachine);
var IndicShaper = (_temp$2 = _class$6 = function (_DefaultShaper) {
        _inherits(IndicShaper, _DefaultShaper);
        function IndicShaper() {
            _classCallCheck(this, IndicShaper);
            return _possibleConstructorReturn(this, _DefaultShaper.apply(this, arguments));
        }
        IndicShaper.planFeatures = function planFeatures(plan) {
            plan.addStage(setupSyllables);
            plan.addStage([
                'locl',
                'ccmp'
            ]);
            plan.addStage(initialReordering);
            plan.addStage('nukt');
            plan.addStage('akhn');
            plan.addStage('rphf', false);
            plan.addStage('rkrf');
            plan.addStage('pref', false);
            plan.addStage('blwf', false);
            plan.addStage('abvf', false);
            plan.addStage('half', false);
            plan.addStage('pstf', false);
            plan.addStage('vatu');
            plan.addStage('cjct');
            plan.addStage('cfar', false);
            plan.addStage(finalReordering);
            plan.addStage({
                local: ['init'],
                global: [
                    'pres',
                    'abvs',
                    'blws',
                    'psts',
                    'haln',
                    'dist',
                    'abvm',
                    'blwm',
                    'calt',
                    'clig'
                ]
            });
            plan.unicodeScript = fromOpenType(plan.script);
            plan.indicConfig = INDIC_CONFIGS[plan.unicodeScript] || INDIC_CONFIGS.Default;
            plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== '2';
        };
        IndicShaper.assignFeatures = function assignFeatures(plan, glyphs) {
            var _loop = function _loop(i) {
                var codepoint = glyphs[i].codePoints[0];
                var d = INDIC_DECOMPOSITIONS[codepoint] || decompositions[codepoint];
                if (d) {
                    var decomposed = d.map(function (c) {
                            var g = plan.font.glyphForCodePoint(c);
                            return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);
                        });
                    glyphs.splice.apply(glyphs, [
                        i,
                        1
                    ].concat(decomposed));
                }
            };
            for (var i = glyphs.length - 1; i >= 0; i--) {
                _loop(i);
            }
        };
        return IndicShaper;
    }(DefaultShaper), _class$6.zeroMarkWidths = 'NONE', _temp$2);
function indicCategory(glyph) {
    return trie$1.get(glyph.codePoints[0]) >> 8;
}
function indicPosition(glyph) {
    return 1 << (trie$1.get(glyph.codePoints[0]) & 255);
}
var IndicInfo = function IndicInfo(category, position, syllableType, syllable) {
    _classCallCheck(this, IndicInfo);
    this.category = category;
    this.position = position;
    this.syllableType = syllableType;
    this.syllable = syllable;
};
function setupSyllables(font, glyphs) {
    var syllable = 0;
    var last = 0;
    for (var _iterator = stateMachine.match(glyphs.map(indicCategory)), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length)
                break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done)
                break;
            _ref = _i.value;
        }
        var _ref2 = _ref, start = _ref2[0], end = _ref2[1], tags = _ref2[2];
        if (start > last) {
            ++syllable;
            for (var _i2 = last; _i2 < start; _i2++) {
                glyphs[_i2].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);
            }
        }
        ++syllable;
        for (var _i3 = start; _i3 <= end; _i3++) {
            glyphs[_i3].shaperInfo = new IndicInfo(1 << indicCategory(glyphs[_i3]), indicPosition(glyphs[_i3]), tags[0], syllable);
        }
        last = end + 1;
    }
    if (last < glyphs.length) {
        ++syllable;
        for (var i = last; i < glyphs.length; i++) {
            glyphs[i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);
        }
    }
}
function isConsonant(glyph) {
    return glyph.shaperInfo.category & CONSONANT_FLAGS;
}
function isJoiner(glyph) {
    return glyph.shaperInfo.category & JOINER_FLAGS;
}
function isHalantOrCoeng(glyph) {
    return glyph.shaperInfo.category & HALANT_OR_COENG_FLAGS;
}
function wouldSubstitute(glyphs, feature) {
    for (var _iterator2 = glyphs, _isArray2 = Array.isArray(_iterator2), _i4 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
        var _glyph$features;
        var _ref3;
        if (_isArray2) {
            if (_i4 >= _iterator2.length)
                break;
            _ref3 = _iterator2[_i4++];
        } else {
            _i4 = _iterator2.next();
            if (_i4.done)
                break;
            _ref3 = _i4.value;
        }
        var glyph = _ref3;
        glyph.features = (_glyph$features = {}, _glyph$features[feature] = true, _glyph$features);
    }
    var GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
    GSUB.applyFeatures([feature], glyphs);
    return glyphs.length === 1;
}
function consonantPosition(font, consonant, virama) {
    var glyphs = [
            virama,
            consonant,
            virama
        ];
    if (wouldSubstitute(glyphs.slice(0, 2), 'blwf') || wouldSubstitute(glyphs.slice(1, 3), 'blwf')) {
        return POSITIONS.Below_C;
    } else if (wouldSubstitute(glyphs.slice(0, 2), 'pstf') || wouldSubstitute(glyphs.slice(1, 3), 'pstf')) {
        return POSITIONS.Post_C;
    } else if (wouldSubstitute(glyphs.slice(0, 2), 'pref') || wouldSubstitute(glyphs.slice(1, 3), 'pref')) {
        return POSITIONS.Post_C;
    }
    return POSITIONS.Base_C;
}
function initialReordering(font, glyphs, plan) {
    var indicConfig = plan.indicConfig;
    var features = font._layoutEngine.engine.GSUBProcessor.features;
    var dottedCircle = font.glyphForCodePoint(9676).id;
    var virama = font.glyphForCodePoint(indicConfig.virama).id;
    if (virama) {
        var info = new GlyphInfo(font, virama, [indicConfig.virama]);
        for (var i = 0; i < glyphs.length; i++) {
            if (glyphs[i].shaperInfo.position === POSITIONS.Base_C) {
                glyphs[i].shaperInfo.position = consonantPosition(font, glyphs[i].copy(), info);
            }
        }
    }
    for (var start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {
        var _glyphs$start$shaperI = glyphs[start].shaperInfo, category = _glyphs$start$shaperI.category, syllableType = _glyphs$start$shaperI.syllableType;
        if (syllableType === 'symbol_cluster' || syllableType === 'non_indic_cluster') {
            continue;
        }
        if (syllableType === 'broken_cluster' && dottedCircle) {
            var g = new GlyphInfo(font, dottedCircle, [9676]);
            g.shaperInfo = new IndicInfo(1 << indicCategory(g), indicPosition(g), glyphs[start].shaperInfo.syllableType, glyphs[start].shaperInfo.syllable);
            var _i5 = start;
            while (_i5 < end && glyphs[_i5].shaperInfo.category === CATEGORIES.Repha) {
                _i5++;
            }
            glyphs.splice(_i5++, 0, g);
            end++;
        }
        var base = end;
        var limit = start;
        var hasReph = false;
        if (indicConfig.rephPos !== POSITIONS.Ra_To_Become_Reph && features.rphf && start + 3 <= end && (indicConfig.rephMode === 'Implicit' && !isJoiner(glyphs[start + 2]) || indicConfig.rephMode === 'Explicit' && glyphs[start + 2].shaperInfo.category === CATEGORIES.ZWJ)) {
            var _g = [
                    glyphs[start].copy(),
                    glyphs[start + 1].copy(),
                    glyphs[start + 2].copy()
                ];
            if (wouldSubstitute(_g.slice(0, 2), 'rphf') || indicConfig.rephMode === 'Explicit' && wouldSubstitute(_g, 'rphf')) {
                limit += 2;
                while (limit < end && isJoiner(glyphs[limit])) {
                    limit++;
                }
                base = start;
                hasReph = true;
            }
        } else if (indicConfig.rephMode === 'Log_Repha' && glyphs[start].shaperInfo.category === CATEGORIES.Repha) {
            limit++;
            while (limit < end && isJoiner(glyphs[limit])) {
                limit++;
            }
            base = start;
            hasReph = true;
        }
        switch (indicConfig.basePos) {
        case 'Last': {
                var _i6 = end;
                var seenBelow = false;
                do {
                    var _info = glyphs[--_i6].shaperInfo;
                    if (isConsonant(glyphs[_i6])) {
                        if (_info.position !== POSITIONS.Below_C && (_info.position !== POSITIONS.Post_C || seenBelow)) {
                            base = _i6;
                            break;
                        }
                        if (_info.position === POSITIONS.Below_C) {
                            seenBelow = true;
                        }
                        base = _i6;
                    } else if (start < _i6 && _info.category === CATEGORIES.ZWJ && glyphs[_i6 - 1].shaperInfo.category === CATEGORIES.H) {
                        break;
                    }
                } while (_i6 > limit);
                break;
            }
        case 'First': {
                base = start;
                for (var _i7 = base + 1; _i7 < end; _i7++) {
                    if (isConsonant(glyphs[_i7])) {
                        glyphs[_i7].shaperInfo.position = POSITIONS.Below_C;
                    }
                }
            }
        }
        if (hasReph && base === start && limit - base <= 2) {
            hasReph = false;
        }
        for (var _i8 = start; _i8 < base; _i8++) {
            var _info2 = glyphs[_i8].shaperInfo;
            _info2.position = Math.min(POSITIONS.Pre_C, _info2.position);
        }
        if (base < end) {
            glyphs[base].shaperInfo.position = POSITIONS.Base_C;
        }
        for (var _i9 = base + 1; _i9 < end; _i9++) {
            if (glyphs[_i9].shaperInfo.category === CATEGORIES.M) {
                for (var j = _i9 + 1; j < end; j++) {
                    if (isConsonant(glyphs[j])) {
                        glyphs[j].shaperInfo.position = POSITIONS.Final_C;
                        break;
                    }
                }
                break;
            }
        }
        if (hasReph) {
            glyphs[start].shaperInfo.position = POSITIONS.Ra_To_Become_Reph;
        }
        if (plan.isOldSpec) {
            var disallowDoubleHalants = plan.unicodeScript !== 'Malayalam';
            for (var _i10 = base + 1; _i10 < end; _i10++) {
                if (glyphs[_i10].shaperInfo.category === CATEGORIES.H) {
                    var _j = void 0;
                    for (_j = end - 1; _j > _i10; _j--) {
                        if (isConsonant(glyphs[_j]) || disallowDoubleHalants && glyphs[_j].shaperInfo.category === CATEGORIES.H) {
                            break;
                        }
                    }
                    if (glyphs[_j].shaperInfo.category !== CATEGORIES.H && _j > _i10) {
                        var t = glyphs[_i10];
                        glyphs.splice.apply(glyphs, [
                            _i10,
                            0
                        ].concat(glyphs.splice(_i10 + 1, _j - _i10)));
                        glyphs[_j] = t;
                    }
                    break;
                }
            }
        }
        var lastPos = POSITIONS.Start;
        for (var _i11 = start; _i11 < end; _i11++) {
            var _info3 = glyphs[_i11].shaperInfo;
            if (_info3.category & (JOINER_FLAGS | CATEGORIES.N | CATEGORIES.RS | CATEGORIES.CM | HALANT_OR_COENG_FLAGS & _info3.category)) {
                _info3.position = lastPos;
                if (_info3.category === CATEGORIES.H && _info3.position === POSITIONS.Pre_M) {
                    for (var _j2 = _i11; _j2 > start; _j2--) {
                        if (glyphs[_j2 - 1].shaperInfo.position !== POSITIONS.Pre_M) {
                            _info3.position = glyphs[_j2 - 1].shaperInfo.position;
                            break;
                        }
                    }
                }
            } else if (_info3.position !== POSITIONS.SMVD) {
                lastPos = _info3.position;
            }
        }
        var last = base;
        for (var _i12 = base + 1; _i12 < end; _i12++) {
            if (isConsonant(glyphs[_i12])) {
                for (var _j3 = last + 1; _j3 < _i12; _j3++) {
                    if (glyphs[_j3].shaperInfo.position < POSITIONS.SMVD) {
                        glyphs[_j3].shaperInfo.position = glyphs[_i12].shaperInfo.position;
                    }
                }
                last = _i12;
            } else if (glyphs[_i12].shaperInfo.category === CATEGORIES.M) {
                last = _i12;
            }
        }
        var arr = glyphs.slice(start, end);
        arr.sort(function (a, b) {
            return a.shaperInfo.position - b.shaperInfo.position;
        });
        glyphs.splice.apply(glyphs, [
            start,
            arr.length
        ].concat(arr));
        for (var _i13 = start; _i13 < end; _i13++) {
            if (glyphs[_i13].shaperInfo.position === POSITIONS.Base_C) {
                base = _i13;
                break;
            }
        }
        for (var _i14 = start; _i14 < end && glyphs[_i14].shaperInfo.position === POSITIONS.Ra_To_Become_Reph; _i14++) {
            glyphs[_i14].features.rphf = true;
        }
        var blwf = !plan.isOldSpec && indicConfig.blwfMode === 'Pre_And_Post';
        for (var _i15 = start; _i15 < base; _i15++) {
            glyphs[_i15].features.half = true;
            if (blwf) {
                glyphs[_i15].features.blwf = true;
            }
        }
        for (var _i16 = base + 1; _i16 < end; _i16++) {
            glyphs[_i16].features.abvf = true;
            glyphs[_i16].features.pstf = true;
            glyphs[_i16].features.blwf = true;
        }
        if (plan.isOldSpec && plan.unicodeScript === 'Devanagari') {
            for (var _i17 = start; _i17 + 1 < base; _i17++) {
                if (glyphs[_i17].shaperInfo.category === CATEGORIES.Ra && glyphs[_i17 + 1].shaperInfo.category === CATEGORIES.H && (_i17 + 1 === base || glyphs[_i17 + 2].shaperInfo.category === CATEGORIES.ZWJ)) {
                    glyphs[_i17].features.blwf = true;
                    glyphs[_i17 + 1].features.blwf = true;
                }
            }
        }
        var prefLen = 2;
        if (features.pref && base + prefLen < end) {
            for (var _i18 = base + 1; _i18 + prefLen - 1 < end; _i18++) {
                var _g2 = [
                        glyphs[_i18].copy(),
                        glyphs[_i18 + 1].copy()
                    ];
                if (wouldSubstitute(_g2, 'pref')) {
                    for (var _j4 = 0; _j4 < prefLen; _j4++) {
                        glyphs[_i18++].features.pref = true;
                    }
                    if (features.cfar) {
                        for (; _i18 < end; _i18++) {
                            glyphs[_i18].features.cfar = true;
                        }
                    }
                    break;
                }
            }
        }
        for (var _i19 = start + 1; _i19 < end; _i19++) {
            if (isJoiner(glyphs[_i19])) {
                var nonJoiner = glyphs[_i19].shaperInfo.category === CATEGORIES.ZWNJ;
                var _j5 = _i19;
                do {
                    _j5--;
                    if (nonJoiner) {
                        delete glyphs[_j5].features.half;
                    }
                } while (_j5 > start && !isConsonant(glyphs[_j5]));
            }
        }
    }
}
function finalReordering(font, glyphs, plan) {
    var indicConfig = plan.indicConfig;
    var features = font._layoutEngine.engine.GSUBProcessor.features;
    for (var start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {
        var tryPref = !!features.pref;
        var base = start;
        for (; base < end; base++) {
            if (glyphs[base].shaperInfo.position >= POSITIONS.Base_C) {
                if (tryPref && base + 1 < end) {
                    for (var i = base + 1; i < end; i++) {
                        if (glyphs[i].features.pref) {
                            if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {
                                base = i;
                                while (base < end && isHalantOrCoeng(glyphs[base])) {
                                    base++;
                                }
                                glyphs[base].shaperInfo.position = POSITIONS.BASE_C;
                                tryPref = false;
                            }
                            break;
                        }
                    }
                }
                if (plan.unicodeScript === 'Malayalam') {
                    for (var _i20 = base + 1; _i20 < end; _i20++) {
                        while (_i20 < end && isJoiner(glyphs[_i20])) {
                            _i20++;
                        }
                        if (_i20 === end || !isHalantOrCoeng(glyphs[_i20])) {
                            break;
                        }
                        _i20++;
                        while (_i20 < end && isJoiner(glyphs[_i20])) {
                            _i20++;
                        }
                        if (_i20 < end && isConsonant(glyphs[_i20]) && glyphs[_i20].shaperInfo.position === POSITIONS.Below_C) {
                            base = _i20;
                            glyphs[base].shaperInfo.position = POSITIONS.Base_C;
                        }
                    }
                }
                if (start < base && glyphs[base].shaperInfo.position > POSITIONS.Base_C) {
                    base--;
                }
                break;
            }
        }
        if (base === end && start < base && glyphs[base - 1].shaperInfo.category === CATEGORIES.ZWJ) {
            base--;
        }
        if (base < end) {
            while (start < base && glyphs[base].shaperInfo.category & (CATEGORIES.N | HALANT_OR_COENG_FLAGS)) {
                base--;
            }
        }
        if (start + 1 < end && start < base) {
            var newPos = base === end ? base - 2 : base - 1;
            if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {
                while (newPos > start && !(glyphs[newPos].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {
                    newPos--;
                }
                if (isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {
                    if (newPos + 1 < end && isJoiner(glyphs[newPos + 1])) {
                        newPos++;
                    }
                } else {
                    newPos = start;
                }
            }
            if (start < newPos && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {
                for (var _i21 = newPos; _i21 > start; _i21--) {
                    if (glyphs[_i21 - 1].shaperInfo.position === POSITIONS.Pre_M) {
                        var oldPos = _i21 - 1;
                        if (oldPos < base && base <= newPos) {
                            base--;
                        }
                        var tmp = glyphs[oldPos];
                        glyphs.splice.apply(glyphs, [
                            oldPos,
                            0
                        ].concat(glyphs.splice(oldPos + 1, newPos - oldPos)));
                        glyphs[newPos] = tmp;
                        newPos--;
                    }
                }
            }
        }
        if (start + 1 < end && glyphs[start].shaperInfo.position === POSITIONS.Ra_To_Become_Reph && glyphs[start].shaperInfo.category === CATEGORIES.Repha !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)) {
            var newRephPos = void 0;
            var rephPos = indicConfig.rephPos;
            var found = false;
            if (rephPos !== POSITIONS.After_Post) {
                newRephPos = start + 1;
                while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {
                    newRephPos++;
                }
                if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {
                    if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {
                        newRephPos++;
                    }
                    found = true;
                }
                if (!found && rephPos === POSITIONS.After_Main) {
                    newRephPos = base;
                    while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= POSITIONS.After_Main) {
                        newRephPos++;
                    }
                    found = newRephPos < end;
                }
                if (!found && rephPos === POSITIONS.After_Sub) {
                    newRephPos = base;
                    while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & (POSITIONS.Post_C | POSITIONS.After_Post | POSITIONS.SMVD))) {
                        newRephPos++;
                    }
                    found = newRephPos < end;
                }
            }
            if (!found) {
                newRephPos = start + 1;
                while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {
                    newRephPos++;
                }
                if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {
                    if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {
                        newRephPos++;
                    }
                    found = true;
                }
            }
            if (!found) {
                newRephPos = end - 1;
                while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === POSITIONS.SMVD) {
                    newRephPos--;
                }
                if (isHalantOrCoeng(glyphs[newRephPos])) {
                    for (var _i22 = base + 1; _i22 < newRephPos; _i22++) {
                        if (glyphs[_i22].shaperInfo.category === CATEGORIES.M) {
                            newRephPos--;
                        }
                    }
                }
            }
            var reph = glyphs[start];
            glyphs.splice.apply(glyphs, [
                start,
                0
            ].concat(glyphs.splice(start + 1, newRephPos - start)));
            glyphs[newRephPos] = reph;
            if (start < base && base <= newRephPos) {
                base--;
            }
        }
        if (tryPref && base + 1 < end) {
            for (var _i23 = base + 1; _i23 < end; _i23++) {
                if (glyphs[_i23].features.pref) {
                    if (glyphs[_i23].isLigated && !glyphs[_i23].isMultiplied) {
                        var _newPos = base;
                        if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {
                            while (_newPos > start && !(glyphs[_newPos - 1].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {
                                _newPos--;
                            }
                            if (_newPos > start && glyphs[_newPos - 1].shaperInfo.category === CATEGORIES.M) {
                                var _oldPos2 = _i23;
                                for (var j = base + 1; j < _oldPos2; j++) {
                                    if (glyphs[j].shaperInfo.category === CATEGORIES.M) {
                                        _newPos--;
                                        break;
                                    }
                                }
                            }
                        }
                        if (_newPos > start && isHalantOrCoeng(glyphs[_newPos - 1])) {
                            if (_newPos < end && isJoiner(glyphs[_newPos])) {
                                _newPos++;
                            }
                        }
                        var _oldPos = _i23;
                        var _tmp = glyphs[_oldPos];
                        glyphs.splice.apply(glyphs, [
                            _newPos + 1,
                            0
                        ].concat(glyphs.splice(_newPos, _oldPos - _newPos)));
                        glyphs[_newPos] = _tmp;
                        if (_newPos <= base && base < _oldPos) {
                            base++;
                        }
                    }
                    break;
                }
            }
        }
        if (glyphs[start].shaperInfo.position === POSITIONS.Pre_M && (!start || !/Cf|Mn/.test(unicode.getCategory(glyphs[start - 1].codePoints[0])))) {
            glyphs[start].features.init = true;
        }
    }
}
function nextSyllable(glyphs, start) {
    if (start >= glyphs.length)
        return start;
    var syllable = glyphs[start].shaperInfo.syllable;
    while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable) {
    }
    return start;
}
var _class$7;
var _temp$3;
var categories$1 = useData.categories;
var decompositions$2 = useData.decompositions;
var trie$2 = new UnicodeTrie(Buffer('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', 'base64'));
var stateMachine$1 = new StateMachine(useData);
var UniversalShaper = (_temp$3 = _class$7 = function (_DefaultShaper) {
        _inherits(UniversalShaper, _DefaultShaper);
        function UniversalShaper() {
            _classCallCheck(this, UniversalShaper);
            return _possibleConstructorReturn(this, _DefaultShaper.apply(this, arguments));
        }
        UniversalShaper.planFeatures = function planFeatures(plan) {
            plan.addStage(setupSyllables$1);
            plan.addStage([
                'locl',
                'ccmp',
                'nukt',
                'akhn'
            ]);
            plan.addStage(clearSubstitutionFlags);
            plan.addStage(['rphf'], false);
            plan.addStage(recordRphf);
            plan.addStage(clearSubstitutionFlags);
            plan.addStage(['pref']);
            plan.addStage(recordPref);
            plan.addStage([
                'rkrf',
                'abvf',
                'blwf',
                'half',
                'pstf',
                'vatu',
                'cjct'
            ]);
            plan.addStage(reorder);
            plan.addStage([
                'abvs',
                'blws',
                'pres',
                'psts',
                'dist',
                'abvm',
                'blwm'
            ]);
        };
        UniversalShaper.assignFeatures = function assignFeatures(plan, glyphs) {
            var _loop = function _loop(i) {
                var codepoint = glyphs[i].codePoints[0];
                if (decompositions$2[codepoint]) {
                    var decomposed = decompositions$2[codepoint].map(function (c) {
                            var g = plan.font.glyphForCodePoint(c);
                            return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);
                        });
                    glyphs.splice.apply(glyphs, [
                        i,
                        1
                    ].concat(decomposed));
                }
            };
            for (var i = glyphs.length - 1; i >= 0; i--) {
                _loop(i);
            }
        };
        return UniversalShaper;
    }(DefaultShaper), _class$7.zeroMarkWidths = 'BEFORE_GPOS', _temp$3);
function useCategory(glyph) {
    return trie$2.get(glyph.codePoints[0]);
}
var USEInfo = function USEInfo(category, syllableType, syllable) {
    _classCallCheck(this, USEInfo);
    this.category = category;
    this.syllableType = syllableType;
    this.syllable = syllable;
};
function setupSyllables$1(font, glyphs) {
    var syllable = 0;
    for (var _iterator = stateMachine$1.match(glyphs.map(useCategory)), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length)
                break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done)
                break;
            _ref = _i.value;
        }
        var _ref2 = _ref, start = _ref2[0], end = _ref2[1], tags = _ref2[2];
        ++syllable;
        for (var i = start; i <= end; i++) {
            glyphs[i].shaperInfo = new USEInfo(categories$1[useCategory(glyphs[i])], tags[0], syllable);
        }
        var limit = glyphs[start].shaperInfo.category === 'R' ? 1 : Math.min(3, end - start);
        for (var _i2 = start; _i2 < start + limit; _i2++) {
            glyphs[_i2].features.rphf = true;
        }
    }
}
function clearSubstitutionFlags(font, glyphs) {
    for (var _iterator2 = glyphs, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
        var _ref3;
        if (_isArray2) {
            if (_i3 >= _iterator2.length)
                break;
            _ref3 = _iterator2[_i3++];
        } else {
            _i3 = _iterator2.next();
            if (_i3.done)
                break;
            _ref3 = _i3.value;
        }
        var glyph = _ref3;
        glyph.substituted = false;
    }
}
function recordRphf(font, glyphs) {
    for (var _iterator3 = glyphs, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
        var _ref4;
        if (_isArray3) {
            if (_i4 >= _iterator3.length)
                break;
            _ref4 = _iterator3[_i4++];
        } else {
            _i4 = _iterator3.next();
            if (_i4.done)
                break;
            _ref4 = _i4.value;
        }
        var glyph = _ref4;
        if (glyph.substituted && glyph.features.rphf) {
            glyph.shaperInfo.category = 'R';
        }
    }
}
function recordPref(font, glyphs) {
    for (var _iterator4 = glyphs, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
        var _ref5;
        if (_isArray4) {
            if (_i5 >= _iterator4.length)
                break;
            _ref5 = _iterator4[_i5++];
        } else {
            _i5 = _iterator4.next();
            if (_i5.done)
                break;
            _ref5 = _i5.value;
        }
        var glyph = _ref5;
        if (glyph.substituted) {
            glyph.shaperInfo.category = 'VPre';
        }
    }
}
function reorder(font, glyphs) {
    var dottedCircle = font.glyphForCodePoint(9676).id;
    for (var start = 0, end = nextSyllable$1(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable$1(glyphs, start)) {
        var i = void 0, j = void 0;
        var info = glyphs[start].shaperInfo;
        var type = info.syllableType;
        if (type !== 'virama_terminated_cluster' && type !== 'standard_cluster' && type !== 'broken_cluster') {
            continue;
        }
        if (type === 'broken_cluster' && dottedCircle) {
            var g = new GlyphInfo(font, dottedCircle, [9676]);
            g.shaperInfo = info;
            for (i = start; i < end && glyphs[i].shaperInfo.category === 'R'; i++) {
            }
            glyphs.splice(++i, 0, g);
            end++;
        }
        if (info.category === 'R' && end - start > 1) {
            for (i = start + 1; i < end; i++) {
                info = glyphs[i].shaperInfo;
                if (isBase(info) || isHalant(glyphs[i])) {
                    if (isHalant(glyphs[i])) {
                        i--;
                    }
                    glyphs.splice.apply(glyphs, [
                        start,
                        0
                    ].concat(glyphs.splice(start + 1, i - start), [glyphs[i]]));
                    break;
                }
            }
        }
        for (i = start, j = end; i < end; i++) {
            info = glyphs[i].shaperInfo;
            if (isBase(info) || isHalant(glyphs[i])) {
                j = isHalant(glyphs[i]) ? i + 1 : i;
            } else if ((info.category === 'VPre' || info.category === 'VMPre') && j < i) {
                glyphs.splice.apply(glyphs, [
                    j,
                    1,
                    glyphs[i]
                ].concat(glyphs.splice(j, i - j)));
            }
        }
    }
}
function nextSyllable$1(glyphs, start) {
    if (start >= glyphs.length)
        return start;
    var syllable = glyphs[start].shaperInfo.syllable;
    while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable) {
    }
    return start;
}
function isHalant(glyph) {
    return glyph.shaperInfo.category === 'H' && !glyph.isLigated;
}
function isBase(info) {
    return info.category === 'B' || info.category === 'GB';
}
var SHAPERS = {
        arab: ArabicShaper,
        mong: ArabicShaper,
        syrc: ArabicShaper,
        'nko ': ArabicShaper,
        phag: ArabicShaper,
        mand: ArabicShaper,
        mani: ArabicShaper,
        phlp: ArabicShaper,
        hang: HangulShaper,
        bng2: IndicShaper,
        beng: IndicShaper,
        dev2: IndicShaper,
        deva: IndicShaper,
        gjr2: IndicShaper,
        gujr: IndicShaper,
        guru: IndicShaper,
        gur2: IndicShaper,
        knda: IndicShaper,
        knd2: IndicShaper,
        mlm2: IndicShaper,
        mlym: IndicShaper,
        ory2: IndicShaper,
        orya: IndicShaper,
        taml: IndicShaper,
        tml2: IndicShaper,
        telu: IndicShaper,
        tel2: IndicShaper,
        khmr: IndicShaper,
        bali: UniversalShaper,
        batk: UniversalShaper,
        brah: UniversalShaper,
        bugi: UniversalShaper,
        buhd: UniversalShaper,
        cakm: UniversalShaper,
        cham: UniversalShaper,
        dupl: UniversalShaper,
        egyp: UniversalShaper,
        gran: UniversalShaper,
        hano: UniversalShaper,
        java: UniversalShaper,
        kthi: UniversalShaper,
        kali: UniversalShaper,
        khar: UniversalShaper,
        khoj: UniversalShaper,
        sind: UniversalShaper,
        lepc: UniversalShaper,
        limb: UniversalShaper,
        mahj: UniversalShaper,
        mtei: UniversalShaper,
        modi: UniversalShaper,
        hmng: UniversalShaper,
        rjng: UniversalShaper,
        saur: UniversalShaper,
        shrd: UniversalShaper,
        sidd: UniversalShaper,
        sinh: UniversalShaper,
        sund: UniversalShaper,
        sylo: UniversalShaper,
        tglg: UniversalShaper,
        tagb: UniversalShaper,
        tale: UniversalShaper,
        lana: UniversalShaper,
        tavt: UniversalShaper,
        takr: UniversalShaper,
        tibt: UniversalShaper,
        tfng: UniversalShaper,
        tirh: UniversalShaper,
        latn: DefaultShaper,
        DFLT: DefaultShaper
    };
function choose(script) {
    if (!Array.isArray(script)) {
        script = [script];
    }
    for (var _iterator = script, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length)
                break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done)
                break;
            _ref = _i.value;
        }
        var s = _ref;
        var shaper = SHAPERS[s];
        if (shaper) {
            return shaper;
        }
    }
    return DefaultShaper;
}
var GSUBProcessor = function (_OTProcessor) {
        _inherits(GSUBProcessor, _OTProcessor);
        function GSUBProcessor() {
            _classCallCheck(this, GSUBProcessor);
            return _possibleConstructorReturn(this, _OTProcessor.apply(this, arguments));
        }
        GSUBProcessor.prototype.applyLookup = function applyLookup(lookupType, table) {
            var _this2 = this;
            switch (lookupType) {
            case 1: {
                    var index = this.coverageIndex(table.coverage);
                    if (index === -1) {
                        return false;
                    }
                    var glyph = this.glyphIterator.cur;
                    switch (table.version) {
                    case 1:
                        glyph.id = glyph.id + table.deltaGlyphID & 65535;
                        break;
                    case 2:
                        glyph.id = table.substitute.get(index);
                        break;
                    }
                    return true;
                }
            case 2: {
                    var _index = this.coverageIndex(table.coverage);
                    if (_index !== -1) {
                        var _glyphs;
                        var sequence = table.sequences.get(_index);
                        if (sequence.length === 0) {
                            this.glyphs.splice(this.glyphIterator.index, 1);
                            return true;
                        }
                        this.glyphIterator.cur.id = sequence[0];
                        this.glyphIterator.cur.ligatureComponent = 0;
                        var features = this.glyphIterator.cur.features;
                        var curGlyph = this.glyphIterator.cur;
                        var replacement = sequence.slice(1).map(function (gid, i) {
                                var glyph = new GlyphInfo(_this2.font, gid, undefined, features);
                                glyph.shaperInfo = curGlyph.shaperInfo;
                                glyph.isLigated = curGlyph.isLigated;
                                glyph.ligatureComponent = i + 1;
                                glyph.substituted = true;
                                glyph.isMultiplied = true;
                                return glyph;
                            });
                        (_glyphs = this.glyphs).splice.apply(_glyphs, [
                            this.glyphIterator.index + 1,
                            0
                        ].concat(replacement));
                        return true;
                    }
                    return false;
                }
            case 3: {
                    var _index2 = this.coverageIndex(table.coverage);
                    if (_index2 !== -1) {
                        var USER_INDEX = 0;
                        this.glyphIterator.cur.id = table.alternateSet.get(_index2)[USER_INDEX];
                        return true;
                    }
                    return false;
                }
            case 4: {
                    var _index3 = this.coverageIndex(table.coverage);
                    if (_index3 === -1) {
                        return false;
                    }
                    for (var _iterator = table.ligatureSets.get(_index3), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length)
                                break;
                            _ref = _iterator[_i++];
                        } else {
                            _i = _iterator.next();
                            if (_i.done)
                                break;
                            _ref = _i.value;
                        }
                        var ligature = _ref;
                        var matched = this.sequenceMatchIndices(1, ligature.components);
                        if (!matched) {
                            continue;
                        }
                        var _curGlyph = this.glyphIterator.cur;
                        var characters = _curGlyph.codePoints.slice();
                        for (var _iterator2 = matched, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length)
                                    break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                _i2 = _iterator2.next();
                                if (_i2.done)
                                    break;
                                _ref2 = _i2.value;
                            }
                            var _index4 = _ref2;
                            characters.push.apply(characters, this.glyphs[_index4].codePoints);
                        }
                        var ligatureGlyph = new GlyphInfo(this.font, ligature.glyph, characters, _curGlyph.features);
                        ligatureGlyph.shaperInfo = _curGlyph.shaperInfo;
                        ligatureGlyph.isLigated = true;
                        ligatureGlyph.substituted = true;
                        var isMarkLigature = _curGlyph.isMark;
                        for (var i = 0; i < matched.length && isMarkLigature; i++) {
                            isMarkLigature = this.glyphs[matched[i]].isMark;
                        }
                        ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
                        var lastLigID = _curGlyph.ligatureID;
                        var lastNumComps = _curGlyph.codePoints.length;
                        var curComps = lastNumComps;
                        var idx = this.glyphIterator.index + 1;
                        for (var _iterator3 = matched, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length)
                                    break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                _i3 = _iterator3.next();
                                if (_i3.done)
                                    break;
                                _ref3 = _i3.value;
                            }
                            var matchIndex = _ref3;
                            if (isMarkLigature) {
                                idx = matchIndex;
                            } else {
                                while (idx < matchIndex) {
                                    var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
                                    this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
                                    this.glyphs[idx].ligatureComponent = ligatureComponent;
                                    idx++;
                                }
                            }
                            lastLigID = this.glyphs[idx].ligatureID;
                            lastNumComps = this.glyphs[idx].codePoints.length;
                            curComps += lastNumComps;
                            idx++;
                        }
                        if (lastLigID && !isMarkLigature) {
                            for (var _i4 = idx; _i4 < this.glyphs.length; _i4++) {
                                if (this.glyphs[_i4].ligatureID === lastLigID) {
                                    var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[_i4].ligatureComponent || 1, lastNumComps);
                                    this.glyphs[_i4].ligatureComponent = ligatureComponent;
                                } else {
                                    break;
                                }
                            }
                        }
                        for (var _i5 = matched.length - 1; _i5 >= 0; _i5--) {
                            this.glyphs.splice(matched[_i5], 1);
                        }
                        this.glyphs[this.glyphIterator.index] = ligatureGlyph;
                        return true;
                    }
                    return false;
                }
            case 5:
                return this.applyContext(table);
            case 6:
                return this.applyChainingContext(table);
            case 7:
                return this.applyLookup(table.lookupType, table.extension);
            default:
                throw new Error('GSUB lookupType ' + lookupType + ' is not supported');
            }
        };
        return GSUBProcessor;
    }(OTProcessor);
var GPOSProcessor = function (_OTProcessor) {
        _inherits(GPOSProcessor, _OTProcessor);
        function GPOSProcessor() {
            _classCallCheck(this, GPOSProcessor);
            return _possibleConstructorReturn(this, _OTProcessor.apply(this, arguments));
        }
        GPOSProcessor.prototype.applyPositionValue = function applyPositionValue(sequenceIndex, value) {
            var position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
            if (value.xAdvance != null) {
                position.xAdvance += value.xAdvance;
            }
            if (value.yAdvance != null) {
                position.yAdvance += value.yAdvance;
            }
            if (value.xPlacement != null) {
                position.xOffset += value.xPlacement;
            }
            if (value.yPlacement != null) {
                position.yOffset += value.yPlacement;
            }
            var variationProcessor = this.font._variationProcessor;
            var variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
            if (variationProcessor && variationStore) {
                if (value.xPlaDevice) {
                    position.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);
                }
                if (value.yPlaDevice) {
                    position.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);
                }
                if (value.xAdvDevice) {
                    position.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);
                }
                if (value.yAdvDevice) {
                    position.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);
                }
            }
        };
        GPOSProcessor.prototype.applyLookup = function applyLookup(lookupType, table) {
            switch (lookupType) {
            case 1: {
                    var index = this.coverageIndex(table.coverage);
                    if (index === -1) {
                        return false;
                    }
                    switch (table.version) {
                    case 1:
                        this.applyPositionValue(0, table.value);
                        break;
                    case 2:
                        this.applyPositionValue(0, table.values.get(index));
                        break;
                    }
                    return true;
                }
            case 2: {
                    var nextGlyph = this.glyphIterator.peek();
                    if (!nextGlyph) {
                        return false;
                    }
                    var _index = this.coverageIndex(table.coverage);
                    if (_index === -1) {
                        return false;
                    }
                    switch (table.version) {
                    case 1:
                        var set = table.pairSets.get(_index);
                        for (var _iterator = set, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length)
                                    break;
                                _ref = _iterator[_i++];
                            } else {
                                _i = _iterator.next();
                                if (_i.done)
                                    break;
                                _ref = _i.value;
                            }
                            var _pair = _ref;
                            if (_pair.secondGlyph === nextGlyph.id) {
                                this.applyPositionValue(0, _pair.value1);
                                this.applyPositionValue(1, _pair.value2);
                                return true;
                            }
                        }
                        return false;
                    case 2:
                        var class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);
                        var class2 = this.getClassID(nextGlyph.id, table.classDef2);
                        if (class1 === -1 || class2 === -1) {
                            return false;
                        }
                        var pair = table.classRecords.get(class1).get(class2);
                        this.applyPositionValue(0, pair.value1);
                        this.applyPositionValue(1, pair.value2);
                        return true;
                    }
                }
            case 3: {
                    var nextIndex = this.glyphIterator.peekIndex();
                    var _nextGlyph = this.glyphs[nextIndex];
                    if (!_nextGlyph) {
                        return false;
                    }
                    var curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];
                    if (!curRecord || !curRecord.exitAnchor) {
                        return false;
                    }
                    var nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, _nextGlyph.id)];
                    if (!nextRecord || !nextRecord.entryAnchor) {
                        return false;
                    }
                    var entry = this.getAnchor(nextRecord.entryAnchor);
                    var exit = this.getAnchor(curRecord.exitAnchor);
                    var cur = this.positions[this.glyphIterator.index];
                    var next = this.positions[nextIndex];
                    switch (this.direction) {
                    case 'ltr':
                        cur.xAdvance = exit.x + cur.xOffset;
                        var d = entry.x + next.xOffset;
                        next.xAdvance -= d;
                        next.xOffset -= d;
                        break;
                    case 'rtl':
                        d = exit.x + cur.xOffset;
                        cur.xAdvance -= d;
                        cur.xOffset -= d;
                        next.xAdvance = entry.x + next.xOffset;
                        break;
                    }
                    if (this.glyphIterator.flags.rightToLeft) {
                        this.glyphIterator.cur.cursiveAttachment = nextIndex;
                        cur.yOffset = entry.y - exit.y;
                    } else {
                        _nextGlyph.cursiveAttachment = this.glyphIterator.index;
                        cur.yOffset = exit.y - entry.y;
                    }
                    return true;
                }
            case 4: {
                    var markIndex = this.coverageIndex(table.markCoverage);
                    if (markIndex === -1) {
                        return false;
                    }
                    var baseGlyphIndex = this.glyphIterator.index;
                    while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0)) {
                    }
                    if (baseGlyphIndex < 0) {
                        return false;
                    }
                    var baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);
                    if (baseIndex === -1) {
                        return false;
                    }
                    var markRecord = table.markArray[markIndex];
                    var baseAnchor = table.baseArray[baseIndex][markRecord.class];
                    this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
                    return true;
                }
            case 5: {
                    var _markIndex = this.coverageIndex(table.markCoverage);
                    if (_markIndex === -1) {
                        return false;
                    }
                    var _baseGlyphIndex = this.glyphIterator.index;
                    while (--_baseGlyphIndex >= 0 && this.glyphs[_baseGlyphIndex].isMark) {
                    }
                    if (_baseGlyphIndex < 0) {
                        return false;
                    }
                    var ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[_baseGlyphIndex].id);
                    if (ligIndex === -1) {
                        return false;
                    }
                    var ligAttach = table.ligatureArray[ligIndex];
                    var markGlyph = this.glyphIterator.cur;
                    var ligGlyph = this.glyphs[_baseGlyphIndex];
                    var compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
                    var _markRecord = table.markArray[_markIndex];
                    var _baseAnchor = ligAttach[compIndex][_markRecord.class];
                    this.applyAnchor(_markRecord, _baseAnchor, _baseGlyphIndex);
                    return true;
                }
            case 6: {
                    var mark1Index = this.coverageIndex(table.mark1Coverage);
                    if (mark1Index === -1) {
                        return false;
                    }
                    var prevIndex = this.glyphIterator.peekIndex(-1);
                    var prev = this.glyphs[prevIndex];
                    if (!prev || !prev.isMark) {
                        return false;
                    }
                    var _cur = this.glyphIterator.cur;
                    var good = false;
                    if (_cur.ligatureID === prev.ligatureID) {
                        if (!_cur.ligatureID) {
                            good = true;
                        } else if (_cur.ligatureComponent === prev.ligatureComponent) {
                            good = true;
                        }
                    } else {
                        if (_cur.ligatureID && !_cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) {
                            good = true;
                        }
                    }
                    if (!good) {
                        return false;
                    }
                    var mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);
                    if (mark2Index === -1) {
                        return false;
                    }
                    var _markRecord2 = table.mark1Array[mark1Index];
                    var _baseAnchor2 = table.mark2Array[mark2Index][_markRecord2.class];
                    this.applyAnchor(_markRecord2, _baseAnchor2, prevIndex);
                    return true;
                }
            case 7:
                return this.applyContext(table);
            case 8:
                return this.applyChainingContext(table);
            case 9:
                return this.applyLookup(table.lookupType, table.extension);
            default:
                throw new Error('Unsupported GPOS table: ' + lookupType);
            }
        };
        GPOSProcessor.prototype.applyAnchor = function applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
            var baseCoords = this.getAnchor(baseAnchor);
            var markCoords = this.getAnchor(markRecord.markAnchor);
            var basePos = this.positions[baseGlyphIndex];
            var markPos = this.positions[this.glyphIterator.index];
            markPos.xOffset = baseCoords.x - markCoords.x;
            markPos.yOffset = baseCoords.y - markCoords.y;
            this.glyphIterator.cur.markAttachment = baseGlyphIndex;
        };
        GPOSProcessor.prototype.getAnchor = function getAnchor(anchor) {
            var x = anchor.xCoordinate;
            var y = anchor.yCoordinate;
            var variationProcessor = this.font._variationProcessor;
            var variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
            if (variationProcessor && variationStore) {
                if (anchor.xDeviceTable) {
                    x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
                }
                if (anchor.yDeviceTable) {
                    y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
                }
            }
            return {
                x: x,
                y: y
            };
        };
        GPOSProcessor.prototype.applyFeatures = function applyFeatures(userFeatures, glyphs, advances) {
            _OTProcessor.prototype.applyFeatures.call(this, userFeatures, glyphs, advances);
            for (var i = 0; i < this.glyphs.length; i++) {
                this.fixCursiveAttachment(i);
            }
            this.fixMarkAttachment();
        };
        GPOSProcessor.prototype.fixCursiveAttachment = function fixCursiveAttachment(i) {
            var glyph = this.glyphs[i];
            if (glyph.cursiveAttachment != null) {
                var j = glyph.cursiveAttachment;
                glyph.cursiveAttachment = null;
                this.fixCursiveAttachment(j);
                this.positions[i].yOffset += this.positions[j].yOffset;
            }
        };
        GPOSProcessor.prototype.fixMarkAttachment = function fixMarkAttachment() {
            for (var i = 0; i < this.glyphs.length; i++) {
                var glyph = this.glyphs[i];
                if (glyph.markAttachment != null) {
                    var j = glyph.markAttachment;
                    this.positions[i].xOffset += this.positions[j].xOffset;
                    this.positions[i].yOffset += this.positions[j].yOffset;
                    if (this.direction === 'ltr') {
                        for (var k = j; k < i; k++) {
                            this.positions[i].xOffset -= this.positions[k].xAdvance;
                            this.positions[i].yOffset -= this.positions[k].yAdvance;
                        }
                    } else {
                        for (var _k = j + 1; _k < i + 1; _k++) {
                            this.positions[i].xOffset += this.positions[_k].xAdvance;
                            this.positions[i].yOffset += this.positions[_k].yAdvance;
                        }
                    }
                }
            }
        };
        return GPOSProcessor;
    }(OTProcessor);
var OTLayoutEngine = function () {
        function OTLayoutEngine(font) {
            _classCallCheck(this, OTLayoutEngine);
            this.font = font;
            this.glyphInfos = null;
            this.plan = null;
            this.GSUBProcessor = null;
            this.GPOSProcessor = null;
            this.fallbackPosition = true;
            if (font.GSUB) {
                this.GSUBProcessor = new GSUBProcessor(font, font.GSUB);
            }
            if (font.GPOS) {
                this.GPOSProcessor = new GPOSProcessor(font, font.GPOS);
            }
        }
        OTLayoutEngine.prototype.setup = function setup(glyphRun) {
            var _this = this;
            this.glyphInfos = glyphRun.glyphs.map(function (glyph) {
                return new GlyphInfo(_this.font, glyph.id, [].concat(glyph.codePoints));
            });
            var script = null;
            if (this.GPOSProcessor) {
                script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
            }
            if (this.GSUBProcessor) {
                script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
            }
            this.shaper = choose(script);
            this.plan = new ShapingPlan(this.font, script, glyphRun.direction);
            this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
            for (var key in this.plan.allFeatures) {
                glyphRun.features[key] = true;
            }
        };
        OTLayoutEngine.prototype.substitute = function substitute(glyphRun) {
            var _this2 = this;
            if (this.GSUBProcessor) {
                this.plan.process(this.GSUBProcessor, this.glyphInfos);
                glyphRun.glyphs = this.glyphInfos.map(function (glyphInfo) {
                    return _this2.font.getGlyph(glyphInfo.id, glyphInfo.codePoints);
                });
            }
        };
        OTLayoutEngine.prototype.position = function position(glyphRun) {
            if (this.shaper.zeroMarkWidths === 'BEFORE_GPOS') {
                this.zeroMarkAdvances(glyphRun.positions);
            }
            if (this.GPOSProcessor) {
                this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
            }
            if (this.shaper.zeroMarkWidths === 'AFTER_GPOS') {
                this.zeroMarkAdvances(glyphRun.positions);
            }
            if (glyphRun.direction === 'rtl') {
                glyphRun.glyphs.reverse();
                glyphRun.positions.reverse();
            }
            return this.GPOSProcessor && this.GPOSProcessor.features;
        };
        OTLayoutEngine.prototype.zeroMarkAdvances = function zeroMarkAdvances(positions) {
            for (var i = 0; i < this.glyphInfos.length; i++) {
                if (this.glyphInfos[i].isMark) {
                    positions[i].xAdvance = 0;
                    positions[i].yAdvance = 0;
                }
            }
        };
        OTLayoutEngine.prototype.cleanup = function cleanup() {
            this.glyphInfos = null;
            this.plan = null;
            this.shaper = null;
        };
        OTLayoutEngine.prototype.getAvailableFeatures = function getAvailableFeatures(script, language) {
            var features = [];
            if (this.GSUBProcessor) {
                this.GSUBProcessor.selectScript(script, language);
                features.push.apply(features, _Object$keys(this.GSUBProcessor.features));
            }
            if (this.GPOSProcessor) {
                this.GPOSProcessor.selectScript(script, language);
                features.push.apply(features, _Object$keys(this.GPOSProcessor.features));
            }
            return features;
        };
        return OTLayoutEngine;
    }();
var LayoutEngine = function () {
        function LayoutEngine(font) {
            _classCallCheck(this, LayoutEngine);
            this.font = font;
            this.unicodeLayoutEngine = null;
            this.kernProcessor = null;
            if (this.font.morx) {
                this.engine = new AATLayoutEngine(this.font);
            } else if (this.font.GSUB || this.font.GPOS) {
                this.engine = new OTLayoutEngine(this.font);
            }
        }
        LayoutEngine.prototype.layout = function layout(string, features, script, language, direction) {
            if (typeof features === 'string') {
                direction = language;
                language = script;
                script = features;
                features = [];
            }
            if (typeof string === 'string') {
                if (script == null) {
                    script = forString(string);
                }
                var glyphs = this.font.glyphsForString(string);
            } else {
                if (script == null) {
                    var codePoints = [];
                    for (var _iterator = string, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length)
                                break;
                            _ref = _iterator[_i++];
                        } else {
                            _i = _iterator.next();
                            if (_i.done)
                                break;
                            _ref = _i.value;
                        }
                        var glyph = _ref;
                        codePoints.push.apply(codePoints, glyph.codePoints);
                    }
                    script = forCodePoints(codePoints);
                }
                var glyphs = string;
            }
            var glyphRun = new GlyphRun(glyphs, features, script, language, direction);
            if (glyphs.length === 0) {
                glyphRun.positions = [];
                return glyphRun;
            }
            if (this.engine && this.engine.setup) {
                this.engine.setup(glyphRun);
            }
            this.substitute(glyphRun);
            this.position(glyphRun);
            this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
            if (this.engine && this.engine.cleanup) {
                this.engine.cleanup();
            }
            return glyphRun;
        };
        LayoutEngine.prototype.substitute = function substitute(glyphRun) {
            if (this.engine && this.engine.substitute) {
                this.engine.substitute(glyphRun);
            }
        };
        LayoutEngine.prototype.position = function position(glyphRun) {
            glyphRun.positions = glyphRun.glyphs.map(function (glyph) {
                return new GlyphPosition(glyph.advanceWidth);
            });
            var positioned = null;
            if (this.engine && this.engine.position) {
                positioned = this.engine.position(glyphRun);
            }
            if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
                if (!this.unicodeLayoutEngine) {
                    this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font);
                }
                this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
            }
            if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
                if (!this.kernProcessor) {
                    this.kernProcessor = new KernProcessor(this.font);
                }
                this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
                glyphRun.features.kern = true;
            }
        };
        LayoutEngine.prototype.hideDefaultIgnorables = function hideDefaultIgnorables(glyphs, positions) {
            var space = this.font.glyphForCodePoint(32);
            for (var i = 0; i < glyphs.length; i++) {
                if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {
                    glyphs[i] = space;
                    positions[i].xAdvance = 0;
                    positions[i].yAdvance = 0;
                }
            }
        };
        LayoutEngine.prototype.isDefaultIgnorable = function isDefaultIgnorable(ch) {
            var plane = ch >> 16;
            if (plane === 0) {
                switch (ch >> 8) {
                case 0:
                    return ch === 173;
                case 3:
                    return ch === 847;
                case 6:
                    return ch === 1564;
                case 23:
                    return 6068 <= ch && ch <= 6069;
                case 24:
                    return 6155 <= ch && ch <= 6158;
                case 32:
                    return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
                case 254:
                    return 65024 <= ch && ch <= 65039 || ch === 65279;
                case 255:
                    return 65520 <= ch && ch <= 65528;
                default:
                    return false;
                }
            } else {
                switch (plane) {
                case 1:
                    return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
                case 14:
                    return 917504 <= ch && ch <= 921599;
                default:
                    return false;
                }
            }
        };
        LayoutEngine.prototype.getAvailableFeatures = function getAvailableFeatures(script, language) {
            var features = [];
            if (this.engine) {
                features.push.apply(features, this.engine.getAvailableFeatures(script, language));
            }
            if (this.font.kern && features.indexOf('kern') === -1) {
                features.push('kern');
            }
            return features;
        };
        LayoutEngine.prototype.stringsForGlyph = function stringsForGlyph(gid) {
            var result = new _Set();
            var codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
            for (var _iterator2 = codePoints, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var codePoint = _ref2;
                result.add(_String$fromCodePoint(codePoint));
            }
            if (this.engine && this.engine.stringsForGlyph) {
                for (var _iterator3 = this.engine.stringsForGlyph(gid), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length)
                            break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if (_i3.done)
                            break;
                        _ref3 = _i3.value;
                    }
                    var string = _ref3;
                    result.add(string);
                }
            }
            return _Array$from(result);
        };
        return LayoutEngine;
    }();
var SVG_COMMANDS = {
        moveTo: 'M',
        lineTo: 'L',
        quadraticCurveTo: 'Q',
        bezierCurveTo: 'C',
        closePath: 'Z'
    };
var Path = function () {
        function Path() {
            _classCallCheck(this, Path);
            this.commands = [];
            this._bbox = null;
            this._cbox = null;
        }
        Path.prototype.toFunction = function toFunction() {
            var cmds = this.commands.map(function (c) {
                    return '  ctx.' + c.command + '(' + c.args.join(', ') + ');';
                });
            return new Function('ctx', cmds.join('\n'));
        };
        Path.prototype.toSVG = function toSVG() {
            var cmds = this.commands.map(function (c) {
                    var args = c.args.map(function (arg) {
                            return Math.round(arg * 100) / 100;
                        });
                    return '' + SVG_COMMANDS[c.command] + args.join(' ');
                });
            return cmds.join('');
        };
        Path.prototype.mapPoints = function mapPoints(fn) {
            var path = new Path();
            for (var _iterator = this.commands, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var c = _ref;
                var args = [];
                for (var _i2 = 0; _i2 < c.args.length; _i2 += 2) {
                    var _fn = fn(c.args[_i2], c.args[_i2 + 1]), x = _fn[0], y = _fn[1];
                    args.push(x, y);
                }
                path[c.command].apply(path, args);
            }
            return path;
        };
        Path.prototype.transform = function transform(m0, m1, m2, m3, m4, m5) {
            return this.mapPoints(function (x, y) {
                x = m0 * x + m2 * y + m4;
                y = m1 * x + m3 * y + m5;
                return [
                    x,
                    y
                ];
            });
        };
        Path.prototype.translate = function translate(x, y) {
            return this.transform(1, 0, 0, 1, x, y);
        };
        Path.prototype.rotate = function rotate(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            return this.transform(cos, sin, -sin, cos, 0, 0);
        };
        Path.prototype.scale = function scale(scaleX) {
            var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
            return this.transform(scaleX, 0, 0, scaleY, 0, 0);
        };
        _createClass(Path, [
            {
                key: 'cbox',
                get: function get() {
                    if (!this._cbox) {
                        var cbox = new BBox();
                        for (var _iterator2 = this.commands, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i3 >= _iterator2.length)
                                    break;
                                _ref2 = _iterator2[_i3++];
                            } else {
                                _i3 = _iterator2.next();
                                if (_i3.done)
                                    break;
                                _ref2 = _i3.value;
                            }
                            var command = _ref2;
                            for (var _i4 = 0; _i4 < command.args.length; _i4 += 2) {
                                cbox.addPoint(command.args[_i4], command.args[_i4 + 1]);
                            }
                        }
                        this._cbox = _Object$freeze(cbox);
                    }
                    return this._cbox;
                }
            },
            {
                key: 'bbox',
                get: function get() {
                    if (this._bbox) {
                        return this._bbox;
                    }
                    var bbox = new BBox();
                    var cx = 0, cy = 0;
                    var f = function f(t) {
                        return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];
                    };
                    for (var _iterator3 = this.commands, _isArray3 = Array.isArray(_iterator3), _i5 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i5 >= _iterator3.length)
                                break;
                            _ref3 = _iterator3[_i5++];
                        } else {
                            _i5 = _iterator3.next();
                            if (_i5.done)
                                break;
                            _ref3 = _i5.value;
                        }
                        var c = _ref3;
                        switch (c.command) {
                        case 'moveTo':
                        case 'lineTo':
                            var _c$args = c.args, x = _c$args[0], y = _c$args[1];
                            bbox.addPoint(x, y);
                            cx = x;
                            cy = y;
                            break;
                        case 'quadraticCurveTo':
                        case 'bezierCurveTo':
                            if (c.command === 'quadraticCurveTo') {
                                var _c$args2 = c.args, qp1x = _c$args2[0], qp1y = _c$args2[1], p3x = _c$args2[2], p3y = _c$args2[3];
                                var cp1x = cx + 2 / 3 * (qp1x - cx);
                                var cp1y = cy + 2 / 3 * (qp1y - cy);
                                var cp2x = p3x + 2 / 3 * (qp1x - p3x);
                                var cp2y = p3y + 2 / 3 * (qp1y - p3y);
                            } else {
                                var _c$args3 = c.args, cp1x = _c$args3[0], cp1y = _c$args3[1], cp2x = _c$args3[2], cp2y = _c$args3[3], p3x = _c$args3[4], p3y = _c$args3[5];
                            }
                            bbox.addPoint(p3x, p3y);
                            var p0 = [
                                    cx,
                                    cy
                                ];
                            var p1 = [
                                    cp1x,
                                    cp1y
                                ];
                            var p2 = [
                                    cp2x,
                                    cp2y
                                ];
                            var p3 = [
                                    p3x,
                                    p3y
                                ];
                            for (var i = 0; i <= 1; i++) {
                                var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                                var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                                c = 3 * p1[i] - 3 * p0[i];
                                if (a === 0) {
                                    if (b === 0) {
                                        continue;
                                    }
                                    var t = -c / b;
                                    if (0 < t && t < 1) {
                                        if (i === 0) {
                                            bbox.addPoint(f(t), bbox.maxY);
                                        } else if (i === 1) {
                                            bbox.addPoint(bbox.maxX, f(t));
                                        }
                                    }
                                    continue;
                                }
                                var b2ac = Math.pow(b, 2) - 4 * c * a;
                                if (b2ac < 0) {
                                    continue;
                                }
                                var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                                if (0 < t1 && t1 < 1) {
                                    if (i === 0) {
                                        bbox.addPoint(f(t1), bbox.maxY);
                                    } else if (i === 1) {
                                        bbox.addPoint(bbox.maxX, f(t1));
                                    }
                                }
                                var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                                if (0 < t2 && t2 < 1) {
                                    if (i === 0) {
                                        bbox.addPoint(f(t2), bbox.maxY);
                                    } else if (i === 1) {
                                        bbox.addPoint(bbox.maxX, f(t2));
                                    }
                                }
                            }
                            cx = p3x;
                            cy = p3y;
                            break;
                        }
                    }
                    return this._bbox = _Object$freeze(bbox);
                }
            }
        ]);
        return Path;
    }();
var _arr = [
        'moveTo',
        'lineTo',
        'quadraticCurveTo',
        'bezierCurveTo',
        'closePath'
    ];
var _loop = function _loop() {
    var command = _arr[_i6];
    Path.prototype[command] = function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }
        this._bbox = this._cbox = null;
        this.commands.push({
            command: command,
            args: args
        });
        return this;
    };
};
for (var _i6 = 0; _i6 < _arr.length; _i6++) {
    _loop();
}
var StandardNames = [
        '.notdef',
        '.null',
        'nonmarkingreturn',
        'space',
        'exclam',
        'quotedbl',
        'numbersign',
        'dollar',
        'percent',
        'ampersand',
        'quotesingle',
        'parenleft',
        'parenright',
        'asterisk',
        'plus',
        'comma',
        'hyphen',
        'period',
        'slash',
        'zero',
        'one',
        'two',
        'three',
        'four',
        'five',
        'six',
        'seven',
        'eight',
        'nine',
        'colon',
        'semicolon',
        'less',
        'equal',
        'greater',
        'question',
        'at',
        'A',
        'B',
        'C',
        'D',
        'E',
        'F',
        'G',
        'H',
        'I',
        'J',
        'K',
        'L',
        'M',
        'N',
        'O',
        'P',
        'Q',
        'R',
        'S',
        'T',
        'U',
        'V',
        'W',
        'X',
        'Y',
        'Z',
        'bracketleft',
        'backslash',
        'bracketright',
        'asciicircum',
        'underscore',
        'grave',
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
        'braceleft',
        'bar',
        'braceright',
        'asciitilde',
        'Adieresis',
        'Aring',
        'Ccedilla',
        'Eacute',
        'Ntilde',
        'Odieresis',
        'Udieresis',
        'aacute',
        'agrave',
        'acircumflex',
        'adieresis',
        'atilde',
        'aring',
        'ccedilla',
        'eacute',
        'egrave',
        'ecircumflex',
        'edieresis',
        'iacute',
        'igrave',
        'icircumflex',
        'idieresis',
        'ntilde',
        'oacute',
        'ograve',
        'ocircumflex',
        'odieresis',
        'otilde',
        'uacute',
        'ugrave',
        'ucircumflex',
        'udieresis',
        'dagger',
        'degree',
        'cent',
        'sterling',
        'section',
        'bullet',
        'paragraph',
        'germandbls',
        'registered',
        'copyright',
        'trademark',
        'acute',
        'dieresis',
        'notequal',
        'AE',
        'Oslash',
        'infinity',
        'plusminus',
        'lessequal',
        'greaterequal',
        'yen',
        'mu',
        'partialdiff',
        'summation',
        'product',
        'pi',
        'integral',
        'ordfeminine',
        'ordmasculine',
        'Omega',
        'ae',
        'oslash',
        'questiondown',
        'exclamdown',
        'logicalnot',
        'radical',
        'florin',
        'approxequal',
        'Delta',
        'guillemotleft',
        'guillemotright',
        'ellipsis',
        'nonbreakingspace',
        'Agrave',
        'Atilde',
        'Otilde',
        'OE',
        'oe',
        'endash',
        'emdash',
        'quotedblleft',
        'quotedblright',
        'quoteleft',
        'quoteright',
        'divide',
        'lozenge',
        'ydieresis',
        'Ydieresis',
        'fraction',
        'currency',
        'guilsinglleft',
        'guilsinglright',
        'fi',
        'fl',
        'daggerdbl',
        'periodcentered',
        'quotesinglbase',
        'quotedblbase',
        'perthousand',
        'Acircumflex',
        'Ecircumflex',
        'Aacute',
        'Edieresis',
        'Egrave',
        'Iacute',
        'Icircumflex',
        'Idieresis',
        'Igrave',
        'Oacute',
        'Ocircumflex',
        'apple',
        'Ograve',
        'Uacute',
        'Ucircumflex',
        'Ugrave',
        'dotlessi',
        'circumflex',
        'tilde',
        'macron',
        'breve',
        'dotaccent',
        'ring',
        'cedilla',
        'hungarumlaut',
        'ogonek',
        'caron',
        'Lslash',
        'lslash',
        'Scaron',
        'scaron',
        'Zcaron',
        'zcaron',
        'brokenbar',
        'Eth',
        'eth',
        'Yacute',
        'yacute',
        'Thorn',
        'thorn',
        'minus',
        'multiply',
        'onesuperior',
        'twosuperior',
        'threesuperior',
        'onehalf',
        'onequarter',
        'threequarters',
        'franc',
        'Gbreve',
        'gbreve',
        'Idotaccent',
        'Scedilla',
        'scedilla',
        'Cacute',
        'cacute',
        'Ccaron',
        'ccaron',
        'dcroat'
    ];
var _class$8;
function _applyDecoratedDescriptor$4(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }
    return desc;
}
var Glyph = (_class$8 = function () {
        function Glyph(id, codePoints, font) {
            _classCallCheck(this, Glyph);
            this.id = id;
            this.codePoints = codePoints;
            this._font = font;
            this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);
            this.isLigature = this.codePoints.length > 1;
        }
        Glyph.prototype._getPath = function _getPath() {
            return new Path();
        };
        Glyph.prototype._getCBox = function _getCBox() {
            return this.path.cbox;
        };
        Glyph.prototype._getBBox = function _getBBox() {
            return this.path.bbox;
        };
        Glyph.prototype._getTableMetrics = function _getTableMetrics(table) {
            if (this.id < table.metrics.length) {
                return table.metrics.get(this.id);
            }
            var metric = table.metrics.get(table.metrics.length - 1);
            var res = {
                    advance: metric ? metric.advance : 0,
                    bearing: table.bearings.get(this.id - table.metrics.length) || 0
                };
            return res;
        };
        Glyph.prototype._getMetrics = function _getMetrics(cbox) {
            if (this._metrics) {
                return this._metrics;
            }
            var _getTableMetrics2 = this._getTableMetrics(this._font.hmtx), advanceWidth = _getTableMetrics2.advance, leftBearing = _getTableMetrics2.bearing;
            if (this._font.vmtx) {
                var _getTableMetrics3 = this._getTableMetrics(this._font.vmtx), advanceHeight = _getTableMetrics3.advance, topBearing = _getTableMetrics3.bearing;
            } else {
                var os2 = void 0;
                if (typeof cbox === 'undefined' || cbox === null) {
                    cbox = this.cbox;
                }
                if ((os2 = this._font['OS/2']) && os2.version > 0) {
                    var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
                    var topBearing = os2.typoAscender - cbox.maxY;
                } else {
                    var hhea = this._font.hhea;
                    var advanceHeight = Math.abs(hhea.ascent - hhea.descent);
                    var topBearing = hhea.ascent - cbox.maxY;
                }
            }
            if (this._font._variationProcessor && this._font.HVAR) {
                advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
            }
            return this._metrics = {
                advanceWidth: advanceWidth,
                advanceHeight: advanceHeight,
                leftBearing: leftBearing,
                topBearing: topBearing
            };
        };
        Glyph.prototype.getScaledPath = function getScaledPath(size) {
            var scale = 1 / this._font.unitsPerEm * size;
            return this.path.scale(scale);
        };
        Glyph.prototype._getName = function _getName() {
            var post = this._font.post;
            if (!post) {
                return null;
            }
            switch (post.version) {
            case 1:
                return StandardNames[this.id];
            case 2:
                var id = post.glyphNameIndex[this.id];
                if (id < StandardNames.length) {
                    return StandardNames[id];
                }
                return post.names[id - StandardNames.length];
            case 2.5:
                return StandardNames[this.id + post.offsets[this.id]];
            case 4:
                return String.fromCharCode(post.map[this.id]);
            }
        };
        Glyph.prototype.render = function render(ctx, size) {
            ctx.save();
            var scale = 1 / this._font.head.unitsPerEm * size;
            ctx.scale(scale, scale);
            var fn = this.path.toFunction();
            fn(ctx);
            ctx.fill();
            ctx.restore();
        };
        _createClass(Glyph, [
            {
                key: 'cbox',
                get: function get() {
                    return this._getCBox();
                }
            },
            {
                key: 'bbox',
                get: function get() {
                    return this._getBBox();
                }
            },
            {
                key: 'path',
                get: function get() {
                    return this._getPath();
                }
            },
            {
                key: 'advanceWidth',
                get: function get() {
                    return this._getMetrics().advanceWidth;
                }
            },
            {
                key: 'advanceHeight',
                get: function get() {
                    return this._getMetrics().advanceHeight;
                }
            },
            {
                key: 'ligatureCaretPositions',
                get: function get() {
                }
            },
            {
                key: 'name',
                get: function get() {
                    return this._getName();
                }
            }
        ]);
        return Glyph;
    }(), (_applyDecoratedDescriptor$4(_class$8.prototype, 'cbox', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'cbox'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'bbox', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'bbox'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'path', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'path'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'advanceWidth', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'advanceWidth'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'advanceHeight', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'advanceHeight'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'name', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'name'), _class$8.prototype)), _class$8);
var GlyfHeader = new r.Struct({
        numberOfContours: r.int16,
        xMin: r.int16,
        yMin: r.int16,
        xMax: r.int16,
        yMax: r.int16
    });
var ON_CURVE = 1 << 0;
var X_SHORT_VECTOR = 1 << 1;
var Y_SHORT_VECTOR = 1 << 2;
var REPEAT = 1 << 3;
var SAME_X = 1 << 4;
var SAME_Y = 1 << 5;
var ARG_1_AND_2_ARE_WORDS = 1 << 0;
var WE_HAVE_A_SCALE = 1 << 3;
var MORE_COMPONENTS = 1 << 5;
var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
var WE_HAVE_INSTRUCTIONS = 1 << 8;
var Point = function () {
        function Point(onCurve, endContour) {
            var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            _classCallCheck(this, Point);
            this.onCurve = onCurve;
            this.endContour = endContour;
            this.x = x;
            this.y = y;
        }
        Point.prototype.copy = function copy() {
            return new Point(this.onCurve, this.endContour, this.x, this.y);
        };
        return Point;
    }();
var Component = function Component(glyphID, dx, dy) {
    _classCallCheck(this, Component);
    this.glyphID = glyphID;
    this.dx = dx;
    this.dy = dy;
    this.pos = 0;
    this.scaleX = this.scaleY = 1;
    this.scale01 = this.scale10 = 0;
};
var TTFGlyph = function (_Glyph) {
        _inherits(TTFGlyph, _Glyph);
        function TTFGlyph() {
            _classCallCheck(this, TTFGlyph);
            return _possibleConstructorReturn(this, _Glyph.apply(this, arguments));
        }
        TTFGlyph.prototype._getCBox = function _getCBox(internal) {
            if (this._font._variationProcessor && !internal) {
                return this.path.cbox;
            }
            var stream = this._font._getTableStream('glyf');
            stream.pos += this._font.loca.offsets[this.id];
            var glyph = GlyfHeader.decode(stream);
            var cbox = new BBox(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
            return _Object$freeze(cbox);
        };
        TTFGlyph.prototype._parseGlyphCoord = function _parseGlyphCoord(stream, prev, short, same) {
            if (short) {
                var val = stream.readUInt8();
                if (!same) {
                    val = -val;
                }
                val += prev;
            } else {
                if (same) {
                    var val = prev;
                } else {
                    var val = prev + stream.readInt16BE();
                }
            }
            return val;
        };
        TTFGlyph.prototype._decode = function _decode() {
            var glyfPos = this._font.loca.offsets[this.id];
            var nextPos = this._font.loca.offsets[this.id + 1];
            if (glyfPos === nextPos) {
                return null;
            }
            var stream = this._font._getTableStream('glyf');
            stream.pos += glyfPos;
            var startPos = stream.pos;
            var glyph = GlyfHeader.decode(stream);
            if (glyph.numberOfContours > 0) {
                this._decodeSimple(glyph, stream);
            } else if (glyph.numberOfContours < 0) {
                this._decodeComposite(glyph, stream, startPos);
            }
            return glyph;
        };
        TTFGlyph.prototype._decodeSimple = function _decodeSimple(glyph, stream) {
            glyph.points = [];
            var endPtsOfContours = new r.Array(r.uint16, glyph.numberOfContours).decode(stream);
            glyph.instructions = new r.Array(r.uint8, r.uint16).decode(stream);
            var flags = [];
            var numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
            while (flags.length < numCoords) {
                var flag = stream.readUInt8();
                flags.push(flag);
                if (flag & REPEAT) {
                    var count = stream.readUInt8();
                    for (var j = 0; j < count; j++) {
                        flags.push(flag);
                    }
                }
            }
            for (var i = 0; i < flags.length; i++) {
                var flag = flags[i];
                var point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);
                glyph.points.push(point);
            }
            var px = 0;
            for (var i = 0; i < flags.length; i++) {
                var flag = flags[i];
                glyph.points[i].x = px = this._parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X);
            }
            var py = 0;
            for (var i = 0; i < flags.length; i++) {
                var flag = flags[i];
                glyph.points[i].y = py = this._parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y);
            }
            if (this._font._variationProcessor) {
                var points = glyph.points.slice();
                points.push.apply(points, this._getPhantomPoints(glyph));
                this._font._variationProcessor.transformPoints(this.id, points);
                glyph.phantomPoints = points.slice(-4);
            }
            return;
        };
        TTFGlyph.prototype._decodeComposite = function _decodeComposite(glyph, stream) {
            var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            glyph.components = [];
            var haveInstructions = false;
            var flags = MORE_COMPONENTS;
            while (flags & MORE_COMPONENTS) {
                flags = stream.readUInt16BE();
                var gPos = stream.pos - offset;
                var glyphID = stream.readUInt16BE();
                if (!haveInstructions) {
                    haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0;
                }
                if (flags & ARG_1_AND_2_ARE_WORDS) {
                    var dx = stream.readInt16BE();
                    var dy = stream.readInt16BE();
                } else {
                    var dx = stream.readInt8();
                    var dy = stream.readInt8();
                }
                var component = new Component(glyphID, dx, dy);
                component.pos = gPos;
                if (flags & WE_HAVE_A_SCALE) {
                    component.scaleX = component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
                    component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                    component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
                    component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                    component.scale01 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                    component.scale10 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                    component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                }
                glyph.components.push(component);
            }
            if (this._font._variationProcessor) {
                var points = [];
                for (var j = 0; j < glyph.components.length; j++) {
                    var component = glyph.components[j];
                    points.push(new Point(true, true, component.dx, component.dy));
                }
                points.push.apply(points, this._getPhantomPoints(glyph));
                this._font._variationProcessor.transformPoints(this.id, points);
                glyph.phantomPoints = points.splice(-4, 4);
                for (var i = 0; i < points.length; i++) {
                    var point = points[i];
                    glyph.components[i].dx = point.x;
                    glyph.components[i].dy = point.y;
                }
            }
            return haveInstructions;
        };
        TTFGlyph.prototype._getPhantomPoints = function _getPhantomPoints(glyph) {
            var cbox = this._getCBox(true);
            if (this._metrics == null) {
                this._metrics = Glyph.prototype._getMetrics.call(this, cbox);
            }
            var _metrics = this._metrics, advanceWidth = _metrics.advanceWidth, advanceHeight = _metrics.advanceHeight, leftBearing = _metrics.leftBearing, topBearing = _metrics.topBearing;
            return [
                new Point(false, true, glyph.xMin - leftBearing, 0),
                new Point(false, true, glyph.xMin - leftBearing + advanceWidth, 0),
                new Point(false, true, 0, glyph.yMax + topBearing),
                new Point(false, true, 0, glyph.yMax + topBearing + advanceHeight)
            ];
        };
        TTFGlyph.prototype._getContours = function _getContours() {
            var glyph = this._decode();
            if (!glyph) {
                return [];
            }
            var points = [];
            if (glyph.numberOfContours < 0) {
                for (var _iterator = glyph.components, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length)
                            break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done)
                            break;
                        _ref = _i.value;
                    }
                    var component = _ref;
                    var _contours = this._font.getGlyph(component.glyphID)._getContours();
                    for (var i = 0; i < _contours.length; i++) {
                        var contour = _contours[i];
                        for (var j = 0; j < contour.length; j++) {
                            var _point = contour[j];
                            var x = _point.x * component.scaleX + _point.y * component.scale01 + component.dx;
                            var y = _point.y * component.scaleY + _point.x * component.scale10 + component.dy;
                            points.push(new Point(_point.onCurve, _point.endContour, x, y));
                        }
                    }
                }
            } else {
                points = glyph.points || [];
            }
            if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {
                this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
                this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
                this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
                this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
            }
            var contours = [];
            var cur = [];
            for (var k = 0; k < points.length; k++) {
                var point = points[k];
                cur.push(point);
                if (point.endContour) {
                    contours.push(cur);
                    cur = [];
                }
            }
            return contours;
        };
        TTFGlyph.prototype._getMetrics = function _getMetrics() {
            if (this._metrics) {
                return this._metrics;
            }
            var cbox = this._getCBox(true);
            _Glyph.prototype._getMetrics.call(this, cbox);
            if (this._font._variationProcessor && !this._font.HVAR) {
                this.path;
            }
            return this._metrics;
        };
        TTFGlyph.prototype._getPath = function _getPath() {
            var contours = this._getContours();
            var path = new Path();
            for (var i = 0; i < contours.length; i++) {
                var contour = contours[i];
                var firstPt = contour[0];
                var lastPt = contour[contour.length - 1];
                var start = 0;
                if (firstPt.onCurve) {
                    var curvePt = null;
                    start = 1;
                } else {
                    if (lastPt.onCurve) {
                        firstPt = lastPt;
                    } else {
                        firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
                    }
                    var curvePt = firstPt;
                }
                path.moveTo(firstPt.x, firstPt.y);
                for (var j = start; j < contour.length; j++) {
                    var pt = contour[j];
                    var prevPt = j === 0 ? firstPt : contour[j - 1];
                    if (prevPt.onCurve && pt.onCurve) {
                        path.lineTo(pt.x, pt.y);
                    } else if (prevPt.onCurve && !pt.onCurve) {
                        var curvePt = pt;
                    } else if (!prevPt.onCurve && !pt.onCurve) {
                        var midX = (prevPt.x + pt.x) / 2;
                        var midY = (prevPt.y + pt.y) / 2;
                        path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
                        var curvePt = pt;
                    } else if (!prevPt.onCurve && pt.onCurve) {
                        path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                        var curvePt = null;
                    } else {
                        throw new Error('Unknown TTF path state');
                    }
                }
                if (curvePt) {
                    path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
                }
                path.closePath();
            }
            return path;
        };
        return TTFGlyph;
    }(Glyph);
var CFFGlyph = function (_Glyph) {
        _inherits(CFFGlyph, _Glyph);
        function CFFGlyph() {
            _classCallCheck(this, CFFGlyph);
            return _possibleConstructorReturn(this, _Glyph.apply(this, arguments));
        }
        CFFGlyph.prototype._getName = function _getName() {
            if (this._font.CFF2) {
                return _Glyph.prototype._getName.call(this);
            }
            return this._font['CFF '].getGlyphName(this.id);
        };
        CFFGlyph.prototype.bias = function bias(s) {
            if (s.length < 1240) {
                return 107;
            } else if (s.length < 33900) {
                return 1131;
            } else {
                return 32768;
            }
        };
        CFFGlyph.prototype._getPath = function _getPath() {
            var stream = this._font.stream;
            var pos = stream.pos;
            var cff = this._font.CFF2 || this._font['CFF '];
            var str = cff.topDict.CharStrings[this.id];
            var end = str.offset + str.length;
            stream.pos = str.offset;
            var path = new Path();
            var stack = [];
            var trans = [];
            var width = null;
            var nStems = 0;
            var x = 0, y = 0;
            var usedGsubrs = void 0;
            var usedSubrs = void 0;
            var open = false;
            this._usedGsubrs = usedGsubrs = {};
            this._usedSubrs = usedSubrs = {};
            var gsubrs = cff.globalSubrIndex || [];
            var gsubrsBias = this.bias(gsubrs);
            var privateDict = cff.privateDictForGlyph(this.id) || {};
            var subrs = privateDict.Subrs || [];
            var subrsBias = this.bias(subrs);
            var vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
            var vsindex = privateDict.vsindex;
            var variationProcessor = this._font._variationProcessor;
            function checkWidth() {
                if (width == null) {
                    width = stack.shift() + privateDict.nominalWidthX;
                }
            }
            function parseStems() {
                if (stack.length % 2 !== 0) {
                    checkWidth();
                }
                nStems += stack.length >> 1;
                return stack.length = 0;
            }
            function moveTo(x, y) {
                if (open) {
                    path.closePath();
                }
                path.moveTo(x, y);
                open = true;
            }
            var parse = function parse() {
                while (stream.pos < end) {
                    var op = stream.readUInt8();
                    if (op < 32) {
                        switch (op) {
                        case 1:
                        case 3:
                        case 18:
                        case 23:
                            parseStems();
                            break;
                        case 4:
                            if (stack.length > 1) {
                                checkWidth();
                            }
                            y += stack.shift();
                            moveTo(x, y);
                            break;
                        case 5:
                            while (stack.length >= 2) {
                                x += stack.shift();
                                y += stack.shift();
                                path.lineTo(x, y);
                            }
                            break;
                        case 6:
                        case 7:
                            var phase = op === 6;
                            while (stack.length >= 1) {
                                if (phase) {
                                    x += stack.shift();
                                } else {
                                    y += stack.shift();
                                }
                                path.lineTo(x, y);
                                phase = !phase;
                            }
                            break;
                        case 8:
                            while (stack.length > 0) {
                                var c1x = x + stack.shift();
                                var c1y = y + stack.shift();
                                var c2x = c1x + stack.shift();
                                var c2y = c1y + stack.shift();
                                x = c2x + stack.shift();
                                y = c2y + stack.shift();
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            }
                            break;
                        case 10:
                            var index = stack.pop() + subrsBias;
                            var subr = subrs[index];
                            if (subr) {
                                usedSubrs[index] = true;
                                var p = stream.pos;
                                var e = end;
                                stream.pos = subr.offset;
                                end = subr.offset + subr.length;
                                parse();
                                stream.pos = p;
                                end = e;
                            }
                            break;
                        case 11:
                            if (cff.version >= 2) {
                                break;
                            }
                            return;
                        case 14:
                            if (cff.version >= 2) {
                                break;
                            }
                            if (stack.length > 0) {
                                checkWidth();
                            }
                            if (open) {
                                path.closePath();
                                open = false;
                            }
                            break;
                        case 15: {
                                if (cff.version < 2) {
                                    throw new Error('vsindex operator not supported in CFF v1');
                                }
                                vsindex = stack.pop();
                                break;
                            }
                        case 16: {
                                if (cff.version < 2) {
                                    throw new Error('blend operator not supported in CFF v1');
                                }
                                if (!variationProcessor) {
                                    throw new Error('blend operator in non-variation font');
                                }
                                var blendVector = variationProcessor.getBlendVector(vstore, vsindex);
                                var numBlends = stack.pop();
                                var numOperands = numBlends * blendVector.length;
                                var delta = stack.length - numOperands;
                                var base = delta - numBlends;
                                for (var i = 0; i < numBlends; i++) {
                                    var sum = stack[base + i];
                                    for (var j = 0; j < blendVector.length; j++) {
                                        sum += blendVector[j] * stack[delta++];
                                    }
                                    stack[base + i] = sum;
                                }
                                while (numOperands--) {
                                    stack.pop();
                                }
                                break;
                            }
                        case 19:
                        case 20:
                            parseStems();
                            stream.pos += nStems + 7 >> 3;
                            break;
                        case 21:
                            if (stack.length > 2) {
                                checkWidth();
                            }
                            x += stack.shift();
                            y += stack.shift();
                            moveTo(x, y);
                            break;
                        case 22:
                            if (stack.length > 1) {
                                checkWidth();
                            }
                            x += stack.shift();
                            moveTo(x, y);
                            break;
                        case 24:
                            while (stack.length >= 8) {
                                var c1x = x + stack.shift();
                                var c1y = y + stack.shift();
                                var c2x = c1x + stack.shift();
                                var c2y = c1y + stack.shift();
                                x = c2x + stack.shift();
                                y = c2y + stack.shift();
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            }
                            x += stack.shift();
                            y += stack.shift();
                            path.lineTo(x, y);
                            break;
                        case 25:
                            while (stack.length >= 8) {
                                x += stack.shift();
                                y += stack.shift();
                                path.lineTo(x, y);
                            }
                            var c1x = x + stack.shift();
                            var c1y = y + stack.shift();
                            var c2x = c1x + stack.shift();
                            var c2y = c1y + stack.shift();
                            x = c2x + stack.shift();
                            y = c2y + stack.shift();
                            path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            break;
                        case 26:
                            if (stack.length % 2) {
                                x += stack.shift();
                            }
                            while (stack.length >= 4) {
                                c1x = x;
                                c1y = y + stack.shift();
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                x = c2x;
                                y = c2y + stack.shift();
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            }
                            break;
                        case 27:
                            if (stack.length % 2) {
                                y += stack.shift();
                            }
                            while (stack.length >= 4) {
                                c1x = x + stack.shift();
                                c1y = y;
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                x = c2x + stack.shift();
                                y = c2y;
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            }
                            break;
                        case 28:
                            stack.push(stream.readInt16BE());
                            break;
                        case 29:
                            index = stack.pop() + gsubrsBias;
                            subr = gsubrs[index];
                            if (subr) {
                                usedGsubrs[index] = true;
                                var p = stream.pos;
                                var e = end;
                                stream.pos = subr.offset;
                                end = subr.offset + subr.length;
                                parse();
                                stream.pos = p;
                                end = e;
                            }
                            break;
                        case 30:
                        case 31:
                            phase = op === 31;
                            while (stack.length >= 4) {
                                if (phase) {
                                    c1x = x + stack.shift();
                                    c1y = y;
                                    c2x = c1x + stack.shift();
                                    c2y = c1y + stack.shift();
                                    y = c2y + stack.shift();
                                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                                } else {
                                    c1x = x;
                                    c1y = y + stack.shift();
                                    c2x = c1x + stack.shift();
                                    c2y = c1y + stack.shift();
                                    x = c2x + stack.shift();
                                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                                }
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                                phase = !phase;
                            }
                            break;
                        case 12:
                            op = stream.readUInt8();
                            switch (op) {
                            case 3:
                                var a = stack.pop();
                                var b = stack.pop();
                                stack.push(a && b ? 1 : 0);
                                break;
                            case 4:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a || b ? 1 : 0);
                                break;
                            case 5:
                                a = stack.pop();
                                stack.push(a ? 0 : 1);
                                break;
                            case 9:
                                a = stack.pop();
                                stack.push(Math.abs(a));
                                break;
                            case 10:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a + b);
                                break;
                            case 11:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a - b);
                                break;
                            case 12:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a / b);
                                break;
                            case 14:
                                a = stack.pop();
                                stack.push(-a);
                                break;
                            case 15:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a === b ? 1 : 0);
                                break;
                            case 18:
                                stack.pop();
                                break;
                            case 20:
                                var val = stack.pop();
                                var idx = stack.pop();
                                trans[idx] = val;
                                break;
                            case 21:
                                idx = stack.pop();
                                stack.push(trans[idx] || 0);
                                break;
                            case 22:
                                var s1 = stack.pop();
                                var s2 = stack.pop();
                                var v1 = stack.pop();
                                var v2 = stack.pop();
                                stack.push(v1 <= v2 ? s1 : s2);
                                break;
                            case 23:
                                stack.push(Math.random());
                                break;
                            case 24:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a * b);
                                break;
                            case 26:
                                a = stack.pop();
                                stack.push(Math.sqrt(a));
                                break;
                            case 27:
                                a = stack.pop();
                                stack.push(a, a);
                                break;
                            case 28:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(b, a);
                                break;
                            case 29:
                                idx = stack.pop();
                                if (idx < 0) {
                                    idx = 0;
                                } else if (idx > stack.length - 1) {
                                    idx = stack.length - 1;
                                }
                                stack.push(stack[idx]);
                                break;
                            case 30:
                                var n = stack.pop();
                                var _j = stack.pop();
                                if (_j >= 0) {
                                    while (_j > 0) {
                                        var t = stack[n - 1];
                                        for (var _i = n - 2; _i >= 0; _i--) {
                                            stack[_i + 1] = stack[_i];
                                        }
                                        stack[0] = t;
                                        _j--;
                                    }
                                } else {
                                    while (_j < 0) {
                                        var t = stack[0];
                                        for (var _i2 = 0; _i2 <= n; _i2++) {
                                            stack[_i2] = stack[_i2 + 1];
                                        }
                                        stack[n - 1] = t;
                                        _j++;
                                    }
                                }
                                break;
                            case 34:
                                c1x = x + stack.shift();
                                c1y = y;
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                var c3x = c2x + stack.shift();
                                var c3y = c2y;
                                var c4x = c3x + stack.shift();
                                var c4y = c3y;
                                var c5x = c4x + stack.shift();
                                var c5y = c4y;
                                var c6x = c5x + stack.shift();
                                var c6y = c5y;
                                x = c6x;
                                y = c6y;
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                                path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                                break;
                            case 35:
                                var pts = [];
                                for (var _i3 = 0; _i3 <= 5; _i3++) {
                                    x += stack.shift();
                                    y += stack.shift();
                                    pts.push(x, y);
                                }
                                path.bezierCurveTo.apply(path, pts.slice(0, 6));
                                path.bezierCurveTo.apply(path, pts.slice(6));
                                stack.shift();
                                break;
                            case 36:
                                c1x = x + stack.shift();
                                c1y = y + stack.shift();
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                c3x = c2x + stack.shift();
                                c3y = c2y;
                                c4x = c3x + stack.shift();
                                c4y = c3y;
                                c5x = c4x + stack.shift();
                                c5y = c4y + stack.shift();
                                c6x = c5x + stack.shift();
                                c6y = c5y;
                                x = c6x;
                                y = c6y;
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                                path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                                break;
                            case 37:
                                var startx = x;
                                var starty = y;
                                pts = [];
                                for (var _i4 = 0; _i4 <= 4; _i4++) {
                                    x += stack.shift();
                                    y += stack.shift();
                                    pts.push(x, y);
                                }
                                if (Math.abs(x - startx) > Math.abs(y - starty)) {
                                    x += stack.shift();
                                    y = starty;
                                } else {
                                    x = startx;
                                    y += stack.shift();
                                }
                                pts.push(x, y);
                                path.bezierCurveTo.apply(path, pts.slice(0, 6));
                                path.bezierCurveTo.apply(path, pts.slice(6));
                                break;
                            default:
                                throw new Error('Unknown op: 12 ' + op);
                            }
                            break;
                        default:
                            throw new Error('Unknown op: ' + op);
                        }
                    } else if (op < 247) {
                        stack.push(op - 139);
                    } else if (op < 251) {
                        var b1 = stream.readUInt8();
                        stack.push((op - 247) * 256 + b1 + 108);
                    } else if (op < 255) {
                        var b1 = stream.readUInt8();
                        stack.push(-(op - 251) * 256 - b1 - 108);
                    } else {
                        stack.push(stream.readInt32BE() / 65536);
                    }
                }
            };
            parse();
            if (open) {
                path.closePath();
            }
            return path;
        };
        return CFFGlyph;
    }(Glyph);
var SBIXImage = new r.Struct({
        originX: r.uint16,
        originY: r.uint16,
        type: new r.String(4),
        data: new r.Buffer(function (t) {
            return t.parent.buflen - t._currentOffset;
        })
    });
var SBIXGlyph = function (_TTFGlyph) {
        _inherits(SBIXGlyph, _TTFGlyph);
        function SBIXGlyph() {
            _classCallCheck(this, SBIXGlyph);
            return _possibleConstructorReturn(this, _TTFGlyph.apply(this, arguments));
        }
        SBIXGlyph.prototype.getImageForSize = function getImageForSize(size) {
            for (var i = 0; i < this._font.sbix.imageTables.length; i++) {
                var table = this._font.sbix.imageTables[i];
                if (table.ppem >= size) {
                    break;
                }
            }
            var offsets = table.imageOffsets;
            var start = offsets[this.id];
            var end = offsets[this.id + 1];
            if (start === end) {
                return null;
            }
            this._font.stream.pos = start;
            return SBIXImage.decode(this._font.stream, { buflen: end - start });
        };
        SBIXGlyph.prototype.render = function render(ctx, size) {
            var img = this.getImageForSize(size);
            if (img != null) {
                var scale = size / this._font.unitsPerEm;
                ctx.image(img.data, {
                    height: size,
                    x: img.originX,
                    y: (this.bbox.minY - img.originY) * scale
                });
            }
            if (this._font.sbix.flags.renderOutlines) {
                _TTFGlyph.prototype.render.call(this, ctx, size);
            }
        };
        return SBIXGlyph;
    }(TTFGlyph);
var COLRLayer = function COLRLayer(glyph, color) {
    _classCallCheck(this, COLRLayer);
    this.glyph = glyph;
    this.color = color;
};
var COLRGlyph = function (_Glyph) {
        _inherits(COLRGlyph, _Glyph);
        function COLRGlyph() {
            _classCallCheck(this, COLRGlyph);
            return _possibleConstructorReturn(this, _Glyph.apply(this, arguments));
        }
        COLRGlyph.prototype._getBBox = function _getBBox() {
            var bbox = new BBox();
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                var b = layer.glyph.bbox;
                bbox.addPoint(b.minX, b.minY);
                bbox.addPoint(b.maxX, b.maxY);
            }
            return bbox;
        };
        COLRGlyph.prototype.render = function render(ctx, size) {
            for (var _iterator = this.layers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var _ref2 = _ref, glyph = _ref2.glyph, color = _ref2.color;
                ctx.fillColor([
                    color.red,
                    color.green,
                    color.blue
                ], color.alpha / 255 * 100);
                glyph.render(ctx, size);
            }
            return;
        };
        _createClass(COLRGlyph, [{
                key: 'layers',
                get: function get() {
                    var cpal = this._font.CPAL;
                    var colr = this._font.COLR;
                    var low = 0;
                    var high = colr.baseGlyphRecord.length - 1;
                    while (low <= high) {
                        var mid = low + high >> 1;
                        var rec = colr.baseGlyphRecord[mid];
                        if (this.id < rec.gid) {
                            high = mid - 1;
                        } else if (this.id > rec.gid) {
                            low = mid + 1;
                        } else {
                            var baseLayer = rec;
                            break;
                        }
                    }
                    if (baseLayer == null) {
                        var g = this._font._getBaseGlyph(this.id);
                        var color = {
                                red: 0,
                                green: 0,
                                blue: 0,
                                alpha: 255
                            };
                        return [new COLRLayer(g, color)];
                    }
                    var layers = [];
                    for (var i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {
                        var rec = colr.layerRecords[i];
                        var color = cpal.colorRecords[rec.paletteIndex];
                        var g = this._font._getBaseGlyph(rec.gid);
                        layers.push(new COLRLayer(g, color));
                    }
                    return layers;
                }
            }]);
        return COLRGlyph;
    }(Glyph);
var TUPLES_SHARE_POINT_NUMBERS = 32768;
var TUPLE_COUNT_MASK = 4095;
var EMBEDDED_TUPLE_COORD = 32768;
var INTERMEDIATE_TUPLE = 16384;
var PRIVATE_POINT_NUMBERS = 8192;
var TUPLE_INDEX_MASK = 4095;
var POINTS_ARE_WORDS = 128;
var POINT_RUN_COUNT_MASK = 127;
var DELTAS_ARE_ZERO = 128;
var DELTAS_ARE_WORDS = 64;
var DELTA_RUN_COUNT_MASK = 63;
var GlyphVariationProcessor = function () {
        function GlyphVariationProcessor(font, coords) {
            _classCallCheck(this, GlyphVariationProcessor);
            this.font = font;
            this.normalizedCoords = this.normalizeCoords(coords);
            this.blendVectors = new _Map();
        }
        GlyphVariationProcessor.prototype.normalizeCoords = function normalizeCoords(coords) {
            var normalized = [];
            for (var i = 0; i < this.font.fvar.axis.length; i++) {
                var axis = this.font.fvar.axis[i];
                if (coords[i] < axis.defaultValue) {
                    normalized.push((coords[i] - axis.defaultValue + _Number$EPSILON) / (axis.defaultValue - axis.minValue + _Number$EPSILON));
                } else {
                    normalized.push((coords[i] - axis.defaultValue + _Number$EPSILON) / (axis.maxValue - axis.defaultValue + _Number$EPSILON));
                }
            }
            if (this.font.avar) {
                for (var i = 0; i < this.font.avar.segment.length; i++) {
                    var segment = this.font.avar.segment[i];
                    for (var j = 0; j < segment.correspondence.length; j++) {
                        var pair = segment.correspondence[j];
                        if (j >= 1 && normalized[i] < pair.fromCoord) {
                            var prev = segment.correspondence[j - 1];
                            normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + _Number$EPSILON) / (pair.fromCoord - prev.fromCoord + _Number$EPSILON) + prev.toCoord;
                            break;
                        }
                    }
                }
            }
            return normalized;
        };
        GlyphVariationProcessor.prototype.transformPoints = function transformPoints(gid, glyphPoints) {
            if (!this.font.fvar || !this.font.gvar) {
                return;
            }
            var gvar = this.font.gvar;
            if (gid >= gvar.glyphCount) {
                return;
            }
            var offset = gvar.offsets[gid];
            if (offset === gvar.offsets[gid + 1]) {
                return;
            }
            var stream = this.font.stream;
            stream.pos = offset;
            if (stream.pos >= stream.length) {
                return;
            }
            var tupleCount = stream.readUInt16BE();
            var offsetToData = offset + stream.readUInt16BE();
            if (tupleCount & TUPLES_SHARE_POINT_NUMBERS) {
                var here = stream.pos;
                stream.pos = offsetToData;
                var sharedPoints = this.decodePoints();
                offsetToData = stream.pos;
                stream.pos = here;
            }
            var origPoints = glyphPoints.map(function (pt) {
                    return pt.copy();
                });
            tupleCount &= TUPLE_COUNT_MASK;
            for (var i = 0; i < tupleCount; i++) {
                var tupleDataSize = stream.readUInt16BE();
                var tupleIndex = stream.readUInt16BE();
                if (tupleIndex & EMBEDDED_TUPLE_COORD) {
                    var tupleCoords = [];
                    for (var a = 0; a < gvar.axisCount; a++) {
                        tupleCoords.push(stream.readInt16BE() / 16384);
                    }
                } else {
                    if ((tupleIndex & TUPLE_INDEX_MASK) >= gvar.globalCoordCount) {
                        throw new Error('Invalid gvar table');
                    }
                    var tupleCoords = gvar.globalCoords[tupleIndex & TUPLE_INDEX_MASK];
                }
                if (tupleIndex & INTERMEDIATE_TUPLE) {
                    var startCoords = [];
                    for (var _a = 0; _a < gvar.axisCount; _a++) {
                        startCoords.push(stream.readInt16BE() / 16384);
                    }
                    var endCoords = [];
                    for (var _a2 = 0; _a2 < gvar.axisCount; _a2++) {
                        endCoords.push(stream.readInt16BE() / 16384);
                    }
                }
                var factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
                if (factor === 0) {
                    offsetToData += tupleDataSize;
                    continue;
                }
                var here = stream.pos;
                stream.pos = offsetToData;
                if (tupleIndex & PRIVATE_POINT_NUMBERS) {
                    var points = this.decodePoints();
                } else {
                    var points = sharedPoints;
                }
                var nPoints = points.length === 0 ? glyphPoints.length : points.length;
                var xDeltas = this.decodeDeltas(nPoints);
                var yDeltas = this.decodeDeltas(nPoints);
                if (points.length === 0) {
                    for (var _i = 0; _i < glyphPoints.length; _i++) {
                        var point = glyphPoints[_i];
                        point.x += Math.round(xDeltas[_i] * factor);
                        point.y += Math.round(yDeltas[_i] * factor);
                    }
                } else {
                    var outPoints = origPoints.map(function (pt) {
                            return pt.copy();
                        });
                    var hasDelta = glyphPoints.map(function () {
                            return false;
                        });
                    for (var _i2 = 0; _i2 < points.length; _i2++) {
                        var idx = points[_i2];
                        if (idx < glyphPoints.length) {
                            var _point = outPoints[idx];
                            hasDelta[idx] = true;
                            _point.x += Math.round(xDeltas[_i2] * factor);
                            _point.y += Math.round(yDeltas[_i2] * factor);
                        }
                    }
                    this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
                    for (var _i3 = 0; _i3 < glyphPoints.length; _i3++) {
                        var deltaX = outPoints[_i3].x - origPoints[_i3].x;
                        var deltaY = outPoints[_i3].y - origPoints[_i3].y;
                        glyphPoints[_i3].x += deltaX;
                        glyphPoints[_i3].y += deltaY;
                    }
                }
                offsetToData += tupleDataSize;
                stream.pos = here;
            }
        };
        GlyphVariationProcessor.prototype.decodePoints = function decodePoints() {
            var stream = this.font.stream;
            var count = stream.readUInt8();
            if (count & POINTS_ARE_WORDS) {
                count = (count & POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8();
            }
            var points = new Uint16Array(count);
            var i = 0;
            var point = 0;
            while (i < count) {
                var run = stream.readUInt8();
                var runCount = (run & POINT_RUN_COUNT_MASK) + 1;
                var fn = run & POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;
                for (var j = 0; j < runCount && i < count; j++) {
                    point += fn.call(stream);
                    points[i++] = point;
                }
            }
            return points;
        };
        GlyphVariationProcessor.prototype.decodeDeltas = function decodeDeltas(count) {
            var stream = this.font.stream;
            var i = 0;
            var deltas = new Int16Array(count);
            while (i < count) {
                var run = stream.readUInt8();
                var runCount = (run & DELTA_RUN_COUNT_MASK) + 1;
                if (run & DELTAS_ARE_ZERO) {
                    i += runCount;
                } else {
                    var fn = run & DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;
                    for (var j = 0; j < runCount && i < count; j++) {
                        deltas[i++] = fn.call(stream);
                    }
                }
            }
            return deltas;
        };
        GlyphVariationProcessor.prototype.tupleFactor = function tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
            var normalized = this.normalizedCoords;
            var gvar = this.font.gvar;
            var factor = 1;
            for (var i = 0; i < gvar.axisCount; i++) {
                if (tupleCoords[i] === 0) {
                    continue;
                }
                if (normalized[i] === 0) {
                    return 0;
                }
                if ((tupleIndex & INTERMEDIATE_TUPLE) === 0) {
                    if (normalized[i] < Math.min(0, tupleCoords[i]) || normalized[i] > Math.max(0, tupleCoords[i])) {
                        return 0;
                    }
                    factor = (factor * normalized[i] + _Number$EPSILON) / (tupleCoords[i] + _Number$EPSILON);
                } else {
                    if (normalized[i] < startCoords[i] || normalized[i] > endCoords[i]) {
                        return 0;
                    } else if (normalized[i] < tupleCoords[i]) {
                        factor = factor * (normalized[i] - startCoords[i] + _Number$EPSILON) / (tupleCoords[i] - startCoords[i] + _Number$EPSILON);
                    } else {
                        factor = factor * (endCoords[i] - normalized[i] + _Number$EPSILON) / (endCoords[i] - tupleCoords[i] + _Number$EPSILON);
                    }
                }
            }
            return factor;
        };
        GlyphVariationProcessor.prototype.interpolateMissingDeltas = function interpolateMissingDeltas(points, inPoints, hasDelta) {
            if (points.length === 0) {
                return;
            }
            var point = 0;
            while (point < points.length) {
                var firstPoint = point;
                var endPoint = point;
                var pt = points[endPoint];
                while (!pt.endContour) {
                    pt = points[++endPoint];
                }
                while (point <= endPoint && !hasDelta[point]) {
                    point++;
                }
                if (point > endPoint) {
                    continue;
                }
                var firstDelta = point;
                var curDelta = point;
                point++;
                while (point <= endPoint) {
                    if (hasDelta[point]) {
                        this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
                        curDelta = point;
                    }
                    point++;
                }
                if (curDelta === firstDelta) {
                    this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
                } else {
                    this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
                    if (firstDelta > 0) {
                        this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
                    }
                }
                point = endPoint + 1;
            }
        };
        GlyphVariationProcessor.prototype.deltaInterpolate = function deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {
            if (p1 > p2) {
                return;
            }
            var iterable = [
                    'x',
                    'y'
                ];
            for (var i = 0; i < iterable.length; i++) {
                var k = iterable[i];
                if (inPoints[ref1][k] > inPoints[ref2][k]) {
                    var p = ref1;
                    ref1 = ref2;
                    ref2 = p;
                }
                var in1 = inPoints[ref1][k];
                var in2 = inPoints[ref2][k];
                var out1 = outPoints[ref1][k];
                var out2 = outPoints[ref2][k];
                if (in1 !== in2 || out1 === out2) {
                    var scale = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
                    for (var _p = p1; _p <= p2; _p++) {
                        var out = inPoints[_p][k];
                        if (out <= in1) {
                            out += out1 - in1;
                        } else if (out >= in2) {
                            out += out2 - in2;
                        } else {
                            out = out1 + (out - in1) * scale;
                        }
                        outPoints[_p][k] = out;
                    }
                }
            }
        };
        GlyphVariationProcessor.prototype.deltaShift = function deltaShift(p1, p2, ref, inPoints, outPoints) {
            var deltaX = outPoints[ref].x - inPoints[ref].x;
            var deltaY = outPoints[ref].y - inPoints[ref].y;
            if (deltaX === 0 && deltaY === 0) {
                return;
            }
            for (var p = p1; p <= p2; p++) {
                if (p !== ref) {
                    outPoints[p].x += deltaX;
                    outPoints[p].y += deltaY;
                }
            }
        };
        GlyphVariationProcessor.prototype.getAdvanceAdjustment = function getAdvanceAdjustment(gid, table) {
            var outerIndex = void 0, innerIndex = void 0;
            if (table.advanceWidthMapping) {
                var idx = gid;
                if (idx >= table.advanceWidthMapping.mapCount) {
                    idx = table.advanceWidthMapping.mapCount - 1;
                }
                var entryFormat = table.advanceWidthMapping.entryFormat;
                var _table$advanceWidthMa = table.advanceWidthMapping.mapData[idx];
                outerIndex = _table$advanceWidthMa.outerIndex;
                innerIndex = _table$advanceWidthMa.innerIndex;
            } else {
                outerIndex = 0;
                innerIndex = gid;
            }
            return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);
        };
        GlyphVariationProcessor.prototype.getDelta = function getDelta(itemStore, outerIndex, innerIndex) {
            if (outerIndex >= itemStore.itemVariationData.length) {
                return 0;
            }
            var varData = itemStore.itemVariationData[outerIndex];
            if (innerIndex >= varData.deltaSets.length) {
                return 0;
            }
            var deltaSet = varData.deltaSets[innerIndex];
            var blendVector = this.getBlendVector(itemStore, outerIndex);
            var netAdjustment = 0;
            for (var master = 0; master < varData.regionIndexCount; master++) {
                netAdjustment += deltaSet.deltas[master] * blendVector[master];
            }
            return netAdjustment;
        };
        GlyphVariationProcessor.prototype.getBlendVector = function getBlendVector(itemStore, outerIndex) {
            var varData = itemStore.itemVariationData[outerIndex];
            if (this.blendVectors.has(varData)) {
                return this.blendVectors.get(varData);
            }
            var normalizedCoords = this.normalizedCoords;
            var blendVector = [];
            for (var master = 0; master < varData.regionIndexCount; master++) {
                var scalar = 1;
                var regionIndex = varData.regionIndexes[master];
                var axes = itemStore.variationRegionList.variationRegions[regionIndex];
                for (var j = 0; j < axes.length; j++) {
                    var axis = axes[j];
                    var axisScalar = void 0;
                    if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) {
                        axisScalar = 1;
                    } else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) {
                        axisScalar = 1;
                    } else if (axis.peakCoord === 0) {
                        axisScalar = 1;
                    } else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) {
                        axisScalar = 0;
                    } else {
                        if (normalizedCoords[j] === axis.peakCoord) {
                            axisScalar = 1;
                        } else if (normalizedCoords[j] < axis.peakCoord) {
                            axisScalar = (normalizedCoords[j] - axis.startCoord + _Number$EPSILON) / (axis.peakCoord - axis.startCoord + _Number$EPSILON);
                        } else {
                            axisScalar = (axis.endCoord - normalizedCoords[j] + _Number$EPSILON) / (axis.endCoord - axis.peakCoord + _Number$EPSILON);
                        }
                    }
                    scalar *= axisScalar;
                }
                blendVector[master] = scalar;
            }
            this.blendVectors.set(varData, blendVector);
            return blendVector;
        };
        return GlyphVariationProcessor;
    }();
var Subset = function () {
        function Subset(font) {
            _classCallCheck(this, Subset);
            this.font = font;
            this.glyphs = [];
            this.mapping = {};
            this.includeGlyph(0);
        }
        Subset.prototype.includeGlyph = function includeGlyph(glyph) {
            if ((typeof glyph === 'undefined' ? 'undefined' : _typeof(glyph)) === 'object') {
                glyph = glyph.id;
            }
            if (this.mapping[glyph] == null) {
                this.glyphs.push(glyph);
                this.mapping[glyph] = this.glyphs.length - 1;
            }
            return this.mapping[glyph];
        };
        Subset.prototype.encodeStream = function encodeStream() {
            var _this = this;
            var s = new r.EncodeStream();
            process.nextTick(function () {
                _this.encode(s);
                return s.end();
            });
            return s;
        };
        return Subset;
    }();
var ON_CURVE$1 = 1 << 0;
var X_SHORT_VECTOR$1 = 1 << 1;
var Y_SHORT_VECTOR$1 = 1 << 2;
var REPEAT$1 = 1 << 3;
var SAME_X$1 = 1 << 4;
var SAME_Y$1 = 1 << 5;
var Point$1 = function () {
        function Point() {
            _classCallCheck(this, Point);
        }
        Point.size = function size(val) {
            return val >= 0 && val <= 255 ? 1 : 2;
        };
        Point.encode = function encode(stream, value) {
            if (value >= 0 && value <= 255) {
                stream.writeUInt8(value);
            } else {
                stream.writeInt16BE(value);
            }
        };
        return Point;
    }();
var Glyf = new r.Struct({
        numberOfContours: r.int16,
        xMin: r.int16,
        yMin: r.int16,
        xMax: r.int16,
        yMax: r.int16,
        endPtsOfContours: new r.Array(r.uint16, 'numberOfContours'),
        instructions: new r.Array(r.uint8, r.uint16),
        flags: new r.Array(r.uint8, 0),
        xPoints: new r.Array(Point$1, 0),
        yPoints: new r.Array(Point$1, 0)
    });
var TTFGlyphEncoder = function () {
        function TTFGlyphEncoder() {
            _classCallCheck(this, TTFGlyphEncoder);
        }
        TTFGlyphEncoder.prototype.encodeSimple = function encodeSimple(path) {
            var instructions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            var endPtsOfContours = [];
            var xPoints = [];
            var yPoints = [];
            var flags = [];
            var same = 0;
            var lastX = 0, lastY = 0, lastFlag = 0;
            var pointCount = 0;
            for (var i = 0; i < path.commands.length; i++) {
                var c = path.commands[i];
                for (var j = 0; j < c.args.length; j += 2) {
                    var x = c.args[j];
                    var y = c.args[j + 1];
                    var flag = 0;
                    if (c.command === 'quadraticCurveTo' && j === 2) {
                        var next = path.commands[i + 1];
                        if (next && next.command === 'quadraticCurveTo') {
                            var midX = (lastX + next.args[0]) / 2;
                            var midY = (lastY + next.args[1]) / 2;
                            if (x === midX && y === midY) {
                                continue;
                            }
                        }
                    }
                    if (!(c.command === 'quadraticCurveTo' && j === 0)) {
                        flag |= ON_CURVE$1;
                    }
                    flag = this._encodePoint(x, lastX, xPoints, flag, X_SHORT_VECTOR$1, SAME_X$1);
                    flag = this._encodePoint(y, lastY, yPoints, flag, Y_SHORT_VECTOR$1, SAME_Y$1);
                    if (flag === lastFlag && same < 255) {
                        flags[flags.length - 1] |= REPEAT$1;
                        same++;
                    } else {
                        if (same > 0) {
                            flags.push(same);
                            same = 0;
                        }
                        flags.push(flag);
                        lastFlag = flag;
                    }
                    lastX = x;
                    lastY = y;
                    pointCount++;
                }
                if (c.command === 'closePath') {
                    endPtsOfContours.push(pointCount - 1);
                }
            }
            if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== 'closePath') {
                endPtsOfContours.push(pointCount - 1);
            }
            var bbox = path.bbox;
            var glyf = {
                    numberOfContours: endPtsOfContours.length,
                    xMin: bbox.minX,
                    yMin: bbox.minY,
                    xMax: bbox.maxX,
                    yMax: bbox.maxY,
                    endPtsOfContours: endPtsOfContours,
                    instructions: instructions,
                    flags: flags,
                    xPoints: xPoints,
                    yPoints: yPoints
                };
            var size = Glyf.size(glyf);
            var tail = 4 - size % 4;
            var stream = new r.EncodeStream(size + tail);
            Glyf.encode(stream, glyf);
            if (tail !== 0) {
                stream.fill(0, tail);
            }
            return stream.buffer;
        };
        TTFGlyphEncoder.prototype._encodePoint = function _encodePoint(value, last, points, flag, shortFlag, sameFlag) {
            var diff = value - last;
            if (value === last) {
                flag |= sameFlag;
            } else {
                if (-255 <= diff && diff <= 255) {
                    flag |= shortFlag;
                    if (diff < 0) {
                        diff = -diff;
                    } else {
                        flag |= sameFlag;
                    }
                }
                points.push(diff);
            }
            return flag;
        };
        return TTFGlyphEncoder;
    }();
var TTFSubset = function (_Subset) {
        _inherits(TTFSubset, _Subset);
        function TTFSubset(font) {
            _classCallCheck(this, TTFSubset);
            var _this = _possibleConstructorReturn(this, _Subset.call(this, font));
            _this.glyphEncoder = new TTFGlyphEncoder();
            return _this;
        }
        TTFSubset.prototype._addGlyph = function _addGlyph(gid) {
            var glyph = this.font.getGlyph(gid);
            var glyf = glyph._decode();
            var curOffset = this.font.loca.offsets[gid];
            var nextOffset = this.font.loca.offsets[gid + 1];
            var stream = this.font._getTableStream('glyf');
            stream.pos += curOffset;
            var buffer = stream.readBuffer(nextOffset - curOffset);
            if (glyf && glyf.numberOfContours < 0) {
                buffer = new Buffer(buffer);
                for (var _iterator = glyf.components, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length)
                            break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done)
                            break;
                        _ref = _i.value;
                    }
                    var component = _ref;
                    gid = this.includeGlyph(component.glyphID);
                    buffer.writeUInt16BE(gid, component.pos);
                }
            } else if (glyf && this.font._variationProcessor) {
                buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);
            }
            this.glyf.push(buffer);
            this.loca.offsets.push(this.offset);
            this.hmtx.metrics.push({
                advance: glyph.advanceWidth,
                bearing: glyph._getMetrics().leftBearing
            });
            this.offset += buffer.length;
            return this.glyf.length - 1;
        };
        TTFSubset.prototype.encode = function encode(stream) {
            this.glyf = [];
            this.offset = 0;
            this.loca = {
                offsets: [],
                version: this.font.loca.version
            };
            this.hmtx = {
                metrics: [],
                bearings: []
            };
            var i = 0;
            while (i < this.glyphs.length) {
                this._addGlyph(this.glyphs[i++]);
            }
            var maxp = cloneDeep(this.font.maxp);
            maxp.numGlyphs = this.glyf.length;
            this.loca.offsets.push(this.offset);
            var head = cloneDeep(this.font.head);
            head.indexToLocFormat = this.loca.version;
            var hhea = cloneDeep(this.font.hhea);
            hhea.numberOfMetrics = this.hmtx.metrics.length;
            Directory.encode(stream, {
                tables: {
                    head: head,
                    hhea: hhea,
                    loca: this.loca,
                    maxp: maxp,
                    'cvt ': this.font['cvt '],
                    prep: this.font.prep,
                    glyf: this.glyf,
                    hmtx: this.hmtx,
                    fpgm: this.font.fpgm
                }
            });
        };
        return TTFSubset;
    }(Subset);
var CFFSubset = function (_Subset) {
        _inherits(CFFSubset, _Subset);
        function CFFSubset(font) {
            _classCallCheck(this, CFFSubset);
            var _this = _possibleConstructorReturn(this, _Subset.call(this, font));
            _this.cff = _this.font['CFF '];
            if (!_this.cff) {
                throw new Error('Not a CFF Font');
            }
            return _this;
        }
        CFFSubset.prototype.subsetCharstrings = function subsetCharstrings() {
            this.charstrings = [];
            var gsubrs = {};
            for (var _iterator = this.glyphs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var gid = _ref;
                this.charstrings.push(this.cff.getCharString(gid));
                var glyph = this.font.getGlyph(gid);
                var path = glyph.path;
                for (var subr in glyph._usedGsubrs) {
                    gsubrs[subr] = true;
                }
            }
            this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
        };
        CFFSubset.prototype.subsetSubrs = function subsetSubrs(subrs, used) {
            var res = [];
            for (var i = 0; i < subrs.length; i++) {
                var subr = subrs[i];
                if (used[i]) {
                    this.cff.stream.pos = subr.offset;
                    res.push(this.cff.stream.readBuffer(subr.length));
                } else {
                    res.push(new Buffer([11]));
                }
            }
            return res;
        };
        CFFSubset.prototype.subsetFontdict = function subsetFontdict(topDict) {
            topDict.FDArray = [];
            topDict.FDSelect = {
                version: 0,
                fds: []
            };
            var used_fds = {};
            var used_subrs = [];
            for (var _iterator2 = this.glyphs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var gid = _ref2;
                var fd = this.cff.fdForGlyph(gid);
                if (fd == null) {
                    continue;
                }
                if (!used_fds[fd]) {
                    topDict.FDArray.push(_Object$assign({}, this.cff.topDict.FDArray[fd]));
                    used_subrs.push({});
                }
                used_fds[fd] = true;
                topDict.FDSelect.fds.push(topDict.FDArray.length - 1);
                var glyph = this.font.getGlyph(gid);
                var path = glyph.path;
                for (var subr in glyph._usedSubrs) {
                    used_subrs[used_subrs.length - 1][subr] = true;
                }
            }
            for (var i = 0; i < topDict.FDArray.length; i++) {
                var dict = topDict.FDArray[i];
                delete dict.FontName;
                if (dict.Private && dict.Private.Subrs) {
                    dict.Private = _Object$assign({}, dict.Private);
                    dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);
                }
            }
            return;
        };
        CFFSubset.prototype.createCIDFontdict = function createCIDFontdict(topDict) {
            var used_subrs = {};
            for (var _iterator3 = this.glyphs, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length)
                        break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done)
                        break;
                    _ref3 = _i3.value;
                }
                var gid = _ref3;
                var glyph = this.font.getGlyph(gid);
                var path = glyph.path;
                for (var subr in glyph._usedSubrs) {
                    used_subrs[subr] = true;
                }
            }
            var privateDict = _Object$assign({}, this.cff.topDict.Private);
            if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) {
                privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
            }
            topDict.FDArray = [{ Private: privateDict }];
            return topDict.FDSelect = {
                version: 3,
                nRanges: 1,
                ranges: [{
                        first: 0,
                        fd: 0
                    }],
                sentinel: this.charstrings.length
            };
        };
        CFFSubset.prototype.addString = function addString(string) {
            if (!string) {
                return null;
            }
            if (!this.strings) {
                this.strings = [];
            }
            this.strings.push(string);
            return standardStrings.length + this.strings.length - 1;
        };
        CFFSubset.prototype.encode = function encode(stream) {
            this.subsetCharstrings();
            var charset = {
                    version: this.charstrings.length > 255 ? 2 : 1,
                    ranges: [{
                            first: 1,
                            nLeft: this.charstrings.length - 2
                        }]
                };
            var topDict = _Object$assign({}, this.cff.topDict);
            topDict.Private = null;
            topDict.charset = charset;
            topDict.Encoding = null;
            topDict.CharStrings = this.charstrings;
            var _arr = [
                    'version',
                    'Notice',
                    'Copyright',
                    'FullName',
                    'FamilyName',
                    'Weight',
                    'PostScript',
                    'BaseFontName',
                    'FontName'
                ];
            for (var _i4 = 0; _i4 < _arr.length; _i4++) {
                var key = _arr[_i4];
                topDict[key] = this.addString(this.cff.string(topDict[key]));
            }
            topDict.ROS = [
                this.addString('Adobe'),
                this.addString('Identity'),
                0
            ];
            topDict.CIDCount = this.charstrings.length;
            if (this.cff.isCIDFont) {
                this.subsetFontdict(topDict);
            } else {
                this.createCIDFontdict(topDict);
            }
            var top = {
                    version: 1,
                    hdrSize: this.cff.hdrSize,
                    offSize: 4,
                    header: this.cff.header,
                    nameIndex: [this.cff.postscriptName],
                    topDictIndex: [topDict],
                    stringIndex: this.strings,
                    globalSubrIndex: this.gsubrs
                };
            CFFTop.encode(stream, top);
        };
        return CFFSubset;
    }(Subset);
var _class;
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }
    return desc;
}
var TTFFont = (_class = function () {
        TTFFont.probe = function probe(buffer) {
            var format = buffer.toString('ascii', 0, 4);
            return format === 'true' || format === 'OTTO' || format === String.fromCharCode(0, 1, 0, 0);
        };
        function TTFFont(stream) {
            var variationCoords = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            _classCallCheck(this, TTFFont);
            this.defaultLanguage = null;
            this.stream = stream;
            this.variationCoords = variationCoords;
            this._directoryPos = this.stream.pos;
            this._tables = {};
            this._glyphs = {};
            this._decodeDirectory();
            for (var tag in this.directory.tables) {
                var table = this.directory.tables[tag];
                if (tables[tag] && table.length > 0) {
                    _Object$defineProperty(this, tag, { get: this._getTable.bind(this, table) });
                }
            }
        }
        TTFFont.prototype.setDefaultLanguage = function setDefaultLanguage() {
            var lang = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            this.defaultLanguage = lang;
        };
        TTFFont.prototype._getTable = function _getTable(table) {
            if (!(table.tag in this._tables)) {
                try {
                    this._tables[table.tag] = this._decodeTable(table);
                } catch (e) {
                    if (fontkit.logErrors) {
                        console.error('Error decoding table ' + table.tag);
                        console.error(e.stack);
                    }
                }
            }
            return this._tables[table.tag];
        };
        TTFFont.prototype._getTableStream = function _getTableStream(tag) {
            var table = this.directory.tables[tag];
            if (table) {
                this.stream.pos = table.offset;
                return this.stream;
            }
            return null;
        };
        TTFFont.prototype._decodeDirectory = function _decodeDirectory() {
            return this.directory = Directory.decode(this.stream, { _startOffset: 0 });
        };
        TTFFont.prototype._decodeTable = function _decodeTable(table) {
            var pos = this.stream.pos;
            var stream = this._getTableStream(table.tag);
            var result = tables[table.tag].decode(stream, this, table.length);
            this.stream.pos = pos;
            return result;
        };
        TTFFont.prototype.getName = function getName(key) {
            var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultLanguage || fontkit.defaultLanguage;
            var record = this.name && this.name.records[key];
            if (record) {
                return record[lang] || record[this.defaultLanguage] || record[fontkit.defaultLanguage] || record['en'] || record[_Object$keys(record)[0]] || null;
            }
            return null;
        };
        TTFFont.prototype.hasGlyphForCodePoint = function hasGlyphForCodePoint(codePoint) {
            return !!this._cmapProcessor.lookup(codePoint);
        };
        TTFFont.prototype.glyphForCodePoint = function glyphForCodePoint(codePoint) {
            return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);
        };
        TTFFont.prototype.glyphsForString = function glyphsForString(string) {
            var glyphs = [];
            var len = string.length;
            var idx = 0;
            var last = -1;
            var state = -1;
            while (idx <= len) {
                var code = 0;
                var nextState = 0;
                if (idx < len) {
                    code = string.charCodeAt(idx++);
                    if (55296 <= code && code <= 56319 && idx < len) {
                        var next = string.charCodeAt(idx);
                        if (56320 <= next && next <= 57343) {
                            idx++;
                            code = ((code & 1023) << 10) + (next & 1023) + 65536;
                        }
                    }
                    nextState = 65024 <= code && code <= 65039 || 917760 <= code && code <= 917999 ? 1 : 0;
                } else {
                    idx++;
                }
                if (state === 0 && nextState === 1) {
                    glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last, code), [
                        last,
                        code
                    ]));
                } else if (state === 0 && nextState === 0) {
                    glyphs.push(this.glyphForCodePoint(last));
                }
                last = code;
                state = nextState;
            }
            return glyphs;
        };
        TTFFont.prototype.layout = function layout(string, userFeatures, script, language, direction) {
            return this._layoutEngine.layout(string, userFeatures, script, language, direction);
        };
        TTFFont.prototype.stringsForGlyph = function stringsForGlyph(gid) {
            return this._layoutEngine.stringsForGlyph(gid);
        };
        TTFFont.prototype.getAvailableFeatures = function getAvailableFeatures(script, language) {
            return this._layoutEngine.getAvailableFeatures(script, language);
        };
        TTFFont.prototype._getBaseGlyph = function _getBaseGlyph(glyph) {
            var characters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            if (!this._glyphs[glyph]) {
                if (this.directory.tables.glyf) {
                    this._glyphs[glyph] = new TTFGlyph(glyph, characters, this);
                } else if (this.directory.tables['CFF '] || this.directory.tables.CFF2) {
                    this._glyphs[glyph] = new CFFGlyph(glyph, characters, this);
                }
            }
            return this._glyphs[glyph] || null;
        };
        TTFFont.prototype.getGlyph = function getGlyph(glyph) {
            var characters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            if (!this._glyphs[glyph]) {
                if (this.directory.tables.sbix) {
                    this._glyphs[glyph] = new SBIXGlyph(glyph, characters, this);
                } else if (this.directory.tables.COLR && this.directory.tables.CPAL) {
                    this._glyphs[glyph] = new COLRGlyph(glyph, characters, this);
                } else {
                    this._getBaseGlyph(glyph, characters);
                }
            }
            return this._glyphs[glyph] || null;
        };
        TTFFont.prototype.createSubset = function createSubset() {
            if (this.directory.tables['CFF ']) {
                return new CFFSubset(this);
            }
            return new TTFSubset(this);
        };
        TTFFont.prototype.getVariation = function getVariation(settings) {
            if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) {
                throw new Error('Variations require a font with the fvar, gvar and glyf, or CFF2 tables.');
            }
            if (typeof settings === 'string') {
                settings = this.namedVariations[settings];
            }
            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {
                throw new Error('Variation settings must be either a variation name or settings object.');
            }
            var coords = this.fvar.axis.map(function (axis, i) {
                    var axisTag = axis.axisTag.trim();
                    if (axisTag in settings) {
                        return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
                    } else {
                        return axis.defaultValue;
                    }
                });
            var stream = new r.DecodeStream(this.stream.buffer);
            stream.pos = this._directoryPos;
            var font = new TTFFont(stream, coords);
            font._tables = this._tables;
            return font;
        };
        TTFFont.prototype.getFont = function getFont(name) {
            return this.getVariation(name);
        };
        _createClass(TTFFont, [
            {
                key: 'postscriptName',
                get: function get() {
                    return this.getName('postscriptName');
                }
            },
            {
                key: 'fullName',
                get: function get() {
                    return this.getName('fullName');
                }
            },
            {
                key: 'familyName',
                get: function get() {
                    return this.getName('fontFamily');
                }
            },
            {
                key: 'subfamilyName',
                get: function get() {
                    return this.getName('fontSubfamily');
                }
            },
            {
                key: 'copyright',
                get: function get() {
                    return this.getName('copyright');
                }
            },
            {
                key: 'version',
                get: function get() {
                    return this.getName('version');
                }
            },
            {
                key: 'ascent',
                get: function get() {
                    return this.hhea.ascent;
                }
            },
            {
                key: 'descent',
                get: function get() {
                    return this.hhea.descent;
                }
            },
            {
                key: 'lineGap',
                get: function get() {
                    return this.hhea.lineGap;
                }
            },
            {
                key: 'underlinePosition',
                get: function get() {
                    return this.post.underlinePosition;
                }
            },
            {
                key: 'underlineThickness',
                get: function get() {
                    return this.post.underlineThickness;
                }
            },
            {
                key: 'italicAngle',
                get: function get() {
                    return this.post.italicAngle;
                }
            },
            {
                key: 'capHeight',
                get: function get() {
                    var os2 = this['OS/2'];
                    return os2 ? os2.capHeight : this.ascent;
                }
            },
            {
                key: 'xHeight',
                get: function get() {
                    var os2 = this['OS/2'];
                    return os2 ? os2.xHeight : 0;
                }
            },
            {
                key: 'numGlyphs',
                get: function get() {
                    return this.maxp.numGlyphs;
                }
            },
            {
                key: 'unitsPerEm',
                get: function get() {
                    return this.head.unitsPerEm;
                }
            },
            {
                key: 'bbox',
                get: function get() {
                    return _Object$freeze(new BBox(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
                }
            },
            {
                key: '_cmapProcessor',
                get: function get() {
                    return new CmapProcessor(this.cmap);
                }
            },
            {
                key: 'characterSet',
                get: function get() {
                    return this._cmapProcessor.getCharacterSet();
                }
            },
            {
                key: '_layoutEngine',
                get: function get() {
                    return new LayoutEngine(this);
                }
            },
            {
                key: 'availableFeatures',
                get: function get() {
                    return this._layoutEngine.getAvailableFeatures();
                }
            },
            {
                key: 'variationAxes',
                get: function get() {
                    var res = {};
                    if (!this.fvar) {
                        return res;
                    }
                    for (var _iterator = this.fvar.axis, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length)
                                break;
                            _ref = _iterator[_i++];
                        } else {
                            _i = _iterator.next();
                            if (_i.done)
                                break;
                            _ref = _i.value;
                        }
                        var axis = _ref;
                        res[axis.axisTag.trim()] = {
                            name: axis.name.en,
                            min: axis.minValue,
                            default: axis.defaultValue,
                            max: axis.maxValue
                        };
                    }
                    return res;
                }
            },
            {
                key: 'namedVariations',
                get: function get() {
                    var res = {};
                    if (!this.fvar) {
                        return res;
                    }
                    for (var _iterator2 = this.fvar.instance, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length)
                                break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            _i2 = _iterator2.next();
                            if (_i2.done)
                                break;
                            _ref2 = _i2.value;
                        }
                        var instance = _ref2;
                        var settings = {};
                        for (var i = 0; i < this.fvar.axis.length; i++) {
                            var axis = this.fvar.axis[i];
                            settings[axis.axisTag.trim()] = instance.coord[i];
                        }
                        res[instance.name.en] = settings;
                    }
                    return res;
                }
            },
            {
                key: '_variationProcessor',
                get: function get() {
                    if (!this.fvar) {
                        return null;
                    }
                    var variationCoords = this.variationCoords;
                    if (!variationCoords && !this.CFF2) {
                        return null;
                    }
                    if (!variationCoords) {
                        variationCoords = this.fvar.axis.map(function (axis) {
                            return axis.defaultValue;
                        });
                    }
                    return new GlyphVariationProcessor(this, variationCoords);
                }
            }
        ]);
        return TTFFont;
    }(), (_applyDecoratedDescriptor(_class.prototype, 'bbox', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'bbox'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_cmapProcessor', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, '_cmapProcessor'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'characterSet', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'characterSet'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_layoutEngine', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, '_layoutEngine'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'variationAxes', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'variationAxes'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'namedVariations', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'namedVariations'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_variationProcessor', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, '_variationProcessor'), _class.prototype)), _class);
var WOFFDirectoryEntry = new r.Struct({
        tag: new r.String(4),
        offset: new r.Pointer(r.uint32, 'void', { type: 'global' }),
        compLength: r.uint32,
        length: r.uint32,
        origChecksum: r.uint32
    });
var WOFFDirectory = new r.Struct({
        tag: new r.String(4),
        flavor: r.uint32,
        length: r.uint32,
        numTables: r.uint16,
        reserved: new r.Reserved(r.uint16),
        totalSfntSize: r.uint32,
        majorVersion: r.uint16,
        minorVersion: r.uint16,
        metaOffset: r.uint32,
        metaLength: r.uint32,
        metaOrigLength: r.uint32,
        privOffset: r.uint32,
        privLength: r.uint32,
        tables: new r.Array(WOFFDirectoryEntry, 'numTables')
    });
WOFFDirectory.process = function () {
    var tables = {};
    for (var _iterator = this.tables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length)
                break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done)
                break;
            _ref = _i.value;
        }
        var table = _ref;
        tables[table.tag] = table;
    }
    this.tables = tables;
};
var WOFFFont = function (_TTFFont) {
        _inherits(WOFFFont, _TTFFont);
        function WOFFFont() {
            _classCallCheck(this, WOFFFont);
            return _possibleConstructorReturn(this, _TTFFont.apply(this, arguments));
        }
        WOFFFont.probe = function probe(buffer) {
            return buffer.toString('ascii', 0, 4) === 'wOFF';
        };
        WOFFFont.prototype._decodeDirectory = function _decodeDirectory() {
            this.directory = WOFFDirectory.decode(this.stream, { _startOffset: 0 });
        };
        WOFFFont.prototype._getTableStream = function _getTableStream(tag) {
            var table = this.directory.tables[tag];
            if (table) {
                this.stream.pos = table.offset;
                if (table.compLength < table.length) {
                    this.stream.pos += 2;
                    var outBuffer = new Buffer(table.length);
                    var buf = inflate(this.stream.readBuffer(table.compLength - 2), outBuffer);
                    return new r.DecodeStream(buf);
                } else {
                    return this.stream;
                }
            }
            return null;
        };
        return WOFFFont;
    }(TTFFont);
var WOFF2Glyph = function (_TTFGlyph) {
        _inherits(WOFF2Glyph, _TTFGlyph);
        function WOFF2Glyph() {
            _classCallCheck(this, WOFF2Glyph);
            return _possibleConstructorReturn(this, _TTFGlyph.apply(this, arguments));
        }
        WOFF2Glyph.prototype._decode = function _decode() {
            return this._font._transformedGlyphs[this.id];
        };
        WOFF2Glyph.prototype._getCBox = function _getCBox() {
            return this.path.bbox;
        };
        return WOFF2Glyph;
    }(TTFGlyph);
var Base128 = {
        decode: function decode(stream) {
            var result = 0;
            var iterable = [
                    0,
                    1,
                    2,
                    3,
                    4
                ];
            for (var j = 0; j < iterable.length; j++) {
                var i = iterable[j];
                var code = stream.readUInt8();
                if (result & 3758096384) {
                    throw new Error('Overflow');
                }
                result = result << 7 | code & 127;
                if ((code & 128) === 0) {
                    return result;
                }
            }
            throw new Error('Bad base 128 number');
        }
    };
var knownTags = [
        'cmap',
        'head',
        'hhea',
        'hmtx',
        'maxp',
        'name',
        'OS/2',
        'post',
        'cvt ',
        'fpgm',
        'glyf',
        'loca',
        'prep',
        'CFF ',
        'VORG',
        'EBDT',
        'EBLC',
        'gasp',
        'hdmx',
        'kern',
        'LTSH',
        'PCLT',
        'VDMX',
        'vhea',
        'vmtx',
        'BASE',
        'GDEF',
        'GPOS',
        'GSUB',
        'EBSC',
        'JSTF',
        'MATH',
        'CBDT',
        'CBLC',
        'COLR',
        'CPAL',
        'SVG ',
        'sbix',
        'acnt',
        'avar',
        'bdat',
        'bloc',
        'bsln',
        'cvar',
        'fdsc',
        'feat',
        'fmtx',
        'fvar',
        'gvar',
        'hsty',
        'just',
        'lcar',
        'mort',
        'morx',
        'opbd',
        'prop',
        'trak',
        'Zapf',
        'Silf',
        'Glat',
        'Gloc',
        'Feat',
        'Sill'
    ];
var WOFF2DirectoryEntry = new r.Struct({
        flags: r.uint8,
        customTag: new r.Optional(new r.String(4), function (t) {
            return (t.flags & 63) === 63;
        }),
        tag: function tag(t) {
            return t.customTag || knownTags[t.flags & 63];
        },
        length: Base128,
        transformVersion: function transformVersion(t) {
            return t.flags >>> 6 & 3;
        },
        transformed: function transformed(t) {
            return t.tag === 'glyf' || t.tag === 'loca' ? t.transformVersion === 0 : t.transformVersion !== 0;
        },
        transformLength: new r.Optional(Base128, function (t) {
            return t.transformed;
        })
    });
var WOFF2Directory = new r.Struct({
        tag: new r.String(4),
        flavor: r.uint32,
        length: r.uint32,
        numTables: r.uint16,
        reserved: new r.Reserved(r.uint16),
        totalSfntSize: r.uint32,
        totalCompressedSize: r.uint32,
        majorVersion: r.uint16,
        minorVersion: r.uint16,
        metaOffset: r.uint32,
        metaLength: r.uint32,
        metaOrigLength: r.uint32,
        privOffset: r.uint32,
        privLength: r.uint32,
        tables: new r.Array(WOFF2DirectoryEntry, 'numTables')
    });
WOFF2Directory.process = function () {
    var tables = {};
    for (var i = 0; i < this.tables.length; i++) {
        var table = this.tables[i];
        tables[table.tag] = table;
    }
    return this.tables = tables;
};
var WOFF2Font = function (_TTFFont) {
        _inherits(WOFF2Font, _TTFFont);
        function WOFF2Font() {
            _classCallCheck(this, WOFF2Font);
            return _possibleConstructorReturn(this, _TTFFont.apply(this, arguments));
        }
        WOFF2Font.probe = function probe(buffer) {
            return buffer.toString('ascii', 0, 4) === 'wOF2';
        };
        WOFF2Font.prototype._decodeDirectory = function _decodeDirectory() {
            this.directory = WOFF2Directory.decode(this.stream);
            this._dataPos = this.stream.pos;
        };
        WOFF2Font.prototype._decompress = function _decompress() {
            if (!this._decompressed) {
                this.stream.pos = this._dataPos;
                var buffer = this.stream.readBuffer(this.directory.totalCompressedSize);
                var decompressedSize = 0;
                for (var tag in this.directory.tables) {
                    var entry = this.directory.tables[tag];
                    entry.offset = decompressedSize;
                    decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
                }
                var decompressed = brotli(buffer, decompressedSize);
                if (!decompressed) {
                    throw new Error('Error decoding compressed data in WOFF2');
                }
                this.stream = new r.DecodeStream(new Buffer(decompressed));
                this._decompressed = true;
            }
        };
        WOFF2Font.prototype._decodeTable = function _decodeTable(table) {
            this._decompress();
            return _TTFFont.prototype._decodeTable.call(this, table);
        };
        WOFF2Font.prototype._getBaseGlyph = function _getBaseGlyph(glyph) {
            var characters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            if (!this._glyphs[glyph]) {
                if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
                    if (!this._transformedGlyphs) {
                        this._transformGlyfTable();
                    }
                    return this._glyphs[glyph] = new WOFF2Glyph(glyph, characters, this);
                } else {
                    return _TTFFont.prototype._getBaseGlyph.call(this, glyph, characters);
                }
            }
        };
        WOFF2Font.prototype._transformGlyfTable = function _transformGlyfTable() {
            this._decompress();
            this.stream.pos = this.directory.tables.glyf.offset;
            var table = GlyfTable.decode(this.stream);
            var glyphs = [];
            for (var index = 0; index < table.numGlyphs; index++) {
                var glyph = {};
                var nContours = table.nContours.readInt16BE();
                glyph.numberOfContours = nContours;
                if (nContours > 0) {
                    var nPoints = [];
                    var totalPoints = 0;
                    for (var i = 0; i < nContours; i++) {
                        var _r = read255UInt16(table.nPoints);
                        totalPoints += _r;
                        nPoints.push(totalPoints);
                    }
                    glyph.points = decodeTriplet(table.flags, table.glyphs, totalPoints);
                    for (var _i = 0; _i < nContours; _i++) {
                        glyph.points[nPoints[_i] - 1].endContour = true;
                    }
                    var instructionSize = read255UInt16(table.glyphs);
                } else if (nContours < 0) {
                    var haveInstructions = TTFGlyph.prototype._decodeComposite.call({ _font: this }, glyph, table.composites);
                    if (haveInstructions) {
                        var instructionSize = read255UInt16(table.glyphs);
                    }
                }
                glyphs.push(glyph);
            }
            this._transformedGlyphs = glyphs;
        };
        return WOFF2Font;
    }(TTFFont);
var Substream = function () {
        function Substream(length) {
            _classCallCheck(this, Substream);
            this.length = length;
            this._buf = new r.Buffer(length);
        }
        Substream.prototype.decode = function decode(stream, parent) {
            return new r.DecodeStream(this._buf.decode(stream, parent));
        };
        return Substream;
    }();
var GlyfTable = new r.Struct({
        version: r.uint32,
        numGlyphs: r.uint16,
        indexFormat: r.uint16,
        nContourStreamSize: r.uint32,
        nPointsStreamSize: r.uint32,
        flagStreamSize: r.uint32,
        glyphStreamSize: r.uint32,
        compositeStreamSize: r.uint32,
        bboxStreamSize: r.uint32,
        instructionStreamSize: r.uint32,
        nContours: new Substream('nContourStreamSize'),
        nPoints: new Substream('nPointsStreamSize'),
        flags: new Substream('flagStreamSize'),
        glyphs: new Substream('glyphStreamSize'),
        composites: new Substream('compositeStreamSize'),
        bboxes: new Substream('bboxStreamSize'),
        instructions: new Substream('instructionStreamSize')
    });
var WORD_CODE = 253;
var ONE_MORE_BYTE_CODE2 = 254;
var ONE_MORE_BYTE_CODE1 = 255;
var LOWEST_U_CODE = 253;
function read255UInt16(stream) {
    var code = stream.readUInt8();
    if (code === WORD_CODE) {
        return stream.readUInt16BE();
    }
    if (code === ONE_MORE_BYTE_CODE1) {
        return stream.readUInt8() + LOWEST_U_CODE;
    }
    if (code === ONE_MORE_BYTE_CODE2) {
        return stream.readUInt8() + LOWEST_U_CODE * 2;
    }
    return code;
}
function withSign(flag, baseval) {
    return flag & 1 ? baseval : -baseval;
}
function decodeTriplet(flags, glyphs, nPoints) {
    var y = void 0;
    var x = y = 0;
    var res = [];
    for (var i = 0; i < nPoints; i++) {
        var dx = 0, dy = 0;
        var flag = flags.readUInt8();
        var onCurve = !(flag >> 7);
        flag &= 127;
        if (flag < 10) {
            dx = 0;
            dy = withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());
        } else if (flag < 20) {
            dx = withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());
            dy = 0;
        } else if (flag < 84) {
            var b0 = flag - 20;
            var b1 = glyphs.readUInt8();
            dx = withSign(flag, 1 + (b0 & 48) + (b1 >> 4));
            dy = withSign(flag >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
        } else if (flag < 120) {
            var b0 = flag - 84;
            dx = withSign(flag, 1 + (b0 / 12 << 8) + glyphs.readUInt8());
            dy = withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());
        } else if (flag < 124) {
            var b1 = glyphs.readUInt8();
            var b2 = glyphs.readUInt8();
            dx = withSign(flag, (b1 << 4) + (b2 >> 4));
            dy = withSign(flag >> 1, ((b2 & 15) << 8) + glyphs.readUInt8());
        } else {
            dx = withSign(flag, glyphs.readUInt16BE());
            dy = withSign(flag >> 1, glyphs.readUInt16BE());
        }
        x += dx;
        y += dy;
        res.push(new Point(onCurve, false, x, y));
    }
    return res;
}
var TTCHeader = new r.VersionedStruct(r.uint32, {
        65536: {
            numFonts: r.uint32,
            offsets: new r.Array(r.uint32, 'numFonts')
        },
        131072: {
            numFonts: r.uint32,
            offsets: new r.Array(r.uint32, 'numFonts'),
            dsigTag: r.uint32,
            dsigLength: r.uint32,
            dsigOffset: r.uint32
        }
    });
var TrueTypeCollection = function () {
        TrueTypeCollection.probe = function probe(buffer) {
            return buffer.toString('ascii', 0, 4) === 'ttcf';
        };
        function TrueTypeCollection(stream) {
            _classCallCheck(this, TrueTypeCollection);
            this.stream = stream;
            if (stream.readString(4) !== 'ttcf') {
                throw new Error('Not a TrueType collection');
            }
            this.header = TTCHeader.decode(stream);
        }
        TrueTypeCollection.prototype.getFont = function getFont(name) {
            for (var _iterator = this.header.offsets, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var offset = _ref;
                var stream = new r.DecodeStream(this.stream.buffer);
                stream.pos = offset;
                var font = new TTFFont(stream);
                if (font.postscriptName === name) {
                    return font;
                }
            }
            return null;
        };
        _createClass(TrueTypeCollection, [{
                key: 'fonts',
                get: function get() {
                    var fonts = [];
                    for (var _iterator2 = this.header.offsets, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length)
                                break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            _i2 = _iterator2.next();
                            if (_i2.done)
                                break;
                            _ref2 = _i2.value;
                        }
                        var offset = _ref2;
                        var stream = new r.DecodeStream(this.stream.buffer);
                        stream.pos = offset;
                        fonts.push(new TTFFont(stream));
                    }
                    return fonts;
                }
            }]);
        return TrueTypeCollection;
    }();
var DFontName = new r.String(r.uint8);
var DFontData = new r.Struct({
        len: r.uint32,
        buf: new r.Buffer('len')
    });
var Ref = new r.Struct({
        id: r.uint16,
        nameOffset: r.int16,
        attr: r.uint8,
        dataOffset: r.uint24,
        handle: r.uint32
    });
var Type = new r.Struct({
        name: new r.String(4),
        maxTypeIndex: r.uint16,
        refList: new r.Pointer(r.uint16, new r.Array(Ref, function (t) {
            return t.maxTypeIndex + 1;
        }), { type: 'parent' })
    });
var TypeList = new r.Struct({
        length: r.uint16,
        types: new r.Array(Type, function (t) {
            return t.length + 1;
        })
    });
var DFontMap = new r.Struct({
        reserved: new r.Reserved(r.uint8, 24),
        typeList: new r.Pointer(r.uint16, TypeList),
        nameListOffset: new r.Pointer(r.uint16, 'void')
    });
var DFontHeader = new r.Struct({
        dataOffset: r.uint32,
        map: new r.Pointer(r.uint32, DFontMap),
        dataLength: r.uint32,
        mapLength: r.uint32
    });
var DFont = function () {
        DFont.probe = function probe(buffer) {
            var stream = new r.DecodeStream(buffer);
            try {
                var header = DFontHeader.decode(stream);
            } catch (e) {
                return false;
            }
            for (var _iterator = header.map.typeList.types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var type = _ref;
                if (type.name === 'sfnt') {
                    return true;
                }
            }
            return false;
        };
        function DFont(stream) {
            _classCallCheck(this, DFont);
            this.stream = stream;
            this.header = DFontHeader.decode(this.stream);
            for (var _iterator2 = this.header.map.typeList.types, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var type = _ref2;
                for (var _iterator3 = type.refList, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length)
                            break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if (_i3.done)
                            break;
                        _ref3 = _i3.value;
                    }
                    var ref = _ref3;
                    if (ref.nameOffset >= 0) {
                        this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
                        ref.name = DFontName.decode(this.stream);
                    } else {
                        ref.name = null;
                    }
                }
                if (type.name === 'sfnt') {
                    this.sfnt = type;
                }
            }
        }
        DFont.prototype.getFont = function getFont(name) {
            if (!this.sfnt) {
                return null;
            }
            for (var _iterator4 = this.sfnt.refList, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
                var _ref4;
                if (_isArray4) {
                    if (_i4 >= _iterator4.length)
                        break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    _i4 = _iterator4.next();
                    if (_i4.done)
                        break;
                    _ref4 = _i4.value;
                }
                var ref = _ref4;
                var pos = this.header.dataOffset + ref.dataOffset + 4;
                var stream = new r.DecodeStream(this.stream.buffer.slice(pos));
                var font = new TTFFont(stream);
                if (font.postscriptName === name) {
                    return font;
                }
            }
            return null;
        };
        _createClass(DFont, [{
                key: 'fonts',
                get: function get() {
                    var fonts = [];
                    for (var _iterator5 = this.sfnt.refList, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i5 >= _iterator5.length)
                                break;
                            _ref5 = _iterator5[_i5++];
                        } else {
                            _i5 = _iterator5.next();
                            if (_i5.done)
                                break;
                            _ref5 = _i5.value;
                        }
                        var ref = _ref5;
                        var pos = this.header.dataOffset + ref.dataOffset + 4;
                        var stream = new r.DecodeStream(this.stream.buffer.slice(pos));
                        fonts.push(new TTFFont(stream));
                    }
                    return fonts;
                }
            }]);
        return DFont;
    }();
fontkit.registerFormat(TTFFont);
fontkit.registerFormat(WOFFFont);
fontkit.registerFormat(WOFF2Font);
fontkit.registerFormat(TrueTypeCollection);
fontkit.registerFormat(DFont);
module.exports = fontkit;
}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":13,"babel-runtime/core-js/array/from":35,"babel-runtime/core-js/get-iterator":36,"babel-runtime/core-js/map":38,"babel-runtime/core-js/number/epsilon":39,"babel-runtime/core-js/object/assign":40,"babel-runtime/core-js/object/define-properties":42,"babel-runtime/core-js/object/define-property":43,"babel-runtime/core-js/object/freeze":44,"babel-runtime/core-js/object/get-own-property-descriptor":45,"babel-runtime/core-js/object/keys":46,"babel-runtime/core-js/set":48,"babel-runtime/core-js/string/from-code-point":49,"babel-runtime/helpers/classCallCheck":52,"babel-runtime/helpers/createClass":53,"babel-runtime/helpers/inherits":55,"babel-runtime/helpers/possibleConstructorReturn":56,"babel-runtime/helpers/typeof":58,"brotli/decompress":71,"buffer":4,"clone":73,"deep-equal":197,"dfa":201,"restructure":209,"restructure/src/utils":225,"tiny-inflate":254,"unicode-properties":256,"unicode-trie":257}],203:[function(require,module,exports){
/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 2.7.0

Copyright (c) 2015-2018, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
!function(t,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{var r=n();for(var a in r)("object"==typeof exports?exports:t)[a]=r[a]}}("undefined"!=typeof self?self:this,function(){return function(t){var n={};function r(a){if(n[a])return n[a].exports;var e=n[a]={i:a,l:!1,exports:{}};return t[a].call(e.exports,e,e.exports,r),e.l=!0,e.exports}return r.m=t,r.c=n,r.d=function(t,n,a){r.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:a})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,n){if(1&n&&(t=r(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var a=Object.create(null);if(r.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var e in t)r.d(a,e,function(n){return t[n]}.bind(null,e));return a},r.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(n,"a",n),n},r.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},r.p="",r(r.s=10)}([function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.setMatrixArrayType=function(t){n.ARRAY_TYPE=t},n.toRadian=function(t){return t*e},n.equals=function(t,n){return Math.abs(t-n)<=a*Math.max(1,Math.abs(t),Math.abs(n))};var a=n.EPSILON=1e-6;n.ARRAY_TYPE="undefined"!=typeof Float32Array?Float32Array:Array,n.RANDOM=Math.random;var e=Math.PI/180},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.forEach=n.sqrLen=n.len=n.sqrDist=n.dist=n.div=n.mul=n.sub=void 0,n.create=e,n.clone=function(t){var n=new a.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},n.fromValues=function(t,n,r,e){var u=new a.ARRAY_TYPE(4);return u[0]=t,u[1]=n,u[2]=r,u[3]=e,u},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t},n.set=function(t,n,r,a,e){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t},n.subtract=u,n.multiply=o,n.divide=i,n.ceil=function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t[3]=Math.ceil(n[3]),t},n.floor=function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t[3]=Math.floor(n[3]),t},n.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t[2]=Math.min(n[2],r[2]),t[3]=Math.min(n[3],r[3]),t},n.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t[2]=Math.max(n[2],r[2]),t[3]=Math.max(n[3],r[3]),t},n.round=function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t[3]=Math.round(n[3]),t},n.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t},n.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t},n.distance=s,n.squaredDistance=c,n.length=f,n.squaredLength=M,n.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t},n.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t[3]=1/n[3],t},n.normalize=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*r+a*a+e*e+u*u;o>0&&(o=1/Math.sqrt(o),t[0]=r*o,t[1]=a*o,t[2]=e*o,t[3]=u*o);return t},n.dot=function(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]+t[3]*n[3]},n.lerp=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=n[3];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t[2]=o+a*(r[2]-o),t[3]=i+a*(r[3]-i),t},n.random=function(t,n){var r,e,u,o,i,s;n=n||1;do{r=2*a.RANDOM()-1,e=2*a.RANDOM()-1,i=r*r+e*e}while(i>=1);do{u=2*a.RANDOM()-1,o=2*a.RANDOM()-1,s=u*u+o*o}while(s>=1);var c=Math.sqrt((1-i)/s);return t[0]=n*r,t[1]=n*e,t[2]=n*u*c,t[3]=n*o*c,t},n.transformMat4=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3];return t[0]=r[0]*a+r[4]*e+r[8]*u+r[12]*o,t[1]=r[1]*a+r[5]*e+r[9]*u+r[13]*o,t[2]=r[2]*a+r[6]*e+r[10]*u+r[14]*o,t[3]=r[3]*a+r[7]*e+r[11]*u+r[15]*o,t},n.transformQuat=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[0],i=r[1],s=r[2],c=r[3],f=c*a+i*u-s*e,M=c*e+s*a-o*u,h=c*u+o*e-i*a,l=-o*a-i*e-s*u;return t[0]=f*c+l*-o+M*-s-h*-i,t[1]=M*c+l*-i+h*-o-f*-s,t[2]=h*c+l*-s+f*-i-M*-o,t[3]=n[3],t},n.str=function(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=n[0],s=n[1],c=n[2],f=n[3];return Math.abs(r-i)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(e-s)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(s))&&Math.abs(u-c)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(c))&&Math.abs(o-f)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(f))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(){var t=new a.ARRAY_TYPE(4);return a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t}function o(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t[2]=n[2]*r[2],t[3]=n[3]*r[3],t}function i(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t[2]=n[2]/r[2],t[3]=n[3]/r[3],t}function s(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2],u=n[3]-t[3];return Math.sqrt(r*r+a*a+e*e+u*u)}function c(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2],u=n[3]-t[3];return r*r+a*a+e*e+u*u}function f(t){var n=t[0],r=t[1],a=t[2],e=t[3];return Math.sqrt(n*n+r*r+a*a+e*e)}function M(t){var n=t[0],r=t[1],a=t[2],e=t[3];return n*n+r*r+a*a+e*e}n.sub=u,n.mul=o,n.div=i,n.dist=s,n.sqrDist=c,n.len=f,n.sqrLen=M,n.forEach=function(){var t=e();return function(n,r,a,e,u,o){var i=void 0,s=void 0;for(r||(r=4),a||(a=0),s=e?Math.min(e*r+a,n.length):n.length,i=a;i<s;i+=r)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],t[3]=n[i+3],u(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2],n[i+3]=t[3];return n}}()},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.forEach=n.sqrLen=n.len=n.sqrDist=n.dist=n.div=n.mul=n.sub=void 0,n.create=e,n.clone=function(t){var n=new a.ARRAY_TYPE(3);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n},n.length=u,n.fromValues=o,n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t},n.set=function(t,n,r,a){return t[0]=n,t[1]=r,t[2]=a,t},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t},n.subtract=i,n.multiply=s,n.divide=c,n.ceil=function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t},n.floor=function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t},n.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t[2]=Math.min(n[2],r[2]),t},n.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t[2]=Math.max(n[2],r[2]),t},n.round=function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t},n.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t},n.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t},n.distance=f,n.squaredDistance=M,n.squaredLength=h,n.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t},n.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t},n.normalize=l,n.dot=v,n.cross=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[0],i=r[1],s=r[2];return t[0]=e*s-u*i,t[1]=u*o-a*s,t[2]=a*i-e*o,t},n.lerp=function(t,n,r,a){var e=n[0],u=n[1],o=n[2];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t[2]=o+a*(r[2]-o),t},n.hermite=function(t,n,r,a,e,u){var o=u*u,i=o*(2*u-3)+1,s=o*(u-2)+u,c=o*(u-1),f=o*(3-2*u);return t[0]=n[0]*i+r[0]*s+a[0]*c+e[0]*f,t[1]=n[1]*i+r[1]*s+a[1]*c+e[1]*f,t[2]=n[2]*i+r[2]*s+a[2]*c+e[2]*f,t},n.bezier=function(t,n,r,a,e,u){var o=1-u,i=o*o,s=u*u,c=i*o,f=3*u*i,M=3*s*o,h=s*u;return t[0]=n[0]*c+r[0]*f+a[0]*M+e[0]*h,t[1]=n[1]*c+r[1]*f+a[1]*M+e[1]*h,t[2]=n[2]*c+r[2]*f+a[2]*M+e[2]*h,t},n.random=function(t,n){n=n||1;var r=2*a.RANDOM()*Math.PI,e=2*a.RANDOM()-1,u=Math.sqrt(1-e*e)*n;return t[0]=Math.cos(r)*u,t[1]=Math.sin(r)*u,t[2]=e*n,t},n.transformMat4=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[3]*a+r[7]*e+r[11]*u+r[15];return o=o||1,t[0]=(r[0]*a+r[4]*e+r[8]*u+r[12])/o,t[1]=(r[1]*a+r[5]*e+r[9]*u+r[13])/o,t[2]=(r[2]*a+r[6]*e+r[10]*u+r[14])/o,t},n.transformMat3=function(t,n,r){var a=n[0],e=n[1],u=n[2];return t[0]=a*r[0]+e*r[3]+u*r[6],t[1]=a*r[1]+e*r[4]+u*r[7],t[2]=a*r[2]+e*r[5]+u*r[8],t},n.transformQuat=function(t,n,r){var a=r[0],e=r[1],u=r[2],o=r[3],i=n[0],s=n[1],c=n[2],f=e*c-u*s,M=u*i-a*c,h=a*s-e*i,l=e*h-u*M,v=u*f-a*h,d=a*M-e*f,b=2*o;return f*=b,M*=b,h*=b,l*=2,v*=2,d*=2,t[0]=i+f+l,t[1]=s+M+v,t[2]=c+h+d,t},n.rotateX=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[0],u[1]=e[1]*Math.cos(a)-e[2]*Math.sin(a),u[2]=e[1]*Math.sin(a)+e[2]*Math.cos(a),t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},n.rotateY=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[2]*Math.sin(a)+e[0]*Math.cos(a),u[1]=e[1],u[2]=e[2]*Math.cos(a)-e[0]*Math.sin(a),t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},n.rotateZ=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[0]*Math.cos(a)-e[1]*Math.sin(a),u[1]=e[0]*Math.sin(a)+e[1]*Math.cos(a),u[2]=e[2],t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},n.angle=function(t,n){var r=o(t[0],t[1],t[2]),a=o(n[0],n[1],n[2]);l(r,r),l(a,a);var e=v(r,a);return e>1?0:e<-1?Math.PI:Math.acos(e)},n.str=function(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=n[0],i=n[1],s=n[2];return Math.abs(r-o)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(o))&&Math.abs(e-i)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(i))&&Math.abs(u-s)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(s))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(){var t=new a.ARRAY_TYPE(3);return a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function u(t){var n=t[0],r=t[1],a=t[2];return Math.sqrt(n*n+r*r+a*a)}function o(t,n,r){var e=new a.ARRAY_TYPE(3);return e[0]=t,e[1]=n,e[2]=r,e}function i(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t}function s(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t[2]=n[2]*r[2],t}function c(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t[2]=n[2]/r[2],t}function f(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2];return Math.sqrt(r*r+a*a+e*e)}function M(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2];return r*r+a*a+e*e}function h(t){var n=t[0],r=t[1],a=t[2];return n*n+r*r+a*a}function l(t,n){var r=n[0],a=n[1],e=n[2],u=r*r+a*a+e*e;return u>0&&(u=1/Math.sqrt(u),t[0]=n[0]*u,t[1]=n[1]*u,t[2]=n[2]*u),t}function v(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}n.sub=i,n.mul=s,n.div=c,n.dist=f,n.sqrDist=M,n.len=u,n.sqrLen=h,n.forEach=function(){var t=e();return function(n,r,a,e,u,o){var i=void 0,s=void 0;for(r||(r=3),a||(a=0),s=e?Math.min(e*r+a,n.length):n.length,i=a;i<s;i+=r)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],u(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2];return n}}()},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.setAxes=n.sqlerp=n.rotationTo=n.equals=n.exactEquals=n.normalize=n.sqrLen=n.squaredLength=n.len=n.length=n.lerp=n.dot=n.scale=n.mul=n.add=n.set=n.copy=n.fromValues=n.clone=void 0,n.create=s,n.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},n.setAxisAngle=c,n.getAxisAngle=function(t,n){var r=2*Math.acos(n[3]),e=Math.sin(r/2);e>a.EPSILON?(t[0]=n[0]/e,t[1]=n[1]/e,t[2]=n[2]/e):(t[0]=1,t[1]=0,t[2]=0);return r},n.multiply=f,n.rotateX=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),s=Math.cos(r);return t[0]=a*s+o*i,t[1]=e*s+u*i,t[2]=u*s-e*i,t[3]=o*s-a*i,t},n.rotateY=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),s=Math.cos(r);return t[0]=a*s-u*i,t[1]=e*s+o*i,t[2]=u*s+a*i,t[3]=o*s-e*i,t},n.rotateZ=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),s=Math.cos(r);return t[0]=a*s+e*i,t[1]=e*s-a*i,t[2]=u*s+o*i,t[3]=o*s-u*i,t},n.calculateW=function(t,n){var r=n[0],a=n[1],e=n[2];return t[0]=r,t[1]=a,t[2]=e,t[3]=Math.sqrt(Math.abs(1-r*r-a*a-e*e)),t},n.slerp=M,n.random=function(t){var n=a.RANDOM(),r=a.RANDOM(),e=a.RANDOM(),u=Math.sqrt(1-n),o=Math.sqrt(n);return t[0]=u*Math.sin(2*Math.PI*r),t[1]=u*Math.cos(2*Math.PI*r),t[2]=o*Math.sin(2*Math.PI*e),t[3]=o*Math.cos(2*Math.PI*e),t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*r+a*a+e*e+u*u,i=o?1/o:0;return t[0]=-r*i,t[1]=-a*i,t[2]=-e*i,t[3]=u*i,t},n.conjugate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t},n.fromMat3=h,n.fromEuler=function(t,n,r,a){var e=.5*Math.PI/180;n*=e,r*=e,a*=e;var u=Math.sin(n),o=Math.cos(n),i=Math.sin(r),s=Math.cos(r),c=Math.sin(a),f=Math.cos(a);return t[0]=u*s*f-o*i*c,t[1]=o*i*f+u*s*c,t[2]=o*s*c-u*i*f,t[3]=o*s*f+u*i*c,t},n.str=function(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"};var a=i(r(0)),e=i(r(5)),u=i(r(2)),o=i(r(1));function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}function s(){var t=new a.ARRAY_TYPE(4);return a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function c(t,n,r){r*=.5;var a=Math.sin(r);return t[0]=a*n[0],t[1]=a*n[1],t[2]=a*n[2],t[3]=Math.cos(r),t}function f(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],s=r[1],c=r[2],f=r[3];return t[0]=a*f+o*i+e*c-u*s,t[1]=e*f+o*s+u*i-a*c,t[2]=u*f+o*c+a*s-e*i,t[3]=o*f-a*i-e*s-u*c,t}function M(t,n,r,e){var u=n[0],o=n[1],i=n[2],s=n[3],c=r[0],f=r[1],M=r[2],h=r[3],l=void 0,v=void 0,d=void 0,b=void 0,m=void 0;return(v=u*c+o*f+i*M+s*h)<0&&(v=-v,c=-c,f=-f,M=-M,h=-h),1-v>a.EPSILON?(l=Math.acos(v),d=Math.sin(l),b=Math.sin((1-e)*l)/d,m=Math.sin(e*l)/d):(b=1-e,m=e),t[0]=b*u+m*c,t[1]=b*o+m*f,t[2]=b*i+m*M,t[3]=b*s+m*h,t}function h(t,n){var r=n[0]+n[4]+n[8],a=void 0;if(r>0)a=Math.sqrt(r+1),t[3]=.5*a,a=.5/a,t[0]=(n[5]-n[7])*a,t[1]=(n[6]-n[2])*a,t[2]=(n[1]-n[3])*a;else{var e=0;n[4]>n[0]&&(e=1),n[8]>n[3*e+e]&&(e=2);var u=(e+1)%3,o=(e+2)%3;a=Math.sqrt(n[3*e+e]-n[3*u+u]-n[3*o+o]+1),t[e]=.5*a,a=.5/a,t[3]=(n[3*u+o]-n[3*o+u])*a,t[u]=(n[3*u+e]+n[3*e+u])*a,t[o]=(n[3*o+e]+n[3*e+o])*a}return t}n.clone=o.clone,n.fromValues=o.fromValues,n.copy=o.copy,n.set=o.set,n.add=o.add,n.mul=f,n.scale=o.scale,n.dot=o.dot,n.lerp=o.lerp;var l=n.length=o.length,v=(n.len=l,n.squaredLength=o.squaredLength),d=(n.sqrLen=v,n.normalize=o.normalize);n.exactEquals=o.exactEquals,n.equals=o.equals,n.rotationTo=function(){var t=u.create(),n=u.fromValues(1,0,0),r=u.fromValues(0,1,0);return function(a,e,o){var i=u.dot(e,o);return i<-.999999?(u.cross(t,n,e),u.len(t)<1e-6&&u.cross(t,r,e),u.normalize(t,t),c(a,t,Math.PI),a):i>.999999?(a[0]=0,a[1]=0,a[2]=0,a[3]=1,a):(u.cross(t,e,o),a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=1+i,d(a,a))}}(),n.sqlerp=function(){var t=s(),n=s();return function(r,a,e,u,o,i){return M(t,a,o,i),M(n,e,u,i),M(r,t,n,2*i*(1-i)),r}}(),n.setAxes=function(){var t=e.create();return function(n,r,a,e){return t[0]=a[0],t[3]=a[1],t[6]=a[2],t[1]=e[0],t[4]=e[1],t[7]=e[2],t[2]=-r[0],t[5]=-r[1],t[8]=-r[2],d(n,h(n,t))}}()},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=function(){var t=new a.ARRAY_TYPE(16);a.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0);return t[0]=1,t[5]=1,t[10]=1,t[15]=1,t},n.clone=function(t){var n=new a.ARRAY_TYPE(16);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},n.fromValues=function(t,n,r,e,u,o,i,s,c,f,M,h,l,v,d,b){var m=new a.ARRAY_TYPE(16);return m[0]=t,m[1]=n,m[2]=r,m[3]=e,m[4]=u,m[5]=o,m[6]=i,m[7]=s,m[8]=c,m[9]=f,m[10]=M,m[11]=h,m[12]=l,m[13]=v,m[14]=d,m[15]=b,m},n.set=function(t,n,r,a,e,u,o,i,s,c,f,M,h,l,v,d,b){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t[4]=u,t[5]=o,t[6]=i,t[7]=s,t[8]=c,t[9]=f,t[10]=M,t[11]=h,t[12]=l,t[13]=v,t[14]=d,t[15]=b,t},n.identity=e,n.transpose=function(t,n){if(t===n){var r=n[1],a=n[2],e=n[3],u=n[6],o=n[7],i=n[11];t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=r,t[6]=n[9],t[7]=n[13],t[8]=a,t[9]=u,t[11]=n[14],t[12]=e,t[13]=o,t[14]=i}else t[0]=n[0],t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=n[1],t[5]=n[5],t[6]=n[9],t[7]=n[13],t[8]=n[2],t[9]=n[6],t[10]=n[10],t[11]=n[14],t[12]=n[3],t[13]=n[7],t[14]=n[11],t[15]=n[15];return t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8],M=n[9],h=n[10],l=n[11],v=n[12],d=n[13],b=n[14],m=n[15],p=r*i-a*o,P=r*s-e*o,A=r*c-u*o,E=a*s-e*i,O=a*c-u*i,R=e*c-u*s,y=f*d-M*v,q=f*b-h*v,x=f*m-l*v,_=M*b-h*d,Y=M*m-l*d,L=h*m-l*b,S=p*L-P*Y+A*_+E*x-O*q+R*y;if(!S)return null;return S=1/S,t[0]=(i*L-s*Y+c*_)*S,t[1]=(e*Y-a*L-u*_)*S,t[2]=(d*R-b*O+m*E)*S,t[3]=(h*O-M*R-l*E)*S,t[4]=(s*x-o*L-c*q)*S,t[5]=(r*L-e*x+u*q)*S,t[6]=(b*A-v*R-m*P)*S,t[7]=(f*R-h*A+l*P)*S,t[8]=(o*Y-i*x+c*y)*S,t[9]=(a*x-r*Y-u*y)*S,t[10]=(v*O-d*A+m*p)*S,t[11]=(M*A-f*O-l*p)*S,t[12]=(i*q-o*_-s*y)*S,t[13]=(r*_-a*q+e*y)*S,t[14]=(d*P-v*E-b*p)*S,t[15]=(f*E-M*P+h*p)*S,t},n.adjoint=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8],M=n[9],h=n[10],l=n[11],v=n[12],d=n[13],b=n[14],m=n[15];return t[0]=i*(h*m-l*b)-M*(s*m-c*b)+d*(s*l-c*h),t[1]=-(a*(h*m-l*b)-M*(e*m-u*b)+d*(e*l-u*h)),t[2]=a*(s*m-c*b)-i*(e*m-u*b)+d*(e*c-u*s),t[3]=-(a*(s*l-c*h)-i*(e*l-u*h)+M*(e*c-u*s)),t[4]=-(o*(h*m-l*b)-f*(s*m-c*b)+v*(s*l-c*h)),t[5]=r*(h*m-l*b)-f*(e*m-u*b)+v*(e*l-u*h),t[6]=-(r*(s*m-c*b)-o*(e*m-u*b)+v*(e*c-u*s)),t[7]=r*(s*l-c*h)-o*(e*l-u*h)+f*(e*c-u*s),t[8]=o*(M*m-l*d)-f*(i*m-c*d)+v*(i*l-c*M),t[9]=-(r*(M*m-l*d)-f*(a*m-u*d)+v*(a*l-u*M)),t[10]=r*(i*m-c*d)-o*(a*m-u*d)+v*(a*c-u*i),t[11]=-(r*(i*l-c*M)-o*(a*l-u*M)+f*(a*c-u*i)),t[12]=-(o*(M*b-h*d)-f*(i*b-s*d)+v*(i*h-s*M)),t[13]=r*(M*b-h*d)-f*(a*b-e*d)+v*(a*h-e*M),t[14]=-(r*(i*b-s*d)-o*(a*b-e*d)+v*(a*s-e*i)),t[15]=r*(i*h-s*M)-o*(a*h-e*M)+f*(a*s-e*i),t},n.determinant=function(t){var n=t[0],r=t[1],a=t[2],e=t[3],u=t[4],o=t[5],i=t[6],s=t[7],c=t[8],f=t[9],M=t[10],h=t[11],l=t[12],v=t[13],d=t[14],b=t[15];return(n*o-r*u)*(M*b-h*d)-(n*i-a*u)*(f*b-h*v)+(n*s-e*u)*(f*d-M*v)+(r*i-a*o)*(c*b-h*l)-(r*s-e*o)*(c*d-M*l)+(a*s-e*i)*(c*v-f*l)},n.multiply=u,n.translate=function(t,n,r){var a=r[0],e=r[1],u=r[2],o=void 0,i=void 0,s=void 0,c=void 0,f=void 0,M=void 0,h=void 0,l=void 0,v=void 0,d=void 0,b=void 0,m=void 0;n===t?(t[12]=n[0]*a+n[4]*e+n[8]*u+n[12],t[13]=n[1]*a+n[5]*e+n[9]*u+n[13],t[14]=n[2]*a+n[6]*e+n[10]*u+n[14],t[15]=n[3]*a+n[7]*e+n[11]*u+n[15]):(o=n[0],i=n[1],s=n[2],c=n[3],f=n[4],M=n[5],h=n[6],l=n[7],v=n[8],d=n[9],b=n[10],m=n[11],t[0]=o,t[1]=i,t[2]=s,t[3]=c,t[4]=f,t[5]=M,t[6]=h,t[7]=l,t[8]=v,t[9]=d,t[10]=b,t[11]=m,t[12]=o*a+f*e+v*u+n[12],t[13]=i*a+M*e+d*u+n[13],t[14]=s*a+h*e+b*u+n[14],t[15]=c*a+l*e+m*u+n[15]);return t},n.scale=function(t,n,r){var a=r[0],e=r[1],u=r[2];return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*e,t[5]=n[5]*e,t[6]=n[6]*e,t[7]=n[7]*e,t[8]=n[8]*u,t[9]=n[9]*u,t[10]=n[10]*u,t[11]=n[11]*u,t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},n.rotate=function(t,n,r,e){var u=e[0],o=e[1],i=e[2],s=Math.sqrt(u*u+o*o+i*i),c=void 0,f=void 0,M=void 0,h=void 0,l=void 0,v=void 0,d=void 0,b=void 0,m=void 0,p=void 0,P=void 0,A=void 0,E=void 0,O=void 0,R=void 0,y=void 0,q=void 0,x=void 0,_=void 0,Y=void 0,L=void 0,S=void 0,w=void 0,I=void 0;if(s<a.EPSILON)return null;u*=s=1/s,o*=s,i*=s,c=Math.sin(r),f=Math.cos(r),M=1-f,h=n[0],l=n[1],v=n[2],d=n[3],b=n[4],m=n[5],p=n[6],P=n[7],A=n[8],E=n[9],O=n[10],R=n[11],y=u*u*M+f,q=o*u*M+i*c,x=i*u*M-o*c,_=u*o*M-i*c,Y=o*o*M+f,L=i*o*M+u*c,S=u*i*M+o*c,w=o*i*M-u*c,I=i*i*M+f,t[0]=h*y+b*q+A*x,t[1]=l*y+m*q+E*x,t[2]=v*y+p*q+O*x,t[3]=d*y+P*q+R*x,t[4]=h*_+b*Y+A*L,t[5]=l*_+m*Y+E*L,t[6]=v*_+p*Y+O*L,t[7]=d*_+P*Y+R*L,t[8]=h*S+b*w+A*I,t[9]=l*S+m*w+E*I,t[10]=v*S+p*w+O*I,t[11]=d*S+P*w+R*I,n!==t&&(t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]);return t},n.rotateX=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[4],o=n[5],i=n[6],s=n[7],c=n[8],f=n[9],M=n[10],h=n[11];n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]);return t[4]=u*e+c*a,t[5]=o*e+f*a,t[6]=i*e+M*a,t[7]=s*e+h*a,t[8]=c*e-u*a,t[9]=f*e-o*a,t[10]=M*e-i*a,t[11]=h*e-s*a,t},n.rotateY=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[0],o=n[1],i=n[2],s=n[3],c=n[8],f=n[9],M=n[10],h=n[11];n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]);return t[0]=u*e-c*a,t[1]=o*e-f*a,t[2]=i*e-M*a,t[3]=s*e-h*a,t[8]=u*a+c*e,t[9]=o*a+f*e,t[10]=i*a+M*e,t[11]=s*a+h*e,t},n.rotateZ=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[0],o=n[1],i=n[2],s=n[3],c=n[4],f=n[5],M=n[6],h=n[7];n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]);return t[0]=u*e+c*a,t[1]=o*e+f*a,t[2]=i*e+M*a,t[3]=s*e+h*a,t[4]=c*e-u*a,t[5]=f*e-o*a,t[6]=M*e-i*a,t[7]=h*e-s*a,t},n.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t},n.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromRotation=function(t,n,r){var e=r[0],u=r[1],o=r[2],i=Math.sqrt(e*e+u*u+o*o),s=void 0,c=void 0,f=void 0;if(i<a.EPSILON)return null;return e*=i=1/i,u*=i,o*=i,s=Math.sin(n),c=Math.cos(n),f=1-c,t[0]=e*e*f+c,t[1]=u*e*f+o*s,t[2]=o*e*f-u*s,t[3]=0,t[4]=e*u*f-o*s,t[5]=u*u*f+c,t[6]=o*u*f+e*s,t[7]=0,t[8]=e*o*f+u*s,t[9]=u*o*f-e*s,t[10]=o*o*f+c,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromXRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=a,t[6]=r,t[7]=0,t[8]=0,t[9]=-r,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromYRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=0,t[2]=-r,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=r,t[9]=0,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromZRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=0,t[3]=0,t[4]=-r,t[5]=a,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromRotationTranslation=o,n.fromQuat2=function(t,n){var r=new a.ARRAY_TYPE(3),e=-n[0],u=-n[1],i=-n[2],s=n[3],c=n[4],f=n[5],M=n[6],h=n[7],l=e*e+u*u+i*i+s*s;l>0?(r[0]=2*(c*s+h*e+f*i-M*u)/l,r[1]=2*(f*s+h*u+M*e-c*i)/l,r[2]=2*(M*s+h*i+c*u-f*e)/l):(r[0]=2*(c*s+h*e+f*i-M*u),r[1]=2*(f*s+h*u+M*e-c*i),r[2]=2*(M*s+h*i+c*u-f*e));return o(t,n,r),t},n.getTranslation=function(t,n){return t[0]=n[12],t[1]=n[13],t[2]=n[14],t},n.getScaling=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[4],o=n[5],i=n[6],s=n[8],c=n[9],f=n[10];return t[0]=Math.sqrt(r*r+a*a+e*e),t[1]=Math.sqrt(u*u+o*o+i*i),t[2]=Math.sqrt(s*s+c*c+f*f),t},n.getRotation=function(t,n){var r=n[0]+n[5]+n[10],a=0;r>0?(a=2*Math.sqrt(r+1),t[3]=.25*a,t[0]=(n[6]-n[9])/a,t[1]=(n[8]-n[2])/a,t[2]=(n[1]-n[4])/a):n[0]>n[5]&&n[0]>n[10]?(a=2*Math.sqrt(1+n[0]-n[5]-n[10]),t[3]=(n[6]-n[9])/a,t[0]=.25*a,t[1]=(n[1]+n[4])/a,t[2]=(n[8]+n[2])/a):n[5]>n[10]?(a=2*Math.sqrt(1+n[5]-n[0]-n[10]),t[3]=(n[8]-n[2])/a,t[0]=(n[1]+n[4])/a,t[1]=.25*a,t[2]=(n[6]+n[9])/a):(a=2*Math.sqrt(1+n[10]-n[0]-n[5]),t[3]=(n[1]-n[4])/a,t[0]=(n[8]+n[2])/a,t[1]=(n[6]+n[9])/a,t[2]=.25*a);return t},n.fromRotationTranslationScale=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=n[3],s=e+e,c=u+u,f=o+o,M=e*s,h=e*c,l=e*f,v=u*c,d=u*f,b=o*f,m=i*s,p=i*c,P=i*f,A=a[0],E=a[1],O=a[2];return t[0]=(1-(v+b))*A,t[1]=(h+P)*A,t[2]=(l-p)*A,t[3]=0,t[4]=(h-P)*E,t[5]=(1-(M+b))*E,t[6]=(d+m)*E,t[7]=0,t[8]=(l+p)*O,t[9]=(d-m)*O,t[10]=(1-(M+v))*O,t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t},n.fromRotationTranslationScaleOrigin=function(t,n,r,a,e){var u=n[0],o=n[1],i=n[2],s=n[3],c=u+u,f=o+o,M=i+i,h=u*c,l=u*f,v=u*M,d=o*f,b=o*M,m=i*M,p=s*c,P=s*f,A=s*M,E=a[0],O=a[1],R=a[2],y=e[0],q=e[1],x=e[2],_=(1-(d+m))*E,Y=(l+A)*E,L=(v-P)*E,S=(l-A)*O,w=(1-(h+m))*O,I=(b+p)*O,N=(v+P)*R,g=(b-p)*R,T=(1-(h+d))*R;return t[0]=_,t[1]=Y,t[2]=L,t[3]=0,t[4]=S,t[5]=w,t[6]=I,t[7]=0,t[8]=N,t[9]=g,t[10]=T,t[11]=0,t[12]=r[0]+y-(_*y+S*q+N*x),t[13]=r[1]+q-(Y*y+w*q+g*x),t[14]=r[2]+x-(L*y+I*q+T*x),t[15]=1,t},n.fromQuat=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r+r,i=a+a,s=e+e,c=r*o,f=a*o,M=a*i,h=e*o,l=e*i,v=e*s,d=u*o,b=u*i,m=u*s;return t[0]=1-M-v,t[1]=f+m,t[2]=h-b,t[3]=0,t[4]=f-m,t[5]=1-c-v,t[6]=l+d,t[7]=0,t[8]=h+b,t[9]=l-d,t[10]=1-c-M,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.frustum=function(t,n,r,a,e,u,o){var i=1/(r-n),s=1/(e-a),c=1/(u-o);return t[0]=2*u*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*u*s,t[6]=0,t[7]=0,t[8]=(r+n)*i,t[9]=(e+a)*s,t[10]=(o+u)*c,t[11]=-1,t[12]=0,t[13]=0,t[14]=o*u*2*c,t[15]=0,t},n.perspective=function(t,n,r,a,e){var u=1/Math.tan(n/2),o=void 0;t[0]=u/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=e&&e!==1/0?(o=1/(a-e),t[10]=(e+a)*o,t[14]=2*e*a*o):(t[10]=-1,t[14]=-2*a);return t},n.perspectiveFromFieldOfView=function(t,n,r,a){var e=Math.tan(n.upDegrees*Math.PI/180),u=Math.tan(n.downDegrees*Math.PI/180),o=Math.tan(n.leftDegrees*Math.PI/180),i=Math.tan(n.rightDegrees*Math.PI/180),s=2/(o+i),c=2/(e+u);return t[0]=s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=c,t[6]=0,t[7]=0,t[8]=-(o-i)*s*.5,t[9]=(e-u)*c*.5,t[10]=a/(r-a),t[11]=-1,t[12]=0,t[13]=0,t[14]=a*r/(r-a),t[15]=0,t},n.ortho=function(t,n,r,a,e,u,o){var i=1/(n-r),s=1/(a-e),c=1/(u-o);return t[0]=-2*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*s,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*c,t[11]=0,t[12]=(n+r)*i,t[13]=(e+a)*s,t[14]=(o+u)*c,t[15]=1,t},n.lookAt=function(t,n,r,u){var o=void 0,i=void 0,s=void 0,c=void 0,f=void 0,M=void 0,h=void 0,l=void 0,v=void 0,d=void 0,b=n[0],m=n[1],p=n[2],P=u[0],A=u[1],E=u[2],O=r[0],R=r[1],y=r[2];if(Math.abs(b-O)<a.EPSILON&&Math.abs(m-R)<a.EPSILON&&Math.abs(p-y)<a.EPSILON)return e(t);h=b-O,l=m-R,v=p-y,d=1/Math.sqrt(h*h+l*l+v*v),o=A*(v*=d)-E*(l*=d),i=E*(h*=d)-P*v,s=P*l-A*h,(d=Math.sqrt(o*o+i*i+s*s))?(o*=d=1/d,i*=d,s*=d):(o=0,i=0,s=0);c=l*s-v*i,f=v*o-h*s,M=h*i-l*o,(d=Math.sqrt(c*c+f*f+M*M))?(c*=d=1/d,f*=d,M*=d):(c=0,f=0,M=0);return t[0]=o,t[1]=c,t[2]=h,t[3]=0,t[4]=i,t[5]=f,t[6]=l,t[7]=0,t[8]=s,t[9]=M,t[10]=v,t[11]=0,t[12]=-(o*b+i*m+s*p),t[13]=-(c*b+f*m+M*p),t[14]=-(h*b+l*m+v*p),t[15]=1,t},n.targetTo=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=a[0],s=a[1],c=a[2],f=e-r[0],M=u-r[1],h=o-r[2],l=f*f+M*M+h*h;l>0&&(l=1/Math.sqrt(l),f*=l,M*=l,h*=l);var v=s*h-c*M,d=c*f-i*h,b=i*M-s*f;(l=v*v+d*d+b*b)>0&&(l=1/Math.sqrt(l),v*=l,d*=l,b*=l);return t[0]=v,t[1]=d,t[2]=b,t[3]=0,t[4]=M*b-h*d,t[5]=h*v-f*b,t[6]=f*d-M*v,t[7]=0,t[8]=f,t[9]=M,t[10]=h,t[11]=0,t[12]=e,t[13]=u,t[14]=o,t[15]=1,t},n.str=function(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"},n.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2)+Math.pow(t[9],2)+Math.pow(t[10],2)+Math.pow(t[11],2)+Math.pow(t[12],2)+Math.pow(t[13],2)+Math.pow(t[14],2)+Math.pow(t[15],2))},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t[4]=n[4]+r[4],t[5]=n[5]+r[5],t[6]=n[6]+r[6],t[7]=n[7]+r[7],t[8]=n[8]+r[8],t[9]=n[9]+r[9],t[10]=n[10]+r[10],t[11]=n[11]+r[11],t[12]=n[12]+r[12],t[13]=n[13]+r[13],t[14]=n[14]+r[14],t[15]=n[15]+r[15],t},n.subtract=i,n.multiplyScalar=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=n[7]*r,t[8]=n[8]*r,t[9]=n[9]*r,t[10]=n[10]*r,t[11]=n[11]*r,t[12]=n[12]*r,t[13]=n[13]*r,t[14]=n[14]*r,t[15]=n[15]*r,t},n.multiplyScalarAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t[4]=n[4]+r[4]*a,t[5]=n[5]+r[5]*a,t[6]=n[6]+r[6]*a,t[7]=n[7]+r[7]*a,t[8]=n[8]+r[8]*a,t[9]=n[9]+r[9]*a,t[10]=n[10]+r[10]*a,t[11]=n[11]+r[11]*a,t[12]=n[12]+r[12]*a,t[13]=n[13]+r[13]*a,t[14]=n[14]+r[14]*a,t[15]=n[15]+r[15]*a,t},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]&&t[9]===n[9]&&t[10]===n[10]&&t[11]===n[11]&&t[12]===n[12]&&t[13]===n[13]&&t[14]===n[14]&&t[15]===n[15]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=t[4],s=t[5],c=t[6],f=t[7],M=t[8],h=t[9],l=t[10],v=t[11],d=t[12],b=t[13],m=t[14],p=t[15],P=n[0],A=n[1],E=n[2],O=n[3],R=n[4],y=n[5],q=n[6],x=n[7],_=n[8],Y=n[9],L=n[10],S=n[11],w=n[12],I=n[13],N=n[14],g=n[15];return Math.abs(r-P)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(P))&&Math.abs(e-A)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(A))&&Math.abs(u-E)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(E))&&Math.abs(o-O)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(O))&&Math.abs(i-R)<=a.EPSILON*Math.max(1,Math.abs(i),Math.abs(R))&&Math.abs(s-y)<=a.EPSILON*Math.max(1,Math.abs(s),Math.abs(y))&&Math.abs(c-q)<=a.EPSILON*Math.max(1,Math.abs(c),Math.abs(q))&&Math.abs(f-x)<=a.EPSILON*Math.max(1,Math.abs(f),Math.abs(x))&&Math.abs(M-_)<=a.EPSILON*Math.max(1,Math.abs(M),Math.abs(_))&&Math.abs(h-Y)<=a.EPSILON*Math.max(1,Math.abs(h),Math.abs(Y))&&Math.abs(l-L)<=a.EPSILON*Math.max(1,Math.abs(l),Math.abs(L))&&Math.abs(v-S)<=a.EPSILON*Math.max(1,Math.abs(v),Math.abs(S))&&Math.abs(d-w)<=a.EPSILON*Math.max(1,Math.abs(d),Math.abs(w))&&Math.abs(b-I)<=a.EPSILON*Math.max(1,Math.abs(b),Math.abs(I))&&Math.abs(m-N)<=a.EPSILON*Math.max(1,Math.abs(m),Math.abs(N))&&Math.abs(p-g)<=a.EPSILON*Math.max(1,Math.abs(p),Math.abs(g))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function u(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=n[6],f=n[7],M=n[8],h=n[9],l=n[10],v=n[11],d=n[12],b=n[13],m=n[14],p=n[15],P=r[0],A=r[1],E=r[2],O=r[3];return t[0]=P*a+A*i+E*M+O*d,t[1]=P*e+A*s+E*h+O*b,t[2]=P*u+A*c+E*l+O*m,t[3]=P*o+A*f+E*v+O*p,P=r[4],A=r[5],E=r[6],O=r[7],t[4]=P*a+A*i+E*M+O*d,t[5]=P*e+A*s+E*h+O*b,t[6]=P*u+A*c+E*l+O*m,t[7]=P*o+A*f+E*v+O*p,P=r[8],A=r[9],E=r[10],O=r[11],t[8]=P*a+A*i+E*M+O*d,t[9]=P*e+A*s+E*h+O*b,t[10]=P*u+A*c+E*l+O*m,t[11]=P*o+A*f+E*v+O*p,P=r[12],A=r[13],E=r[14],O=r[15],t[12]=P*a+A*i+E*M+O*d,t[13]=P*e+A*s+E*h+O*b,t[14]=P*u+A*c+E*l+O*m,t[15]=P*o+A*f+E*v+O*p,t}function o(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=a+a,s=e+e,c=u+u,f=a*i,M=a*s,h=a*c,l=e*s,v=e*c,d=u*c,b=o*i,m=o*s,p=o*c;return t[0]=1-(l+d),t[1]=M+p,t[2]=h-m,t[3]=0,t[4]=M-p,t[5]=1-(f+d),t[6]=v+b,t[7]=0,t[8]=h+m,t[9]=v-b,t[10]=1-(f+l),t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t}function i(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t[4]=n[4]-r[4],t[5]=n[5]-r[5],t[6]=n[6]-r[6],t[7]=n[7]-r[7],t[8]=n[8]-r[8],t[9]=n[9]-r[9],t[10]=n[10]-r[10],t[11]=n[11]-r[11],t[12]=n[12]-r[12],t[13]=n[13]-r[13],t[14]=n[14]-r[14],t[15]=n[15]-r[15],t}n.mul=u,n.sub=i},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=function(){var t=new a.ARRAY_TYPE(9);a.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0);return t[0]=1,t[4]=1,t[8]=1,t},n.fromMat4=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[4],t[4]=n[5],t[5]=n[6],t[6]=n[8],t[7]=n[9],t[8]=n[10],t},n.clone=function(t){var n=new a.ARRAY_TYPE(9);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},n.fromValues=function(t,n,r,e,u,o,i,s,c){var f=new a.ARRAY_TYPE(9);return f[0]=t,f[1]=n,f[2]=r,f[3]=e,f[4]=u,f[5]=o,f[6]=i,f[7]=s,f[8]=c,f},n.set=function(t,n,r,a,e,u,o,i,s,c){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t[4]=u,t[5]=o,t[6]=i,t[7]=s,t[8]=c,t},n.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},n.transpose=function(t,n){if(t===n){var r=n[1],a=n[2],e=n[5];t[1]=n[3],t[2]=n[6],t[3]=r,t[5]=n[7],t[6]=a,t[7]=e}else t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8];return t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8],M=f*o-i*c,h=-f*u+i*s,l=c*u-o*s,v=r*M+a*h+e*l;if(!v)return null;return v=1/v,t[0]=M*v,t[1]=(-f*a+e*c)*v,t[2]=(i*a-e*o)*v,t[3]=h*v,t[4]=(f*r-e*s)*v,t[5]=(-i*r+e*u)*v,t[6]=l*v,t[7]=(-c*r+a*s)*v,t[8]=(o*r-a*u)*v,t},n.adjoint=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8];return t[0]=o*f-i*c,t[1]=e*c-a*f,t[2]=a*i-e*o,t[3]=i*s-u*f,t[4]=r*f-e*s,t[5]=e*u-r*i,t[6]=u*c-o*s,t[7]=a*s-r*c,t[8]=r*o-a*u,t},n.determinant=function(t){var n=t[0],r=t[1],a=t[2],e=t[3],u=t[4],o=t[5],i=t[6],s=t[7],c=t[8];return n*(c*u-o*s)+r*(-c*e+o*i)+a*(s*e-u*i)},n.multiply=e,n.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=n[6],f=n[7],M=n[8],h=r[0],l=r[1];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=i,t[5]=s,t[6]=h*a+l*o+c,t[7]=h*e+l*i+f,t[8]=h*u+l*s+M,t},n.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=n[6],f=n[7],M=n[8],h=Math.sin(r),l=Math.cos(r);return t[0]=l*a+h*o,t[1]=l*e+h*i,t[2]=l*u+h*s,t[3]=l*o-h*a,t[4]=l*i-h*e,t[5]=l*s-h*u,t[6]=c,t[7]=f,t[8]=M,t},n.scale=function(t,n,r){var a=r[0],e=r[1];return t[0]=a*n[0],t[1]=a*n[1],t[2]=a*n[2],t[3]=e*n[3],t[4]=e*n[4],t[5]=e*n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},n.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=n[0],t[7]=n[1],t[8]=1,t},n.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=0,t[3]=-r,t[4]=a,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},n.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=n[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},n.fromMat2d=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=0,t[3]=n[2],t[4]=n[3],t[5]=0,t[6]=n[4],t[7]=n[5],t[8]=1,t},n.fromQuat=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r+r,i=a+a,s=e+e,c=r*o,f=a*o,M=a*i,h=e*o,l=e*i,v=e*s,d=u*o,b=u*i,m=u*s;return t[0]=1-M-v,t[3]=f-m,t[6]=h+b,t[1]=f+m,t[4]=1-c-v,t[7]=l-d,t[2]=h-b,t[5]=l+d,t[8]=1-c-M,t},n.normalFromMat4=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8],M=n[9],h=n[10],l=n[11],v=n[12],d=n[13],b=n[14],m=n[15],p=r*i-a*o,P=r*s-e*o,A=r*c-u*o,E=a*s-e*i,O=a*c-u*i,R=e*c-u*s,y=f*d-M*v,q=f*b-h*v,x=f*m-l*v,_=M*b-h*d,Y=M*m-l*d,L=h*m-l*b,S=p*L-P*Y+A*_+E*x-O*q+R*y;if(!S)return null;return S=1/S,t[0]=(i*L-s*Y+c*_)*S,t[1]=(s*x-o*L-c*q)*S,t[2]=(o*Y-i*x+c*y)*S,t[3]=(e*Y-a*L-u*_)*S,t[4]=(r*L-e*x+u*q)*S,t[5]=(a*x-r*Y-u*y)*S,t[6]=(d*R-b*O+m*E)*S,t[7]=(b*A-v*R-m*P)*S,t[8]=(v*O-d*A+m*p)*S,t},n.projection=function(t,n,r){return t[0]=2/n,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/r,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t},n.str=function(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"},n.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2))},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t[4]=n[4]+r[4],t[5]=n[5]+r[5],t[6]=n[6]+r[6],t[7]=n[7]+r[7],t[8]=n[8]+r[8],t},n.subtract=u,n.multiplyScalar=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=n[7]*r,t[8]=n[8]*r,t},n.multiplyScalarAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t[4]=n[4]+r[4]*a,t[5]=n[5]+r[5]*a,t[6]=n[6]+r[6]*a,t[7]=n[7]+r[7]*a,t[8]=n[8]+r[8]*a,t},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=t[4],s=t[5],c=t[6],f=t[7],M=t[8],h=n[0],l=n[1],v=n[2],d=n[3],b=n[4],m=n[5],p=n[6],P=n[7],A=n[8];return Math.abs(r-h)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(e-l)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(l))&&Math.abs(u-v)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(v))&&Math.abs(o-d)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(d))&&Math.abs(i-b)<=a.EPSILON*Math.max(1,Math.abs(i),Math.abs(b))&&Math.abs(s-m)<=a.EPSILON*Math.max(1,Math.abs(s),Math.abs(m))&&Math.abs(c-p)<=a.EPSILON*Math.max(1,Math.abs(c),Math.abs(p))&&Math.abs(f-P)<=a.EPSILON*Math.max(1,Math.abs(f),Math.abs(P))&&Math.abs(M-A)<=a.EPSILON*Math.max(1,Math.abs(M),Math.abs(A))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=n[6],f=n[7],M=n[8],h=r[0],l=r[1],v=r[2],d=r[3],b=r[4],m=r[5],p=r[6],P=r[7],A=r[8];return t[0]=h*a+l*o+v*c,t[1]=h*e+l*i+v*f,t[2]=h*u+l*s+v*M,t[3]=d*a+b*o+m*c,t[4]=d*e+b*i+m*f,t[5]=d*u+b*s+m*M,t[6]=p*a+P*o+A*c,t[7]=p*e+P*i+A*f,t[8]=p*u+P*s+A*M,t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t[4]=n[4]-r[4],t[5]=n[5]-r[5],t[6]=n[6]-r[6],t[7]=n[7]-r[7],t[8]=n[8]-r[8],t}n.mul=e,n.sub=u},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.forEach=n.sqrLen=n.sqrDist=n.dist=n.div=n.mul=n.sub=n.len=void 0,n.create=e,n.clone=function(t){var n=new a.ARRAY_TYPE(2);return n[0]=t[0],n[1]=t[1],n},n.fromValues=function(t,n){var r=new a.ARRAY_TYPE(2);return r[0]=t,r[1]=n,r},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t},n.set=function(t,n,r){return t[0]=n,t[1]=r,t},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t},n.subtract=u,n.multiply=o,n.divide=i,n.ceil=function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t},n.floor=function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t},n.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t},n.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t},n.round=function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t},n.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t},n.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t},n.distance=s,n.squaredDistance=c,n.length=f,n.squaredLength=M,n.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t},n.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t},n.normalize=function(t,n){var r=n[0],a=n[1],e=r*r+a*a;e>0&&(e=1/Math.sqrt(e),t[0]=n[0]*e,t[1]=n[1]*e);return t},n.dot=function(t,n){return t[0]*n[0]+t[1]*n[1]},n.cross=function(t,n,r){var a=n[0]*r[1]-n[1]*r[0];return t[0]=t[1]=0,t[2]=a,t},n.lerp=function(t,n,r,a){var e=n[0],u=n[1];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t},n.random=function(t,n){n=n||1;var r=2*a.RANDOM()*Math.PI;return t[0]=Math.cos(r)*n,t[1]=Math.sin(r)*n,t},n.transformMat2=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[2]*e,t[1]=r[1]*a+r[3]*e,t},n.transformMat2d=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[2]*e+r[4],t[1]=r[1]*a+r[3]*e+r[5],t},n.transformMat3=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[3]*e+r[6],t[1]=r[1]*a+r[4]*e+r[7],t},n.transformMat4=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[4]*e+r[12],t[1]=r[1]*a+r[5]*e+r[13],t},n.rotate=function(t,n,r,a){var e=n[0]-r[0],u=n[1]-r[1],o=Math.sin(a),i=Math.cos(a);return t[0]=e*i-u*o+r[0],t[1]=e*o+u*i+r[1],t},n.angle=function(t,n){var r=t[0],a=t[1],e=n[0],u=n[1],o=r*r+a*a;o>0&&(o=1/Math.sqrt(o));var i=e*e+u*u;i>0&&(i=1/Math.sqrt(i));var s=(r*e+a*u)*o*i;return s>1?0:s<-1?Math.PI:Math.acos(s)},n.str=function(t){return"vec2("+t[0]+", "+t[1]+")"},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]},n.equals=function(t,n){var r=t[0],e=t[1],u=n[0],o=n[1];return Math.abs(r-u)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(u))&&Math.abs(e-o)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(o))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(){var t=new a.ARRAY_TYPE(2);return a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0),t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t}function o(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t}function i(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t}function s(t,n){var r=n[0]-t[0],a=n[1]-t[1];return Math.sqrt(r*r+a*a)}function c(t,n){var r=n[0]-t[0],a=n[1]-t[1];return r*r+a*a}function f(t){var n=t[0],r=t[1];return Math.sqrt(n*n+r*r)}function M(t){var n=t[0],r=t[1];return n*n+r*r}n.len=f,n.sub=u,n.mul=o,n.div=i,n.dist=s,n.sqrDist=c,n.sqrLen=M,n.forEach=function(){var t=e();return function(n,r,a,e,u,o){var i=void 0,s=void 0;for(r||(r=2),a||(a=0),s=e?Math.min(e*r+a,n.length):n.length,i=a;i<s;i+=r)t[0]=n[i],t[1]=n[i+1],u(t,t,o),n[i]=t[0],n[i+1]=t[1];return n}}()},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sqrLen=n.squaredLength=n.len=n.length=n.dot=n.mul=n.setReal=n.getReal=void 0,n.create=function(){var t=new a.ARRAY_TYPE(8);a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0);return t[3]=1,t},n.clone=function(t){var n=new a.ARRAY_TYPE(8);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n},n.fromValues=function(t,n,r,e,u,o,i,s){var c=new a.ARRAY_TYPE(8);return c[0]=t,c[1]=n,c[2]=r,c[3]=e,c[4]=u,c[5]=o,c[6]=i,c[7]=s,c},n.fromRotationTranslationValues=function(t,n,r,e,u,o,i){var s=new a.ARRAY_TYPE(8);s[0]=t,s[1]=n,s[2]=r,s[3]=e;var c=.5*u,f=.5*o,M=.5*i;return s[4]=c*e+f*r-M*n,s[5]=f*e+M*t-c*r,s[6]=M*e+c*n-f*t,s[7]=-c*t-f*n-M*r,s},n.fromRotationTranslation=i,n.fromTranslation=function(t,n){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=.5*n[0],t[5]=.5*n[1],t[6]=.5*n[2],t[7]=0,t},n.fromRotation=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=0,t[5]=0,t[6]=0,t[7]=0,t},n.fromMat4=function(t,n){var r=e.create();u.getRotation(r,n);var o=new a.ARRAY_TYPE(3);return u.getTranslation(o,n),i(t,r,o),t},n.copy=s,n.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t},n.set=function(t,n,r,a,e,u,o,i,s){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t[4]=u,t[5]=o,t[6]=i,t[7]=s,t},n.getDual=function(t,n){return t[0]=n[4],t[1]=n[5],t[2]=n[6],t[3]=n[7],t},n.setDual=function(t,n){return t[4]=n[0],t[5]=n[1],t[6]=n[2],t[7]=n[3],t},n.getTranslation=function(t,n){var r=n[4],a=n[5],e=n[6],u=n[7],o=-n[0],i=-n[1],s=-n[2],c=n[3];return t[0]=2*(r*c+u*o+a*s-e*i),t[1]=2*(a*c+u*i+e*o-r*s),t[2]=2*(e*c+u*s+r*i-a*o),t},n.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=.5*r[0],s=.5*r[1],c=.5*r[2],f=n[4],M=n[5],h=n[6],l=n[7];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=o*i+e*c-u*s+f,t[5]=o*s+u*i-a*c+M,t[6]=o*c+a*s-e*i+h,t[7]=-a*i-e*s-u*c+l,t},n.rotateX=function(t,n,r){var a=-n[0],u=-n[1],o=-n[2],i=n[3],s=n[4],c=n[5],f=n[6],M=n[7],h=s*i+M*a+c*o-f*u,l=c*i+M*u+f*a-s*o,v=f*i+M*o+s*u-c*a,d=M*i-s*a-c*u-f*o;return e.rotateX(t,n,r),a=t[0],u=t[1],o=t[2],i=t[3],t[4]=h*i+d*a+l*o-v*u,t[5]=l*i+d*u+v*a-h*o,t[6]=v*i+d*o+h*u-l*a,t[7]=d*i-h*a-l*u-v*o,t},n.rotateY=function(t,n,r){var a=-n[0],u=-n[1],o=-n[2],i=n[3],s=n[4],c=n[5],f=n[6],M=n[7],h=s*i+M*a+c*o-f*u,l=c*i+M*u+f*a-s*o,v=f*i+M*o+s*u-c*a,d=M*i-s*a-c*u-f*o;return e.rotateY(t,n,r),a=t[0],u=t[1],o=t[2],i=t[3],t[4]=h*i+d*a+l*o-v*u,t[5]=l*i+d*u+v*a-h*o,t[6]=v*i+d*o+h*u-l*a,t[7]=d*i-h*a-l*u-v*o,t},n.rotateZ=function(t,n,r){var a=-n[0],u=-n[1],o=-n[2],i=n[3],s=n[4],c=n[5],f=n[6],M=n[7],h=s*i+M*a+c*o-f*u,l=c*i+M*u+f*a-s*o,v=f*i+M*o+s*u-c*a,d=M*i-s*a-c*u-f*o;return e.rotateZ(t,n,r),a=t[0],u=t[1],o=t[2],i=t[3],t[4]=h*i+d*a+l*o-v*u,t[5]=l*i+d*u+v*a-h*o,t[6]=v*i+d*o+h*u-l*a,t[7]=d*i-h*a-l*u-v*o,t},n.rotateByQuatAppend=function(t,n,r){var a=r[0],e=r[1],u=r[2],o=r[3],i=n[0],s=n[1],c=n[2],f=n[3];return t[0]=i*o+f*a+s*u-c*e,t[1]=s*o+f*e+c*a-i*u,t[2]=c*o+f*u+i*e-s*a,t[3]=f*o-i*a-s*e-c*u,i=n[4],s=n[5],c=n[6],f=n[7],t[4]=i*o+f*a+s*u-c*e,t[5]=s*o+f*e+c*a-i*u,t[6]=c*o+f*u+i*e-s*a,t[7]=f*o-i*a-s*e-c*u,t},n.rotateByQuatPrepend=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],s=r[1],c=r[2],f=r[3];return t[0]=a*f+o*i+e*c-u*s,t[1]=e*f+o*s+u*i-a*c,t[2]=u*f+o*c+a*s-e*i,t[3]=o*f-a*i-e*s-u*c,i=r[4],s=r[5],c=r[6],f=r[7],t[4]=a*f+o*i+e*c-u*s,t[5]=e*f+o*s+u*i-a*c,t[6]=u*f+o*c+a*s-e*i,t[7]=o*f-a*i-e*s-u*c,t},n.rotateAroundAxis=function(t,n,r,e){if(Math.abs(e)<a.EPSILON)return s(t,n);var u=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);e*=.5;var o=Math.sin(e),i=o*r[0]/u,c=o*r[1]/u,f=o*r[2]/u,M=Math.cos(e),h=n[0],l=n[1],v=n[2],d=n[3];t[0]=h*M+d*i+l*f-v*c,t[1]=l*M+d*c+v*i-h*f,t[2]=v*M+d*f+h*c-l*i,t[3]=d*M-h*i-l*c-v*f;var b=n[4],m=n[5],p=n[6],P=n[7];return t[4]=b*M+P*i+m*f-p*c,t[5]=m*M+P*c+p*i-b*f,t[6]=p*M+P*f+b*c-m*i,t[7]=P*M-b*i-m*c-p*f,t},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t[4]=n[4]+r[4],t[5]=n[5]+r[5],t[6]=n[6]+r[6],t[7]=n[7]+r[7],t},n.multiply=c,n.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=n[7]*r,t},n.lerp=function(t,n,r,a){var e=1-a;f(n,r)<0&&(a=-a);return t[0]=n[0]*e+r[0]*a,t[1]=n[1]*e+r[1]*a,t[2]=n[2]*e+r[2]*a,t[3]=n[3]*e+r[3]*a,t[4]=n[4]*e+r[4]*a,t[5]=n[5]*e+r[5]*a,t[6]=n[6]*e+r[6]*a,t[7]=n[7]*e+r[7]*a,t},n.invert=function(t,n){var r=h(n);return t[0]=-n[0]/r,t[1]=-n[1]/r,t[2]=-n[2]/r,t[3]=n[3]/r,t[4]=-n[4]/r,t[5]=-n[5]/r,t[6]=-n[6]/r,t[7]=n[7]/r,t},n.conjugate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t[4]=-n[4],t[5]=-n[5],t[6]=-n[6],t[7]=n[7],t},n.normalize=function(t,n){var r=h(n);if(r>0){r=Math.sqrt(r);var a=n[0]/r,e=n[1]/r,u=n[2]/r,o=n[3]/r,i=n[4],s=n[5],c=n[6],f=n[7],M=a*i+e*s+u*c+o*f;t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=(i-a*M)/r,t[5]=(s-e*M)/r,t[6]=(c-u*M)/r,t[7]=(f-o*M)/r}return t},n.str=function(t){return"quat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+")"},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=t[4],s=t[5],c=t[6],f=t[7],M=n[0],h=n[1],l=n[2],v=n[3],d=n[4],b=n[5],m=n[6],p=n[7];return Math.abs(r-M)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(M))&&Math.abs(e-h)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(h))&&Math.abs(u-l)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(l))&&Math.abs(o-v)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(v))&&Math.abs(i-d)<=a.EPSILON*Math.max(1,Math.abs(i),Math.abs(d))&&Math.abs(s-b)<=a.EPSILON*Math.max(1,Math.abs(s),Math.abs(b))&&Math.abs(c-m)<=a.EPSILON*Math.max(1,Math.abs(c),Math.abs(m))&&Math.abs(f-p)<=a.EPSILON*Math.max(1,Math.abs(f),Math.abs(p))};var a=o(r(0)),e=o(r(3)),u=o(r(4));function o(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}function i(t,n,r){var a=.5*r[0],e=.5*r[1],u=.5*r[2],o=n[0],i=n[1],s=n[2],c=n[3];return t[0]=o,t[1]=i,t[2]=s,t[3]=c,t[4]=a*c+e*s-u*i,t[5]=e*c+u*o-a*s,t[6]=u*c+a*i-e*o,t[7]=-a*o-e*i-u*s,t}function s(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t}n.getReal=e.copy;n.setReal=e.copy;function c(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[4],s=r[5],c=r[6],f=r[7],M=n[4],h=n[5],l=n[6],v=n[7],d=r[0],b=r[1],m=r[2],p=r[3];return t[0]=a*p+o*d+e*m-u*b,t[1]=e*p+o*b+u*d-a*m,t[2]=u*p+o*m+a*b-e*d,t[3]=o*p-a*d-e*b-u*m,t[4]=a*f+o*i+e*c-u*s+M*p+v*d+h*m-l*b,t[5]=e*f+o*s+u*i-a*c+h*p+v*b+l*d-M*m,t[6]=u*f+o*c+a*s-e*i+l*p+v*m+M*b-h*d,t[7]=o*f-a*i-e*s-u*c+v*p-M*d-h*b-l*m,t}n.mul=c;var f=n.dot=e.dot;var M=n.length=e.length,h=(n.len=M,n.squaredLength=e.squaredLength);n.sqrLen=h},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=function(){var t=new a.ARRAY_TYPE(6);a.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[4]=0,t[5]=0);return t[0]=1,t[3]=1,t},n.clone=function(t){var n=new a.ARRAY_TYPE(6);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t},n.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},n.fromValues=function(t,n,r,e,u,o){var i=new a.ARRAY_TYPE(6);return i[0]=t,i[1]=n,i[2]=r,i[3]=e,i[4]=u,i[5]=o,i},n.set=function(t,n,r,a,e,u,o){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t[4]=u,t[5]=o,t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=r*u-a*e;if(!s)return null;return s=1/s,t[0]=u*s,t[1]=-a*s,t[2]=-e*s,t[3]=r*s,t[4]=(e*i-u*o)*s,t[5]=(a*o-r*i)*s,t},n.determinant=function(t){return t[0]*t[3]-t[1]*t[2]},n.multiply=e,n.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=Math.sin(r),f=Math.cos(r);return t[0]=a*f+u*c,t[1]=e*f+o*c,t[2]=a*-c+u*f,t[3]=e*-c+o*f,t[4]=i,t[5]=s,t},n.scale=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=r[0],f=r[1];return t[0]=a*c,t[1]=e*c,t[2]=u*f,t[3]=o*f,t[4]=i,t[5]=s,t},n.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=r[0],f=r[1];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=a*c+u*f+i,t[5]=e*c+o*f+s,t},n.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=-r,t[3]=a,t[4]=0,t[5]=0,t},n.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t[4]=0,t[5]=0,t},n.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=n[0],t[5]=n[1],t},n.str=function(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"},n.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+1)},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t[4]=n[4]+r[4],t[5]=n[5]+r[5],t},n.subtract=u,n.multiplyScalar=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*r,t[5]=n[5]*r,t},n.multiplyScalarAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t[4]=n[4]+r[4]*a,t[5]=n[5]+r[5]*a,t},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=t[4],s=t[5],c=n[0],f=n[1],M=n[2],h=n[3],l=n[4],v=n[5];return Math.abs(r-c)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(e-f)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(f))&&Math.abs(u-M)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(M))&&Math.abs(o-h)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(h))&&Math.abs(i-l)<=a.EPSILON*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(s-v)<=a.EPSILON*Math.max(1,Math.abs(s),Math.abs(v))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=r[0],f=r[1],M=r[2],h=r[3],l=r[4],v=r[5];return t[0]=a*c+u*f,t[1]=e*c+o*f,t[2]=a*M+u*h,t[3]=e*M+o*h,t[4]=a*l+u*v+i,t[5]=e*l+o*v+s,t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t[4]=n[4]-r[4],t[5]=n[5]-r[5],t}n.mul=e,n.sub=u},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=function(){var t=new a.ARRAY_TYPE(4);a.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0);return t[0]=1,t[3]=1,t},n.clone=function(t){var n=new a.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t},n.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},n.fromValues=function(t,n,r,e){var u=new a.ARRAY_TYPE(4);return u[0]=t,u[1]=n,u[2]=r,u[3]=e,u},n.set=function(t,n,r,a,e){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t},n.transpose=function(t,n){if(t===n){var r=n[1];t[1]=n[2],t[2]=r}else t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3];return t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*u-e*a;if(!o)return null;return o=1/o,t[0]=u*o,t[1]=-a*o,t[2]=-e*o,t[3]=r*o,t},n.adjoint=function(t,n){var r=n[0];return t[0]=n[3],t[1]=-n[1],t[2]=-n[2],t[3]=r,t},n.determinant=function(t){return t[0]*t[3]-t[2]*t[1]},n.multiply=e,n.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),s=Math.cos(r);return t[0]=a*s+u*i,t[1]=e*s+o*i,t[2]=a*-i+u*s,t[3]=e*-i+o*s,t},n.scale=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],s=r[1];return t[0]=a*i,t[1]=e*i,t[2]=u*s,t[3]=o*s,t},n.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=-r,t[3]=a,t},n.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t},n.str=function(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},n.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2))},n.LDU=function(t,n,r,a){return t[2]=a[2]/a[0],r[0]=a[0],r[1]=a[1],r[3]=a[3]-t[2]*r[1],[t,n,r]},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t},n.subtract=u,n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=n[0],s=n[1],c=n[2],f=n[3];return Math.abs(r-i)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(e-s)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(s))&&Math.abs(u-c)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(c))&&Math.abs(o-f)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(f))},n.multiplyScalar=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t},n.multiplyScalarAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],s=r[1],c=r[2],f=r[3];return t[0]=a*i+u*s,t[1]=e*i+o*s,t[2]=a*c+u*f,t[3]=e*c+o*f,t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t}n.mul=e,n.sub=u},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.vec4=n.vec3=n.vec2=n.quat2=n.quat=n.mat4=n.mat3=n.mat2d=n.mat2=n.glMatrix=void 0;var a=l(r(0)),e=l(r(9)),u=l(r(8)),o=l(r(5)),i=l(r(4)),s=l(r(3)),c=l(r(7)),f=l(r(6)),M=l(r(2)),h=l(r(1));function l(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}n.glMatrix=a,n.mat2=e,n.mat2d=u,n.mat3=o,n.mat4=i,n.quat=s,n.quat2=c,n.vec2=f,n.vec3=M,n.vec4=h}])});
},{}],204:[function(require,module,exports){
'use strict';

var typeMap = {};
var types = require('./types');

// load all available handlers
types.forEach(function (type) {
  typeMap[type] = require('./types/' + type).detect;
});

module.exports = function (buffer, filepath) {
  var type, result;
  for (type in typeMap) {
    result = typeMap[type](buffer, filepath);
    if (result) {
      return type;
    }
  }
};

},{"./types":206}],205:[function(require,module,exports){
(function (Buffer){
'use strict';

var fs = require('fs');
var path = require('path');

var detector = require('./detector');

var handlers = {};
var types = require('./types');

// load all available handlers
types.forEach(function (type) {
  handlers[type] = require('./types/' + type);
});

// Maximum buffer size, with a default of 128 kilobytes.
// TO-DO: make this adaptive based on the initial signature of the image
var MaxBufferSize = 128*1024;

function lookup (buffer, filepath) {
  // detect the file type.. don't rely on the extension
  var type = detector(buffer, filepath);

  // find an appropriate handler for this file type
  if (type in handlers) {
    var size = handlers[type].calculate(buffer, filepath);
    if (size !== false) {
      size.type = type;
      return size;
    }
  }

  // throw up, if we don't understand the file
  throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');
}

function asyncFileToBuffer (filepath, callback) {
  // open the file in read only mode
  fs.open(filepath, 'r', function (err, descriptor) {
    if (err) { return callback(err); }
    var size = fs.fstatSync(descriptor).size;
    if (size <= 0){return callback(new Error("File size is not greater than 0 —— " + filepath)); }
    var bufferSize = Math.min(size, MaxBufferSize);
    var buffer = new Buffer(bufferSize);
    // read first buffer block from the file, asynchronously
    fs.read(descriptor, buffer, 0, bufferSize, 0, function (err) {
      if (err) { return callback(err); }
      // close the file, we are done
      fs.close(descriptor, function (err) {
        callback(err, buffer);
      });
    });
  });
}

function syncFileToBuffer (filepath) {
  // read from the file, synchronously
  var descriptor = fs.openSync(filepath, 'r');
  var size = fs.fstatSync(descriptor).size;
  var bufferSize = Math.min(size, MaxBufferSize);
  var buffer = new Buffer(bufferSize);
  fs.readSync(descriptor, buffer, 0, bufferSize, 0);
  fs.closeSync(descriptor);
  return buffer;
}

/**
 * @params input - buffer or relative/absolute path of the image file
 * @params callback - optional function for async detection
 */
module.exports = function (input, callback) {

  // Handle buffer input
  if (Buffer.isBuffer(input)) {
    return lookup(input);
  }

  // input should be a string at this point
  if (typeof input !== 'string') {
    throw new TypeError('invalid invocation');
  }

  // resolve the file path
  var filepath = path.resolve(input);

  if (typeof callback === 'function') {
    asyncFileToBuffer(filepath, function (err, buffer) {
      if (err) { return callback(err); }

      // return the dimensions
      var dimensions;
      try {
        dimensions = lookup(buffer, filepath);
      } catch (e) {
        err = e;
      }
      callback(err, dimensions);
    });
  } else {
    var buffer = syncFileToBuffer(filepath);
    return lookup(buffer, filepath);
  }
};

module.exports.types = types;

}).call(this,require("buffer").Buffer)
},{"./detector":204,"./types":206,"buffer":4,"fs":1,"path":11}],206:[function(require,module,exports){
'use strict';

module.exports = [
  'bmp',
  'gif',
  'jpg',
  'png',
  'psd',
  'svg',
  'tiff',
  'webp',
  'dds'
];

},{}],207:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

},{"./runtime":208}],208:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);

},{}],209:[function(require,module,exports){
(function () {
    var key, val, _ref, _ref1;
    exports.EncodeStream = require('./src/EncodeStream');
    exports.DecodeStream = require('./src/DecodeStream');
    exports.Array = require('./src/Array');
    exports.LazyArray = require('./src/LazyArray');
    exports.Bitfield = require('./src/Bitfield');
    exports.Boolean = require('./src/Boolean');
    exports.Buffer = require('./src/Buffer');
    exports.Enum = require('./src/Enum');
    exports.Optional = require('./src/Optional');
    exports.Reserved = require('./src/Reserved');
    exports.String = require('./src/String');
    exports.Struct = require('./src/Struct');
    exports.VersionedStruct = require('./src/VersionedStruct');
    _ref = require('./src/Number');
    for (key in _ref) {
        val = _ref[key];
        exports[key] = val;
    }
    _ref1 = require('./src/Pointer');
    for (key in _ref1) {
        val = _ref1[key];
        exports[key] = val;
    }
}.call(this));
},{"./src/Array":210,"./src/Bitfield":211,"./src/Boolean":212,"./src/Buffer":213,"./src/DecodeStream":214,"./src/EncodeStream":215,"./src/Enum":216,"./src/LazyArray":217,"./src/Number":218,"./src/Optional":219,"./src/Pointer":220,"./src/Reserved":221,"./src/String":222,"./src/Struct":223,"./src/VersionedStruct":224}],210:[function(require,module,exports){
(function () {
    var ArrayT, NumberT, utils;
    NumberT = require('./Number').Number;
    utils = require('./utils');
    ArrayT = function () {
        function ArrayT(type, length, lengthType) {
            this.type = type;
            this.length = length;
            this.lengthType = lengthType != null ? lengthType : 'count';
        }
        ArrayT.prototype.decode = function (stream, parent) {
            var ctx, i, length, pos, res, target, _i;
            pos = stream.pos;
            res = [];
            ctx = parent;
            if (this.length != null) {
                length = utils.resolveLength(this.length, stream, parent);
            }
            if (this.length instanceof NumberT) {
                Object.defineProperties(res, {
                    parent: { value: parent },
                    _startOffset: { value: pos },
                    _currentOffset: {
                        value: 0,
                        writable: true
                    },
                    _length: { value: length }
                });
                ctx = res;
            }
            if (length == null || this.lengthType === 'bytes') {
                target = length != null ? stream.pos + length : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream.length;
                while (stream.pos < target) {
                    res.push(this.type.decode(stream, ctx));
                }
            } else {
                for (i = _i = 0; _i < length; i = _i += 1) {
                    res.push(this.type.decode(stream, ctx));
                }
            }
            return res;
        };
        ArrayT.prototype.size = function (array, ctx) {
            var item, size, _i, _len;
            if (!array) {
                return this.type.size(null, ctx) * utils.resolveLength(this.length, null, ctx);
            }
            size = 0;
            if (this.length instanceof NumberT) {
                size += this.length.size();
                ctx = { parent: ctx };
            }
            for (_i = 0, _len = array.length; _i < _len; _i++) {
                item = array[_i];
                size += this.type.size(item, ctx);
            }
            return size;
        };
        ArrayT.prototype.encode = function (stream, array, parent) {
            var ctx, i, item, ptr, _i, _len;
            ctx = parent;
            if (this.length instanceof NumberT) {
                ctx = {
                    pointers: [],
                    startOffset: stream.pos,
                    parent: parent
                };
                ctx.pointerOffset = stream.pos + this.size(array, ctx);
                this.length.encode(stream, array.length);
            }
            for (_i = 0, _len = array.length; _i < _len; _i++) {
                item = array[_i];
                this.type.encode(stream, item, ctx);
            }
            if (this.length instanceof NumberT) {
                i = 0;
                while (i < ctx.pointers.length) {
                    ptr = ctx.pointers[i++];
                    ptr.type.encode(stream, ptr.val);
                }
            }
        };
        return ArrayT;
    }();
    module.exports = ArrayT;
}.call(this));
},{"./Number":218,"./utils":225}],211:[function(require,module,exports){
(function () {
    var Bitfield;
    Bitfield = function () {
        function Bitfield(type, flags) {
            this.type = type;
            this.flags = flags != null ? flags : [];
        }
        Bitfield.prototype.decode = function (stream) {
            var flag, i, res, val, _i, _len, _ref;
            val = this.type.decode(stream);
            res = {};
            _ref = this.flags;
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                flag = _ref[i];
                if (flag != null) {
                    res[flag] = !!(val & 1 << i);
                }
            }
            return res;
        };
        Bitfield.prototype.size = function () {
            return this.type.size();
        };
        Bitfield.prototype.encode = function (stream, keys) {
            var flag, i, val, _i, _len, _ref;
            val = 0;
            _ref = this.flags;
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                flag = _ref[i];
                if (flag != null) {
                    if (keys[flag]) {
                        val |= 1 << i;
                    }
                }
            }
            return this.type.encode(stream, val);
        };
        return Bitfield;
    }();
    module.exports = Bitfield;
}.call(this));
},{}],212:[function(require,module,exports){
(function () {
    var BooleanT;
    BooleanT = function () {
        function BooleanT(type) {
            this.type = type;
        }
        BooleanT.prototype.decode = function (stream, parent) {
            return !!this.type.decode(stream, parent);
        };
        BooleanT.prototype.size = function (val, parent) {
            return this.type.size(val, parent);
        };
        BooleanT.prototype.encode = function (stream, val, parent) {
            return this.type.encode(stream, +val, parent);
        };
        return BooleanT;
    }();
    module.exports = BooleanT;
}.call(this));
},{}],213:[function(require,module,exports){
(function () {
    var BufferT, NumberT, utils;
    utils = require('./utils');
    NumberT = require('./Number').Number;
    BufferT = function () {
        function BufferT(length) {
            this.length = length;
        }
        BufferT.prototype.decode = function (stream, parent) {
            var length;
            length = utils.resolveLength(this.length, stream, parent);
            return stream.readBuffer(length);
        };
        BufferT.prototype.size = function (val, parent) {
            if (!val) {
                return utils.resolveLength(this.length, null, parent);
            }
            return val.length;
        };
        BufferT.prototype.encode = function (stream, buf, parent) {
            if (this.length instanceof NumberT) {
                this.length.encode(stream, buf.length);
            }
            return stream.writeBuffer(buf);
        };
        return BufferT;
    }();
    module.exports = BufferT;
}.call(this));
},{"./Number":218,"./utils":225}],214:[function(require,module,exports){
(function (Buffer){
(function () {
    var DecodeStream, iconv;
    try {
        iconv = function () {
            throw new Error('Cannot find module \'iconv-lite\' from \'C:\\Users\\Jack W\\dev\\oss\\triangulator2\\node_modules\\.registry.npmjs.org\\restructure\\0.5.4\\node_modules\\restructure\\src\'');
        }();
    } catch (_error) {
    }
    DecodeStream = function () {
        var key;
        function DecodeStream(buffer) {
            this.buffer = buffer;
            this.pos = 0;
            this.length = this.buffer.length;
        }
        DecodeStream.TYPES = {
            UInt8: 1,
            UInt16: 2,
            UInt24: 3,
            UInt32: 4,
            Int8: 1,
            Int16: 2,
            Int24: 3,
            Int32: 4,
            Float: 4,
            Double: 8
        };
        for (key in Buffer.prototype) {
            if (key.slice(0, 4) === 'read') {
                (function (key) {
                    var bytes;
                    bytes = DecodeStream.TYPES[key.replace(/read|[BL]E/g, '')];
                    return DecodeStream.prototype[key] = function () {
                        var ret;
                        ret = this.buffer[key](this.pos);
                        this.pos += bytes;
                        return ret;
                    };
                }(key));
            }
        }
        DecodeStream.prototype.readString = function (length, encoding) {
            var buf, byte, i, _i, _ref;
            if (encoding == null) {
                encoding = 'ascii';
            }
            switch (encoding) {
            case 'utf16le':
            case 'ucs2':
            case 'utf8':
            case 'ascii':
                return this.buffer.toString(encoding, this.pos, this.pos += length);
            case 'utf16be':
                buf = new Buffer(this.readBuffer(length));
                for (i = _i = 0, _ref = buf.length - 1; _i < _ref; i = _i += 2) {
                    byte = buf[i];
                    buf[i] = buf[i + 1];
                    buf[i + 1] = byte;
                }
                return buf.toString('utf16le');
            default:
                buf = this.readBuffer(length);
                if (iconv) {
                    try {
                        return iconv.decode(buf, encoding);
                    } catch (_error) {
                    }
                }
                return buf;
            }
        };
        DecodeStream.prototype.readBuffer = function (length) {
            return this.buffer.slice(this.pos, this.pos += length);
        };
        DecodeStream.prototype.readUInt24BE = function () {
            return (this.readUInt16BE() << 8) + this.readUInt8();
        };
        DecodeStream.prototype.readUInt24LE = function () {
            return this.readUInt16LE() + (this.readUInt8() << 16);
        };
        DecodeStream.prototype.readInt24BE = function () {
            return (this.readInt16BE() << 8) + this.readUInt8();
        };
        DecodeStream.prototype.readInt24LE = function () {
            return this.readUInt16LE() + (this.readInt8() << 16);
        };
        return DecodeStream;
    }();
    module.exports = DecodeStream;
}.call(this));
}).call(this,require("buffer").Buffer)
},{"buffer":4}],215:[function(require,module,exports){
(function (Buffer){
(function () {
    var DecodeStream, EncodeStream, iconv, stream, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    stream = require('stream');
    DecodeStream = require('./DecodeStream');
    try {
        iconv = function () {
            throw new Error('Cannot find module \'iconv-lite\' from \'C:\\Users\\Jack W\\dev\\oss\\triangulator2\\node_modules\\.registry.npmjs.org\\restructure\\0.5.4\\node_modules\\restructure\\src\'');
        }();
    } catch (_error) {
    }
    EncodeStream = function (_super) {
        var key;
        __extends(EncodeStream, _super);
        function EncodeStream(bufferSize) {
            if (bufferSize == null) {
                bufferSize = 65536;
            }
            EncodeStream.__super__.constructor.apply(this, arguments);
            this.buffer = new Buffer(bufferSize);
            this.bufferOffset = 0;
            this.pos = 0;
        }
        for (key in Buffer.prototype) {
            if (key.slice(0, 5) === 'write') {
                (function (key) {
                    var bytes;
                    bytes = +DecodeStream.TYPES[key.replace(/write|[BL]E/g, '')];
                    return EncodeStream.prototype[key] = function (value) {
                        this.ensure(bytes);
                        this.buffer[key](value, this.bufferOffset);
                        this.bufferOffset += bytes;
                        return this.pos += bytes;
                    };
                }(key));
            }
        }
        EncodeStream.prototype._read = function () {
        };
        EncodeStream.prototype.ensure = function (bytes) {
            if (this.bufferOffset + bytes > this.buffer.length) {
                return this.flush();
            }
        };
        EncodeStream.prototype.flush = function () {
            if (this.bufferOffset > 0) {
                this.push(new Buffer(this.buffer.slice(0, this.bufferOffset)));
                return this.bufferOffset = 0;
            }
        };
        EncodeStream.prototype.writeBuffer = function (buffer) {
            this.flush();
            this.push(buffer);
            return this.pos += buffer.length;
        };
        EncodeStream.prototype.writeString = function (string, encoding) {
            var buf, byte, i, _i, _ref;
            if (encoding == null) {
                encoding = 'ascii';
            }
            switch (encoding) {
            case 'utf16le':
            case 'ucs2':
            case 'utf8':
            case 'ascii':
                return this.writeBuffer(new Buffer(string, encoding));
            case 'utf16be':
                buf = new Buffer(string, 'utf16le');
                for (i = _i = 0, _ref = buf.length - 1; _i < _ref; i = _i += 2) {
                    byte = buf[i];
                    buf[i] = buf[i + 1];
                    buf[i + 1] = byte;
                }
                return this.writeBuffer(buf);
            default:
                if (iconv) {
                    return this.writeBuffer(iconv.encode(string, encoding));
                } else {
                    throw new Error('Install iconv-lite to enable additional string encodings.');
                }
            }
        };
        EncodeStream.prototype.writeUInt24BE = function (val) {
            this.ensure(3);
            this.buffer[this.bufferOffset++] = val >>> 16 & 255;
            this.buffer[this.bufferOffset++] = val >>> 8 & 255;
            this.buffer[this.bufferOffset++] = val & 255;
            return this.pos += 3;
        };
        EncodeStream.prototype.writeUInt24LE = function (val) {
            this.ensure(3);
            this.buffer[this.bufferOffset++] = val & 255;
            this.buffer[this.bufferOffset++] = val >>> 8 & 255;
            this.buffer[this.bufferOffset++] = val >>> 16 & 255;
            return this.pos += 3;
        };
        EncodeStream.prototype.writeInt24BE = function (val) {
            if (val >= 0) {
                return this.writeUInt24BE(val);
            } else {
                return this.writeUInt24BE(val + 16777215 + 1);
            }
        };
        EncodeStream.prototype.writeInt24LE = function (val) {
            if (val >= 0) {
                return this.writeUInt24LE(val);
            } else {
                return this.writeUInt24LE(val + 16777215 + 1);
            }
        };
        EncodeStream.prototype.fill = function (val, length) {
            var buf;
            if (length < this.buffer.length) {
                this.ensure(length);
                this.buffer.fill(val, this.bufferOffset, this.bufferOffset + length);
                this.bufferOffset += length;
                return this.pos += length;
            } else {
                buf = new Buffer(length);
                buf.fill(val);
                return this.writeBuffer(buf);
            }
        };
        EncodeStream.prototype.end = function () {
            this.flush();
            return this.push(null);
        };
        return EncodeStream;
    }(stream.Readable);
    module.exports = EncodeStream;
}.call(this));
}).call(this,require("buffer").Buffer)
},{"./DecodeStream":214,"buffer":4,"stream":29}],216:[function(require,module,exports){
(function () {
    var Enum;
    Enum = function () {
        function Enum(type, options) {
            this.type = type;
            this.options = options != null ? options : [];
        }
        Enum.prototype.decode = function (stream) {
            var index;
            index = this.type.decode(stream);
            return this.options[index] || index;
        };
        Enum.prototype.size = function () {
            return this.type.size();
        };
        Enum.prototype.encode = function (stream, val) {
            var index;
            index = this.options.indexOf(val);
            if (index === -1) {
                throw new Error('Unknown option in enum: ' + val);
            }
            return this.type.encode(stream, index);
        };
        return Enum;
    }();
    module.exports = Enum;
}.call(this));
},{}],217:[function(require,module,exports){
(function () {
    var ArrayT, LazyArray, LazyArrayT, NumberT, inspect, utils, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    ArrayT = require('./Array');
    NumberT = require('./Number').Number;
    utils = require('./utils');
    inspect = require('util').inspect;
    LazyArrayT = function (_super) {
        __extends(LazyArrayT, _super);
        function LazyArrayT() {
            return LazyArrayT.__super__.constructor.apply(this, arguments);
        }
        LazyArrayT.prototype.decode = function (stream, parent) {
            var length, pos, res;
            pos = stream.pos;
            length = utils.resolveLength(this.length, stream, parent);
            if (this.length instanceof NumberT) {
                parent = {
                    parent: parent,
                    _startOffset: pos,
                    _currentOffset: 0,
                    _length: length
                };
            }
            res = new LazyArray(this.type, length, stream, parent);
            stream.pos += length * this.type.size(null, parent);
            return res;
        };
        LazyArrayT.prototype.size = function (val, ctx) {
            if (val instanceof LazyArray) {
                val = val.toArray();
            }
            return LazyArrayT.__super__.size.call(this, val, ctx);
        };
        LazyArrayT.prototype.encode = function (stream, val, ctx) {
            if (val instanceof LazyArray) {
                val = val.toArray();
            }
            return LazyArrayT.__super__.encode.call(this, stream, val, ctx);
        };
        return LazyArrayT;
    }(ArrayT);
    LazyArray = function () {
        function LazyArray(type, length, stream, ctx) {
            this.type = type;
            this.length = length;
            this.stream = stream;
            this.ctx = ctx;
            this.base = this.stream.pos;
            this.items = [];
        }
        LazyArray.prototype.get = function (index) {
            var pos;
            if (index < 0 || index >= this.length) {
                return void 0;
            }
            if (this.items[index] == null) {
                pos = this.stream.pos;
                this.stream.pos = this.base + this.type.size(null, this.ctx) * index;
                this.items[index] = this.type.decode(this.stream, this.ctx);
                this.stream.pos = pos;
            }
            return this.items[index];
        };
        LazyArray.prototype.toArray = function () {
            var i, _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = this.length; _i < _ref; i = _i += 1) {
                _results.push(this.get(i));
            }
            return _results;
        };
        LazyArray.prototype.inspect = function () {
            return inspect(this.toArray());
        };
        return LazyArray;
    }();
    module.exports = LazyArrayT;
}.call(this));
},{"./Array":210,"./Number":218,"./utils":225,"util":34}],218:[function(require,module,exports){
(function () {
    var DecodeStream, Fixed, NumberT, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    DecodeStream = require('./DecodeStream');
    NumberT = function () {
        function NumberT(type, endian) {
            this.type = type;
            this.endian = endian != null ? endian : 'BE';
            this.fn = this.type;
            if (this.type[this.type.length - 1] !== '8') {
                this.fn += this.endian;
            }
        }
        NumberT.prototype.size = function () {
            return DecodeStream.TYPES[this.type];
        };
        NumberT.prototype.decode = function (stream) {
            return stream['read' + this.fn]();
        };
        NumberT.prototype.encode = function (stream, val) {
            return stream['write' + this.fn](val);
        };
        return NumberT;
    }();
    exports.Number = NumberT;
    exports.uint8 = new NumberT('UInt8');
    exports.uint16be = exports.uint16 = new NumberT('UInt16', 'BE');
    exports.uint16le = new NumberT('UInt16', 'LE');
    exports.uint24be = exports.uint24 = new NumberT('UInt24', 'BE');
    exports.uint24le = new NumberT('UInt24', 'LE');
    exports.uint32be = exports.uint32 = new NumberT('UInt32', 'BE');
    exports.uint32le = new NumberT('UInt32', 'LE');
    exports.int8 = new NumberT('Int8');
    exports.int16be = exports.int16 = new NumberT('Int16', 'BE');
    exports.int16le = new NumberT('Int16', 'LE');
    exports.int24be = exports.int24 = new NumberT('Int24', 'BE');
    exports.int24le = new NumberT('Int24', 'LE');
    exports.int32be = exports.int32 = new NumberT('Int32', 'BE');
    exports.int32le = new NumberT('Int32', 'LE');
    exports.floatbe = exports.float = new NumberT('Float', 'BE');
    exports.floatle = new NumberT('Float', 'LE');
    exports.doublebe = exports.double = new NumberT('Double', 'BE');
    exports.doublele = new NumberT('Double', 'LE');
    Fixed = function (_super) {
        __extends(Fixed, _super);
        function Fixed(size, endian, fracBits) {
            if (fracBits == null) {
                fracBits = size >> 1;
            }
            Fixed.__super__.constructor.call(this, 'Int' + size, endian);
            this._point = 1 << fracBits;
        }
        Fixed.prototype.decode = function (stream) {
            return Fixed.__super__.decode.call(this, stream) / this._point;
        };
        Fixed.prototype.encode = function (stream, val) {
            return Fixed.__super__.encode.call(this, stream, val * this._point | 0);
        };
        return Fixed;
    }(NumberT);
    exports.Fixed = Fixed;
    exports.fixed16be = exports.fixed16 = new Fixed(16, 'BE');
    exports.fixed16le = new Fixed(16, 'LE');
    exports.fixed32be = exports.fixed32 = new Fixed(32, 'BE');
    exports.fixed32le = new Fixed(32, 'LE');
}.call(this));
},{"./DecodeStream":214}],219:[function(require,module,exports){
(function () {
    var Optional;
    Optional = function () {
        function Optional(type, condition) {
            this.type = type;
            this.condition = condition != null ? condition : true;
        }
        Optional.prototype.decode = function (stream, parent) {
            var condition;
            condition = this.condition;
            if (typeof condition === 'function') {
                condition = condition.call(parent, parent);
            }
            if (condition) {
                return this.type.decode(stream, parent);
            }
        };
        Optional.prototype.size = function (val, parent) {
            var condition;
            condition = this.condition;
            if (typeof condition === 'function') {
                condition = condition.call(parent, parent);
            }
            if (condition) {
                return this.type.size(val, parent);
            } else {
                return 0;
            }
        };
        Optional.prototype.encode = function (stream, val, parent) {
            var condition;
            condition = this.condition;
            if (typeof condition === 'function') {
                condition = condition.call(parent, parent);
            }
            if (condition) {
                return this.type.encode(stream, val, parent);
            }
        };
        return Optional;
    }();
    module.exports = Optional;
}.call(this));
},{}],220:[function(require,module,exports){
(function () {
    var Pointer, VoidPointer, utils;
    utils = require('./utils');
    Pointer = function () {
        function Pointer(offsetType, type, options) {
            var _base, _base1, _base2, _base3;
            this.offsetType = offsetType;
            this.type = type;
            this.options = options != null ? options : {};
            if (this.type === 'void') {
                this.type = null;
            }
            if ((_base = this.options).type == null) {
                _base.type = 'local';
            }
            if ((_base1 = this.options).allowNull == null) {
                _base1.allowNull = true;
            }
            if ((_base2 = this.options).nullValue == null) {
                _base2.nullValue = 0;
            }
            if ((_base3 = this.options).lazy == null) {
                _base3.lazy = false;
            }
            if (this.options.relativeTo) {
                this.relativeToGetter = new Function('ctx', 'return ctx.' + this.options.relativeTo);
            }
        }
        Pointer.prototype.decode = function (stream, ctx) {
            var c, decodeValue, offset, ptr, relative, val;
            offset = this.offsetType.decode(stream, ctx);
            if (offset === this.options.nullValue && this.options.allowNull) {
                return null;
            }
            relative = function () {
                switch (this.options.type) {
                case 'local':
                    return ctx._startOffset;
                case 'immediate':
                    return stream.pos - this.offsetType.size();
                case 'parent':
                    return ctx.parent._startOffset;
                default:
                    c = ctx;
                    while (c.parent) {
                        c = c.parent;
                    }
                    return c._startOffset || 0;
                }
            }.call(this);
            if (this.options.relativeTo) {
                relative += this.relativeToGetter(ctx);
            }
            ptr = offset + relative;
            if (this.type != null) {
                val = null;
                decodeValue = function (_this) {
                    return function () {
                        var pos;
                        if (val != null) {
                            return val;
                        }
                        pos = stream.pos;
                        stream.pos = ptr;
                        val = _this.type.decode(stream, ctx);
                        stream.pos = pos;
                        return val;
                    };
                }(this);
                if (this.options.lazy) {
                    return new utils.PropertyDescriptor({ get: decodeValue });
                }
                return decodeValue();
            } else {
                return ptr;
            }
        };
        Pointer.prototype.size = function (val, ctx) {
            var parent, type;
            parent = ctx;
            switch (this.options.type) {
            case 'local':
            case 'immediate':
                break;
            case 'parent':
                ctx = ctx.parent;
                break;
            default:
                while (ctx.parent) {
                    ctx = ctx.parent;
                }
            }
            type = this.type;
            if (type == null) {
                if (!(val instanceof VoidPointer)) {
                    throw new Error('Must be a VoidPointer');
                }
                type = val.type;
                val = val.value;
            }
            if (val && ctx) {
                ctx.pointerSize += type.size(val, parent);
            }
            return this.offsetType.size();
        };
        Pointer.prototype.encode = function (stream, val, ctx) {
            var parent, relative, type;
            parent = ctx;
            if (val == null) {
                this.offsetType.encode(stream, this.options.nullValue);
                return;
            }
            switch (this.options.type) {
            case 'local':
                relative = ctx.startOffset;
                break;
            case 'immediate':
                relative = stream.pos + this.offsetType.size(val, parent);
                break;
            case 'parent':
                ctx = ctx.parent;
                relative = ctx.startOffset;
                break;
            default:
                relative = 0;
                while (ctx.parent) {
                    ctx = ctx.parent;
                }
            }
            if (this.options.relativeTo) {
                relative += this.relativeToGetter(parent.val);
            }
            this.offsetType.encode(stream, ctx.pointerOffset - relative);
            type = this.type;
            if (type == null) {
                if (!(val instanceof VoidPointer)) {
                    throw new Error('Must be a VoidPointer');
                }
                type = val.type;
                val = val.value;
            }
            ctx.pointers.push({
                type: type,
                val: val,
                parent: parent
            });
            return ctx.pointerOffset += type.size(val, parent);
        };
        return Pointer;
    }();
    VoidPointer = function () {
        function VoidPointer(type, value) {
            this.type = type;
            this.value = value;
        }
        return VoidPointer;
    }();
    exports.Pointer = Pointer;
    exports.VoidPointer = VoidPointer;
}.call(this));
},{"./utils":225}],221:[function(require,module,exports){
(function () {
    var Reserved, utils;
    utils = require('./utils');
    Reserved = function () {
        function Reserved(type, count) {
            this.type = type;
            this.count = count != null ? count : 1;
        }
        Reserved.prototype.decode = function (stream, parent) {
            stream.pos += this.size(null, parent);
            return void 0;
        };
        Reserved.prototype.size = function (data, parent) {
            var count;
            count = utils.resolveLength(this.count, null, parent);
            return this.type.size() * count;
        };
        Reserved.prototype.encode = function (stream, val, parent) {
            return stream.fill(0, this.size(val, parent));
        };
        return Reserved;
    }();
    module.exports = Reserved;
}.call(this));
},{"./utils":225}],222:[function(require,module,exports){
(function (Buffer){
(function () {
    var NumberT, StringT, utils;
    NumberT = require('./Number').Number;
    utils = require('./utils');
    StringT = function () {
        function StringT(length, encoding) {
            this.length = length;
            this.encoding = encoding != null ? encoding : 'ascii';
        }
        StringT.prototype.decode = function (stream, parent) {
            var buffer, encoding, length, pos, string;
            length = function () {
                if (this.length != null) {
                    return utils.resolveLength(this.length, stream, parent);
                } else {
                    buffer = stream.buffer, length = stream.length, pos = stream.pos;
                    while (pos < length && buffer[pos] !== 0) {
                        ++pos;
                    }
                    return pos - stream.pos;
                }
            }.call(this);
            encoding = this.encoding;
            if (typeof encoding === 'function') {
                encoding = encoding.call(parent, parent) || 'ascii';
            }
            string = stream.readString(length, encoding);
            if (this.length == null && stream.pos < stream.length) {
                stream.pos++;
            }
            return string;
        };
        StringT.prototype.size = function (val, parent) {
            var encoding, size;
            if (!val) {
                return utils.resolveLength(this.length, null, parent);
            }
            encoding = this.encoding;
            if (typeof encoding === 'function') {
                encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || 'ascii';
            }
            if (encoding === 'utf16be') {
                encoding = 'utf16le';
            }
            size = Buffer.byteLength(val, encoding);
            if (this.length instanceof NumberT) {
                size += this.length.size();
            }
            if (this.length == null) {
                size++;
            }
            return size;
        };
        StringT.prototype.encode = function (stream, val, parent) {
            var encoding;
            encoding = this.encoding;
            if (typeof encoding === 'function') {
                encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || 'ascii';
            }
            if (this.length instanceof NumberT) {
                this.length.encode(stream, Buffer.byteLength(val, encoding));
            }
            stream.writeString(val, encoding);
            if (this.length == null) {
                return stream.writeUInt8(0);
            }
        };
        return StringT;
    }();
    module.exports = StringT;
}.call(this));
}).call(this,require("buffer").Buffer)
},{"./Number":218,"./utils":225,"buffer":4}],223:[function(require,module,exports){
(function () {
    var Struct, utils;
    utils = require('./utils');
    Struct = function () {
        function Struct(fields) {
            this.fields = fields != null ? fields : {};
        }
        Struct.prototype.decode = function (stream, parent, length) {
            var res, _ref;
            if (length == null) {
                length = 0;
            }
            res = this._setup(stream, parent, length);
            this._parseFields(stream, res, this.fields);
            if ((_ref = this.process) != null) {
                _ref.call(res, stream);
            }
            return res;
        };
        Struct.prototype._setup = function (stream, parent, length) {
            var res;
            res = {};
            Object.defineProperties(res, {
                parent: { value: parent },
                _startOffset: { value: stream.pos },
                _currentOffset: {
                    value: 0,
                    writable: true
                },
                _length: { value: length }
            });
            return res;
        };
        Struct.prototype._parseFields = function (stream, res, fields) {
            var key, type, val;
            for (key in fields) {
                type = fields[key];
                if (typeof type === 'function') {
                    val = type.call(res, res);
                } else {
                    val = type.decode(stream, res);
                }
                if (val !== void 0) {
                    if (val instanceof utils.PropertyDescriptor) {
                        Object.defineProperty(res, key, val);
                    } else {
                        res[key] = val;
                    }
                }
                res._currentOffset = stream.pos - res._startOffset;
            }
        };
        Struct.prototype.size = function (val, parent, includePointers) {
            var ctx, key, size, type, _ref;
            if (val == null) {
                val = {};
            }
            if (includePointers == null) {
                includePointers = true;
            }
            ctx = {
                parent: parent,
                val: val,
                pointerSize: 0
            };
            size = 0;
            _ref = this.fields;
            for (key in _ref) {
                type = _ref[key];
                if (type.size != null) {
                    size += type.size(val[key], ctx);
                }
            }
            if (includePointers) {
                size += ctx.pointerSize;
            }
            return size;
        };
        Struct.prototype.encode = function (stream, val, parent) {
            var ctx, i, key, ptr, type, _ref, _ref1;
            if ((_ref = this.preEncode) != null) {
                _ref.call(val, stream);
            }
            ctx = {
                pointers: [],
                startOffset: stream.pos,
                parent: parent,
                val: val,
                pointerSize: 0
            };
            ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
            _ref1 = this.fields;
            for (key in _ref1) {
                type = _ref1[key];
                if (type.encode != null) {
                    type.encode(stream, val[key], ctx);
                }
            }
            i = 0;
            while (i < ctx.pointers.length) {
                ptr = ctx.pointers[i++];
                ptr.type.encode(stream, ptr.val, ptr.parent);
            }
        };
        return Struct;
    }();
    module.exports = Struct;
}.call(this));
},{"./utils":225}],224:[function(require,module,exports){
(function () {
    var Struct, VersionedStruct, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    Struct = require('./Struct');
    VersionedStruct = function (_super) {
        __extends(VersionedStruct, _super);
        function VersionedStruct(type, versions) {
            this.type = type;
            this.versions = versions != null ? versions : {};
            if (typeof this.type === 'string') {
                this.versionGetter = new Function('parent', 'return parent.' + this.type);
                this.versionSetter = new Function('parent', 'version', 'return parent.' + this.type + ' = version');
            }
        }
        VersionedStruct.prototype.decode = function (stream, parent, length) {
            var fields, res, _ref;
            if (length == null) {
                length = 0;
            }
            res = this._setup(stream, parent, length);
            if (typeof this.type === 'string') {
                res.version = this.versionGetter(parent);
            } else {
                res.version = this.type.decode(stream);
            }
            if (this.versions.header) {
                this._parseFields(stream, res, this.versions.header);
            }
            fields = this.versions[res.version];
            if (fields == null) {
                throw new Error('Unknown version ' + res.version);
            }
            if (fields instanceof VersionedStruct) {
                return fields.decode(stream, parent);
            }
            this._parseFields(stream, res, fields);
            if ((_ref = this.process) != null) {
                _ref.call(res, stream);
            }
            return res;
        };
        VersionedStruct.prototype.size = function (val, parent, includePointers) {
            var ctx, fields, key, size, type, _ref;
            if (includePointers == null) {
                includePointers = true;
            }
            if (!val) {
                throw new Error('Not a fixed size');
            }
            ctx = {
                parent: parent,
                val: val,
                pointerSize: 0
            };
            size = 0;
            if (typeof this.type !== 'string') {
                size += this.type.size(val.version, ctx);
            }
            if (this.versions.header) {
                _ref = this.versions.header;
                for (key in _ref) {
                    type = _ref[key];
                    if (type.size != null) {
                        size += type.size(val[key], ctx);
                    }
                }
            }
            fields = this.versions[val.version];
            if (fields == null) {
                throw new Error('Unknown version ' + val.version);
            }
            for (key in fields) {
                type = fields[key];
                if (type.size != null) {
                    size += type.size(val[key], ctx);
                }
            }
            if (includePointers) {
                size += ctx.pointerSize;
            }
            return size;
        };
        VersionedStruct.prototype.encode = function (stream, val, parent) {
            var ctx, fields, i, key, ptr, type, _ref, _ref1;
            if ((_ref = this.preEncode) != null) {
                _ref.call(val, stream);
            }
            ctx = {
                pointers: [],
                startOffset: stream.pos,
                parent: parent,
                val: val,
                pointerSize: 0
            };
            ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
            if (typeof this.type !== 'string') {
                this.type.encode(stream, val.version);
            }
            if (this.versions.header) {
                _ref1 = this.versions.header;
                for (key in _ref1) {
                    type = _ref1[key];
                    if (type.encode != null) {
                        type.encode(stream, val[key], ctx);
                    }
                }
            }
            fields = this.versions[val.version];
            for (key in fields) {
                type = fields[key];
                if (type.encode != null) {
                    type.encode(stream, val[key], ctx);
                }
            }
            i = 0;
            while (i < ctx.pointers.length) {
                ptr = ctx.pointers[i++];
                ptr.type.encode(stream, ptr.val, ptr.parent);
            }
        };
        return VersionedStruct;
    }(Struct);
    module.exports = VersionedStruct;
}.call(this));
},{"./Struct":223}],225:[function(require,module,exports){
(function () {
    var NumberT, PropertyDescriptor;
    NumberT = require('./Number').Number;
    exports.resolveLength = function (length, stream, parent) {
        var res;
        if (typeof length === 'number') {
            res = length;
        } else if (typeof length === 'function') {
            res = length.call(parent, parent);
        } else if (parent && typeof length === 'string') {
            res = parent[length];
        } else if (stream && length instanceof NumberT) {
            res = length.decode(stream);
        }
        if (isNaN(res)) {
            throw new Error('Not a fixed size');
        }
        return res;
    };
    PropertyDescriptor = function () {
        function PropertyDescriptor(opts) {
            var key, val;
            if (opts == null) {
                opts = {};
            }
            this.enumerable = true;
            this.configurable = true;
            for (key in opts) {
                val = opts[key];
                this[key] = val;
            }
        }
        return PropertyDescriptor;
    }();
    exports.PropertyDescriptor = PropertyDescriptor;
}.call(this));
},{"./Number":218}],226:[function(require,module,exports){
(function (Buffer){
;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = require('stream').Stream
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = require('string_decoder').StringDecoder
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})(typeof exports === 'undefined' ? this.sax = {} : exports)

}).call(this,require("buffer").Buffer)
},{"buffer":4,"stream":29,"string_decoder":30}],227:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":228,"./lib/tychei":229,"./lib/xor128":230,"./lib/xor4096":231,"./lib/xorshift7":232,"./lib/xorwow":233,"./seedrandom":234}],228:[function(require,module,exports){
// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],229:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],230:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],231:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],232:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],233:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],234:[function(require,module,exports){
/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

// Detect the global object, even if operating in strict mode.
// http://stackoverflow.com/a/14387057/265298
var global = (0, eval)('this'),
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
} else {
  // When included as a plain script, set up Math.seedrandom global.
  math['seed' + rngname] = seedrandom;
}


// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":3}],235:[function(require,module,exports){
/*!
* svg.js - A lightweight library for manipulating and animating SVG.
* @version 2.7.1
* https://svgdotjs.github.io/
*
* @copyright Wout Fierens <wout@mick-wout.com>
* @license MIT
*
* BUILT: Fri Nov 30 2018 10:01:55 GMT+0100 (GMT+01:00)
*/;
(function(root, factory) {
  /* istanbul ignore next */
  if (typeof define === 'function' && define.amd) {
    define(function(){
      return factory(root, root.document)
    })
  } else if (typeof exports === 'object') {
    module.exports = root.document ? factory(root, root.document) : function(w){ return factory(w, w.document) }
  } else {
    root.SVG = factory(root, root.document)
  }
}(typeof window !== "undefined" ? window : this, function(window, document) {

// Find global reference - uses 'this' by default when available,
// falls back to 'window' otherwise (for bundlers like Webpack)
var globalRef = (typeof this !== "undefined") ? this : window;

// The main wrapping element
var SVG = globalRef.SVG = function(element) {
  if (SVG.supported) {
    element = new SVG.Doc(element)

    if(!SVG.parser.draw)
      SVG.prepare()

    return element
  }
}

// Default namespaces
SVG.ns    = 'http://www.w3.org/2000/svg'
SVG.xmlns = 'http://www.w3.org/2000/xmlns/'
SVG.xlink = 'http://www.w3.org/1999/xlink'
SVG.svgjs = 'http://svgjs.com/svgjs'

// Svg support test
SVG.supported = (function() {
  return !! document.createElementNS &&
         !! document.createElementNS(SVG.ns,'svg').createSVGRect
})()

// Don't bother to continue if SVG is not supported
if (!SVG.supported) return false

// Element id sequence
SVG.did  = 1000

// Get next named element id
SVG.eid = function(name) {
  return 'Svgjs' + capitalize(name) + (SVG.did++)
}

// Method for element creation
SVG.create = function(name) {
  // create element
  var element = document.createElementNS(this.ns, name)

  // apply unique id
  element.setAttribute('id', this.eid(name))

  return element
}

// Method for extending objects
SVG.extend = function() {
  var modules, methods, key, i

  // Get list of modules
  modules = [].slice.call(arguments)

  // Get object with extensions
  methods = modules.pop()

  for (i = modules.length - 1; i >= 0; i--)
    if (modules[i])
      for (key in methods)
        modules[i].prototype[key] = methods[key]

  // Make sure SVG.Set inherits any newly added methods
  if (SVG.Set && SVG.Set.inherit)
    SVG.Set.inherit()
}

// Invent new element
SVG.invent = function(config) {
  // Create element initializer
  var initializer = typeof config.create == 'function' ?
    config.create :
    function() {
      this.constructor.call(this, SVG.create(config.create))
    }

  // Inherit prototype
  if (config.inherit)
    initializer.prototype = new config.inherit

  // Extend with methods
  if (config.extend)
    SVG.extend(initializer, config.extend)

  // Attach construct method to parent
  if (config.construct)
    SVG.extend(config.parent || SVG.Container, config.construct)

  return initializer
}

// Adopt existing svg elements
SVG.adopt = function(node) {
  // check for presence of node
  if (!node) return null

  // make sure a node isn't already adopted
  if (node.instance) return node.instance

  // initialize variables
  var element

  // adopt with element-specific settings
  if (node.nodeName == 'svg')
    element = node.parentNode instanceof window.SVGElement ? new SVG.Nested : new SVG.Doc
  else if (node.nodeName == 'linearGradient')
    element = new SVG.Gradient('linear')
  else if (node.nodeName == 'radialGradient')
    element = new SVG.Gradient('radial')
  else if (SVG[capitalize(node.nodeName)])
    element = new SVG[capitalize(node.nodeName)]
  else
    element = new SVG.Element(node)

  // ensure references
  element.type  = node.nodeName
  element.node  = node
  node.instance = element

  // SVG.Class specific preparations
  if (element instanceof SVG.Doc)
    element.namespace().defs()

  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)
  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})

  return element
}

// Initialize parsing element
SVG.prepare = function() {
  // Select document body and create invisible svg element
  var body = document.getElementsByTagName('body')[0]
    , draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0)

  // Create parser object
  SVG.parser = {
    body: body || document.documentElement
  , draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').attr('focusable', 'false').node
  , poly: draw.polyline().node
  , path: draw.path().node
  , native: SVG.create('svg')
  }
}

SVG.parser = {
  native: SVG.create('svg')
}

document.addEventListener('DOMContentLoaded', function() {
  if(!SVG.parser.draw)
    SVG.prepare()
}, false)

// Storage for regular expressions
SVG.regex = {
  // Parse unit value
  numberAndUnit:    /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i

  // Parse hex value
, hex:              /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i

  // Parse rgb value
, rgb:              /rgb\((\d+),(\d+),(\d+)\)/

  // Parse reference id
, reference:        /#([a-z0-9\-_]+)/i

  // splits a transformation chain
, transforms:       /\)\s*,?\s*/

  // Whitespace
, whitespace:       /\s/g

  // Test hex value
, isHex:            /^#[a-f0-9]{3,6}$/i

  // Test rgb value
, isRgb:            /^rgb\(/

  // Test css declaration
, isCss:            /[^:]+:[^;]+;?/

  // Test for blank string
, isBlank:          /^(\s+)?$/

  // Test for numeric string
, isNumber:         /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i

  // Test for percent value
, isPercent:        /^-?[\d\.]+%$/

  // Test for image url
, isImage:          /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i

  // split at whitespace and comma
, delimiter:        /[\s,]+/

  // The following regex are used to parse the d attribute of a path

  // Matches all hyphens which are not after an exponent
, hyphen:           /([^e])\-/gi

  // Replaces and tests for all path letters
, pathLetters:      /[MLHVCSQTAZ]/gi

  // yes we need this one, too
, isPathLetter:     /[MLHVCSQTAZ]/i

  // matches 0.154.23.45
, numbersWithDots:  /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi

  // matches .
, dots:             /\./g
}

SVG.utils = {
  // Map function
  map: function(array, block) {
    var i
      , il = array.length
      , result = []

    for (i = 0; i < il; i++)
      result.push(block(array[i]))

    return result
  }

  // Filter function
, filter: function(array, block) {
    var i
      , il = array.length
      , result = []

    for (i = 0; i < il; i++)
      if (block(array[i]))
        result.push(array[i])

    return result
  }

  // Degrees to radians
, radians: function(d) {
    return d % 360 * Math.PI / 180
  }

  // Radians to degrees
, degrees: function(r) {
    return r * 180 / Math.PI % 360
  }

, filterSVGElements: function(nodes) {
    return this.filter( nodes, function(el) { return el instanceof window.SVGElement })
  }

}

SVG.defaults = {
  // Default attribute values
  attrs: {
    // fill and stroke
    'fill-opacity':     1
  , 'stroke-opacity':   1
  , 'stroke-width':     0
  , 'stroke-linejoin':  'miter'
  , 'stroke-linecap':   'butt'
  , fill:               '#000000'
  , stroke:             '#000000'
  , opacity:            1
    // position
  , x:                  0
  , y:                  0
  , cx:                 0
  , cy:                 0
    // size
  , width:              0
  , height:             0
    // radius
  , r:                  0
  , rx:                 0
  , ry:                 0
    // gradient
  , offset:             0
  , 'stop-opacity':     1
  , 'stop-color':       '#000000'
    // text
  , 'font-size':        16
  , 'font-family':      'Helvetica, Arial, sans-serif'
  , 'text-anchor':      'start'
  }

}
// Module for color convertions
SVG.Color = function(color) {
  var match

  // initialize defaults
  this.r = 0
  this.g = 0
  this.b = 0

  if(!color) return

  // parse color
  if (typeof color === 'string') {
    if (SVG.regex.isRgb.test(color)) {
      // get rgb values
      match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace,''))

      // parse numeric values
      this.r = parseInt(match[1])
      this.g = parseInt(match[2])
      this.b = parseInt(match[3])

    } else if (SVG.regex.isHex.test(color)) {
      // get hex values
      match = SVG.regex.hex.exec(fullHex(color))

      // parse numeric values
      this.r = parseInt(match[1], 16)
      this.g = parseInt(match[2], 16)
      this.b = parseInt(match[3], 16)

    }

  } else if (typeof color === 'object') {
    this.r = color.r
    this.g = color.g
    this.b = color.b

  }

}

SVG.extend(SVG.Color, {
  // Default to hex conversion
  toString: function() {
    return this.toHex()
  }
  // Build hex value
, toHex: function() {
    return '#'
      + compToHex(this.r)
      + compToHex(this.g)
      + compToHex(this.b)
  }
  // Build rgb value
, toRgb: function() {
    return 'rgb(' + [this.r, this.g, this.b].join() + ')'
  }
  // Calculate true brightness
, brightness: function() {
    return (this.r / 255 * 0.30)
         + (this.g / 255 * 0.59)
         + (this.b / 255 * 0.11)
  }
  // Make color morphable
, morph: function(color) {
    this.destination = new SVG.Color(color)

    return this
  }
  // Get morphed color at given position
, at: function(pos) {
    // make sure a destination is defined
    if (!this.destination) return this

    // normalise pos
    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos

    // generate morphed color
    return new SVG.Color({
      r: ~~(this.r + (this.destination.r - this.r) * pos)
    , g: ~~(this.g + (this.destination.g - this.g) * pos)
    , b: ~~(this.b + (this.destination.b - this.b) * pos)
    })
  }

})

// Testers

// Test if given value is a color string
SVG.Color.test = function(color) {
  color += ''
  return SVG.regex.isHex.test(color)
      || SVG.regex.isRgb.test(color)
}

// Test if given value is a rgb object
SVG.Color.isRgb = function(color) {
  return color && typeof color.r == 'number'
               && typeof color.g == 'number'
               && typeof color.b == 'number'
}

// Test if given value is a color
SVG.Color.isColor = function(color) {
  return SVG.Color.isRgb(color) || SVG.Color.test(color)
}
// Module for array conversion
SVG.Array = function(array, fallback) {
  array = (array || []).valueOf()

  // if array is empty and fallback is provided, use fallback
  if (array.length == 0 && fallback)
    array = fallback.valueOf()

  // parse array
  this.value = this.parse(array)
}

SVG.extend(SVG.Array, {
  // Make array morphable
  morph: function(array) {
    this.destination = this.parse(array)

    // normalize length of arrays
    if (this.value.length != this.destination.length) {
      var lastValue       = this.value[this.value.length - 1]
        , lastDestination = this.destination[this.destination.length - 1]

      while(this.value.length > this.destination.length)
        this.destination.push(lastDestination)
      while(this.value.length < this.destination.length)
        this.value.push(lastValue)
    }

    return this
  }
  // Clean up any duplicate points
, settle: function() {
    // find all unique values
    for (var i = 0, il = this.value.length, seen = []; i < il; i++)
      if (seen.indexOf(this.value[i]) == -1)
        seen.push(this.value[i])

    // set new value
    return this.value = seen
  }
  // Get morphed array at given position
, at: function(pos) {
    // make sure a destination is defined
    if (!this.destination) return this

    // generate morphed array
    for (var i = 0, il = this.value.length, array = []; i < il; i++)
      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)

    return new SVG.Array(array)
  }
  // Convert array to string
, toString: function() {
    return this.value.join(' ')
  }
  // Real value
, valueOf: function() {
    return this.value
  }
  // Parse whitespace separated string
, parse: function(array) {
    array = array.valueOf()

    // if already is an array, no need to parse it
    if (Array.isArray(array)) return array

    return this.split(array)
  }
  // Strip unnecessary whitespace
, split: function(string) {
    return string.trim().split(SVG.regex.delimiter).map(parseFloat)
  }
  // Reverse array
, reverse: function() {
    this.value.reverse()

    return this
  }
, clone: function() {
    var clone = new this.constructor()
    clone.value = array_clone(this.value)
    return clone
  }
})
// Poly points array
SVG.PointArray = function(array, fallback) {
  SVG.Array.call(this, array, fallback || [[0,0]])
}

// Inherit from SVG.Array
SVG.PointArray.prototype = new SVG.Array
SVG.PointArray.prototype.constructor = SVG.PointArray

SVG.extend(SVG.PointArray, {
  // Convert array to string
  toString: function() {
    // convert to a poly point string
    for (var i = 0, il = this.value.length, array = []; i < il; i++)
      array.push(this.value[i].join(','))

    return array.join(' ')
  }
  // Convert array to line object
, toLine: function() {
    return {
      x1: this.value[0][0]
    , y1: this.value[0][1]
    , x2: this.value[1][0]
    , y2: this.value[1][1]
    }
  }
  // Get morphed array at given position
, at: function(pos) {
    // make sure a destination is defined
    if (!this.destination) return this

    // generate morphed point string
    for (var i = 0, il = this.value.length, array = []; i < il; i++)
      array.push([
        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos
      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos
      ])

    return new SVG.PointArray(array)
  }
  // Parse point string and flat array
, parse: function(array) {
    var points = []

    array = array.valueOf()

    // if it is an array
    if (Array.isArray(array)) {
      // and it is not flat, there is no need to parse it
      if(Array.isArray(array[0])) {
        // make sure to use a clone
        return array.map(function (el) { return el.slice() })
      } else if (array[0].x != null){
        // allow point objects to be passed
        return array.map(function (el) { return [el.x, el.y] })
      }
    } else { // Else, it is considered as a string
      // parse points
      array = array.trim().split(SVG.regex.delimiter).map(parseFloat)
    }

    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.
    if (array.length % 2 !== 0) array.pop()

    // wrap points in two-tuples and parse points as floats
    for(var i = 0, len = array.length; i < len; i = i + 2)
      points.push([ array[i], array[i+1] ])

    return points
  }
  // Move point string
, move: function(x, y) {
    var box = this.bbox()

    // get relative offset
    x -= box.x
    y -= box.y

    // move every point
    if (!isNaN(x) && !isNaN(y))
      for (var i = this.value.length - 1; i >= 0; i--)
        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]

    return this
  }
  // Resize poly string
, size: function(width, height) {
    var i, box = this.bbox()

    // recalculate position of all points according to new size
    for (i = this.value.length - 1; i >= 0; i--) {
      if(box.width) this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x
      if(box.height) this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y
    }

    return this
  }
  // Get bounding box of points
, bbox: function() {
    SVG.parser.poly.setAttribute('points', this.toString())

    return SVG.parser.poly.getBBox()
  }
})

var pathHandlers = {
  M: function(c, p, p0) {
    p.x = p0.x = c[0]
    p.y = p0.y = c[1]

    return ['M', p.x, p.y]
  },
  L: function(c, p) {
    p.x = c[0]
    p.y = c[1]
    return ['L', c[0], c[1]]
  },
  H: function(c, p) {
    p.x = c[0]
    return ['H', c[0]]
  },
  V: function(c, p) {
    p.y = c[0]
    return ['V', c[0]]
  },
  C: function(c, p) {
    p.x = c[4]
    p.y = c[5]
    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]]
  },
  S: function(c, p) {
    p.x = c[2]
    p.y = c[3]
    return ['S', c[0], c[1], c[2], c[3]]
  },
  Q: function(c, p) {
    p.x = c[2]
    p.y = c[3]
    return ['Q', c[0], c[1], c[2], c[3]]
  },
  T: function(c, p) {
    p.x = c[0]
    p.y = c[1]
    return ['T', c[0], c[1]]
  },
  Z: function(c, p, p0) {
    p.x = p0.x
    p.y = p0.y
    return ['Z']
  },
  A: function(c, p) {
    p.x = c[5]
    p.y = c[6]
    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]]
  }
}

var mlhvqtcsa = 'mlhvqtcsaz'.split('')

for(var i = 0, il = mlhvqtcsa.length; i < il; ++i){
  pathHandlers[mlhvqtcsa[i]] = (function(i){
    return function(c, p, p0) {
      if(i == 'H') c[0] = c[0] + p.x
      else if(i == 'V') c[0] = c[0] + p.y
      else if(i == 'A'){
        c[5] = c[5] + p.x,
        c[6] = c[6] + p.y
      }
      else
        for(var j = 0, jl = c.length; j < jl; ++j) {
          c[j] = c[j] + (j%2 ? p.y : p.x)
        }

      return pathHandlers[i](c, p, p0)
    }
  })(mlhvqtcsa[i].toUpperCase())
}

// Path points array
SVG.PathArray = function(array, fallback) {
  SVG.Array.call(this, array, fallback || [['M', 0, 0]])
}

// Inherit from SVG.Array
SVG.PathArray.prototype = new SVG.Array
SVG.PathArray.prototype.constructor = SVG.PathArray

SVG.extend(SVG.PathArray, {
  // Convert array to string
  toString: function() {
    return arrayToString(this.value)
  }
  // Move path string
, move: function(x, y) {
    // get bounding box of current situation
    var box = this.bbox()

    // get relative offset
    x -= box.x
    y -= box.y

    if (!isNaN(x) && !isNaN(y)) {
      // move every point
      for (var l, i = this.value.length - 1; i >= 0; i--) {
        l = this.value[i][0]

        if (l == 'M' || l == 'L' || l == 'T')  {
          this.value[i][1] += x
          this.value[i][2] += y

        } else if (l == 'H')  {
          this.value[i][1] += x

        } else if (l == 'V')  {
          this.value[i][1] += y

        } else if (l == 'C' || l == 'S' || l == 'Q')  {
          this.value[i][1] += x
          this.value[i][2] += y
          this.value[i][3] += x
          this.value[i][4] += y

          if (l == 'C')  {
            this.value[i][5] += x
            this.value[i][6] += y
          }

        } else if (l == 'A')  {
          this.value[i][6] += x
          this.value[i][7] += y
        }

      }
    }

    return this
  }
  // Resize path string
, size: function(width, height) {
    // get bounding box of current situation
    var i, l, box = this.bbox()

    // recalculate position of all points according to new size
    for (i = this.value.length - 1; i >= 0; i--) {
      l = this.value[i][0]

      if (l == 'M' || l == 'L' || l == 'T')  {
        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x
        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y

      } else if (l == 'H')  {
        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x

      } else if (l == 'V')  {
        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y

      } else if (l == 'C' || l == 'S' || l == 'Q')  {
        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x
        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y
        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x
        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y

        if (l == 'C')  {
          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x
          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y
        }

      } else if (l == 'A')  {
        // resize radii
        this.value[i][1] = (this.value[i][1] * width)  / box.width
        this.value[i][2] = (this.value[i][2] * height) / box.height

        // move position values
        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x
        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y
      }

    }

    return this
  }
  // Test if the passed path array use the same path data commands as this path array
, equalCommands: function(pathArray) {
    var i, il, equalCommands

    pathArray = new SVG.PathArray(pathArray)

    equalCommands = this.value.length === pathArray.value.length
    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {
      equalCommands = this.value[i][0] === pathArray.value[i][0]
    }

    return equalCommands
  }
  // Make path array morphable
, morph: function(pathArray) {
    pathArray = new SVG.PathArray(pathArray)

    if(this.equalCommands(pathArray)) {
      this.destination = pathArray
    } else {
      this.destination = null
    }

    return this
  }
  // Get morphed path array at given position
, at: function(pos) {
    // make sure a destination is defined
    if (!this.destination) return this

    var sourceArray = this.value
      , destinationArray = this.destination.value
      , array = [], pathArray = new SVG.PathArray()
      , i, il, j, jl

    // Animate has specified in the SVG spec
    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement
    for (i = 0, il = sourceArray.length; i < il; i++) {
      array[i] = [sourceArray[i][0]]
      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {
        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos
      }
      // For the two flags of the elliptical arc command, the SVG spec say:
      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true
      // Elliptical arc command as an array followed by corresponding indexes:
      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
      //   0    1   2        3                 4             5      6  7
      if(array[i][0] === 'A') {
        array[i][4] = +(array[i][4] != 0)
        array[i][5] = +(array[i][5] != 0)
      }
    }

    // Directly modify the value of a path array, this is done this way for performance
    pathArray.value = array
    return pathArray
  }
  // Absolutize and parse path to array
, parse: function(array) {
    // if it's already a patharray, no need to parse it
    if (array instanceof SVG.PathArray) return array.valueOf()

    // prepare for parsing
    var i, x0, y0, s, seg, arr
      , x = 0
      , y = 0
      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7, 'Z':0 }

    if(typeof array == 'string'){

      array = array
        .replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123
        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers
        .replace(SVG.regex.hyphen, '$1 -')      // add space before hyphen
        .trim()                                 // trim
        .split(SVG.regex.delimiter)   // split into array

    }else{
      array = array.reduce(function(prev, curr){
        return [].concat.call(prev, curr)
      }, [])
    }

    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]
    var arr = []
      , p = new SVG.Point()
      , p0 = new SVG.Point()
      , index = 0
      , len = array.length

    do{
      // Test if we have a path letter
      if(SVG.regex.isPathLetter.test(array[index])){
        s = array[index]
        ++index
      // If last letter was a move command and we got no new, it defaults to [L]ine
      }else if(s == 'M'){
        s = 'L'
      }else if(s == 'm'){
        s = 'l'
      }

      arr.push(pathHandlers[s].call(null,
          array.slice(index, (index = index + paramCnt[s.toUpperCase()])).map(parseFloat),
          p, p0
        )
      )

    }while(len > index)

    return arr

  }
  // Get bounding box of path
, bbox: function() {
    SVG.parser.path.setAttribute('d', this.toString())

    return SVG.parser.path.getBBox()
  }

})

// Module for unit convertions
SVG.Number = SVG.invent({
  // Initialize
  create: function(value, unit) {
    // initialize defaults
    this.value = 0
    this.unit  = unit || ''

    // parse value
    if (typeof value === 'number') {
      // ensure a valid numeric value
      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value

    } else if (typeof value === 'string') {
      unit = value.match(SVG.regex.numberAndUnit)

      if (unit) {
        // make value numeric
        this.value = parseFloat(unit[1])

        // normalize
        if (unit[5] == '%')
          this.value /= 100
        else if (unit[5] == 's')
          this.value *= 1000

        // store unit
        this.unit = unit[5]
      }

    } else {
      if (value instanceof SVG.Number) {
        this.value = value.valueOf()
        this.unit  = value.unit
      }
    }

  }
  // Add methods
, extend: {
    // Stringalize
    toString: function() {
      return (
        this.unit == '%' ?
          ~~(this.value * 1e8) / 1e6:
        this.unit == 's' ?
          this.value / 1e3 :
          this.value
      ) + this.unit
    }
  , toJSON: function() {
      return this.toString()
    }
  , // Convert to primitive
    valueOf: function() {
      return this.value
    }
    // Add number
  , plus: function(number) {
      number = new SVG.Number(number)
      return new SVG.Number(this + number, this.unit || number.unit)
    }
    // Subtract number
  , minus: function(number) {
      number = new SVG.Number(number)
      return new SVG.Number(this - number, this.unit || number.unit)
    }
    // Multiply number
  , times: function(number) {
      number = new SVG.Number(number)
      return new SVG.Number(this * number, this.unit || number.unit)
    }
    // Divide number
  , divide: function(number) {
      number = new SVG.Number(number)
      return new SVG.Number(this / number, this.unit || number.unit)
    }
    // Convert to different unit
  , to: function(unit) {
      var number = new SVG.Number(this)

      if (typeof unit === 'string')
        number.unit = unit

      return number
    }
    // Make number morphable
  , morph: function(number) {
      this.destination = new SVG.Number(number)

      if(number.relative) {
        this.destination.value += this.value
      }

      return this
    }
    // Get morphed number at given position
  , at: function(pos) {
      // Make sure a destination is defined
      if (!this.destination) return this

      // Generate new morphed number
      return new SVG.Number(this.destination)
          .minus(this)
          .times(pos)
          .plus(this)
    }

  }
})


SVG.Element = SVG.invent({
  // Initialize node
  create: function(node) {
    // make stroke value accessible dynamically
    this._stroke = SVG.defaults.attrs.stroke
    this._event = null
    this._events = {}

    // initialize data object
    this.dom = {}

    // create circular reference
    if (this.node = node) {
      this.type = node.nodeName
      this.node.instance = this
      this._events = node._events || {}

      // store current attribute value
      this._stroke = node.getAttribute('stroke') || this._stroke
    }
  }

  // Add class methods
, extend: {
    // Move over x-axis
    x: function(x) {
      return this.attr('x', x)
    }
    // Move over y-axis
  , y: function(y) {
      return this.attr('y', y)
    }
    // Move by center over x-axis
  , cx: function(x) {
      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)
    }
    // Move by center over y-axis
  , cy: function(y) {
      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)
    }
    // Move element to given x and y values
  , move: function(x, y) {
      return this.x(x).y(y)
    }
    // Move element by its center
  , center: function(x, y) {
      return this.cx(x).cy(y)
    }
    // Set width of element
  , width: function(width) {
      return this.attr('width', width)
    }
    // Set height of element
  , height: function(height) {
      return this.attr('height', height)
    }
    // Set element size to given width and height
  , size: function(width, height) {
      var p = proportionalSize(this, width, height)

      return this
        .width(new SVG.Number(p.width))
        .height(new SVG.Number(p.height))
    }
    // Clone element
  , clone: function(parent) {
      // write dom data to the dom so the clone can pickup the data
      this.writeDataToDom()

      // clone element and assign new id
      var clone = assignNewId(this.node.cloneNode(true))

      // insert the clone in the given parent or after myself
      if(parent) parent.add(clone)
      else this.after(clone)

      return clone
    }
    // Remove element
  , remove: function() {
      if (this.parent())
        this.parent().removeElement(this)

      return this
    }
    // Replace element
  , replace: function(element) {
      this.after(element).remove()

      return element
    }
    // Add element to given container and return self
  , addTo: function(parent) {
      return parent.put(this)
    }
    // Add element to given container and return container
  , putIn: function(parent) {
      return parent.add(this)
    }
    // Get / set id
  , id: function(id) {
      return this.attr('id', id)
    }
    // Checks whether the given point inside the bounding box of the element
  , inside: function(x, y) {
      var box = this.bbox()

      return x > box.x
          && y > box.y
          && x < box.x + box.width
          && y < box.y + box.height
    }
    // Show element
  , show: function() {
      return this.style('display', '')
    }
    // Hide element
  , hide: function() {
      return this.style('display', 'none')
    }
    // Is element visible?
  , visible: function() {
      return this.style('display') != 'none'
    }
    // Return id on string conversion
  , toString: function() {
      return this.attr('id')
    }
    // Return array of classes on the node
  , classes: function() {
      var attr = this.attr('class')

      return attr == null ? [] : attr.trim().split(SVG.regex.delimiter)
    }
    // Return true if class exists on the node, false otherwise
  , hasClass: function(name) {
      return this.classes().indexOf(name) != -1
    }
    // Add class to the node
  , addClass: function(name) {
      if (!this.hasClass(name)) {
        var array = this.classes()
        array.push(name)
        this.attr('class', array.join(' '))
      }

      return this
    }
    // Remove class from the node
  , removeClass: function(name) {
      if (this.hasClass(name)) {
        this.attr('class', this.classes().filter(function(c) {
          return c != name
        }).join(' '))
      }

      return this
    }
    // Toggle the presence of a class on the node
  , toggleClass: function(name) {
      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)
    }
    // Get referenced element form attribute value
  , reference: function(attr) {
      return SVG.get(this.attr(attr))
    }
    // Returns the parent element instance
  , parent: function(type) {
      var parent = this

      // check for parent
      if(!parent.node.parentNode) return null

      // get parent element
      parent = SVG.adopt(parent.node.parentNode)

      if(!type) return parent

      // loop trough ancestors if type is given
      while(parent && parent.node instanceof window.SVGElement){
        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent
        if(!parent.node.parentNode || parent.node.parentNode.nodeName == '#document' || parent.node.parentNode.nodeName == '#document-fragment') return null // #759, #720
        parent = SVG.adopt(parent.node.parentNode)
      }
    }
    // Get parent document
  , doc: function() {
      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)
    }
    // return array of all ancestors of given type up to the root svg
  , parents: function(type) {
      var parents = [], parent = this

      do{
        parent = parent.parent(type)
        if(!parent || !parent.node) break

        parents.push(parent)
      } while(parent.parent)

      return parents
    }
    // matches the element vs a css selector
  , matches: function(selector){
      return matches(this.node, selector)
    }
    // Returns the svg node to call native svg methods on it
  , native: function() {
      return this.node
    }
    // Import raw svg
  , svg: function(svg) {
      // create temporary holder
      var well = document.createElement('svg')

      // act as a setter if svg is given
      if (svg && this instanceof SVG.Parent) {
        // dump raw svg
        well.innerHTML = '<svg>' + svg.replace(/\n/, '').replace(/<([\w:-]+)([^<]+?)\/>/g, '<$1$2></$1>') + '</svg>'

        // transplant nodes
        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)
          this.node.appendChild(well.firstChild.firstChild)

      // otherwise act as a getter
      } else {
        // create a wrapping svg element in case of partial content
        well.appendChild(svg = document.createElement('svg'))

        // write svgjs data to the dom
        this.writeDataToDom()

        // insert a copy of this node
        svg.appendChild(this.node.cloneNode(true))

        // return target element
        return well.innerHTML.replace(/^<svg>/, '').replace(/<\/svg>$/, '')
      }

      return this
    }
  // write svgjs data to the dom
  , writeDataToDom: function() {

      // dump variables recursively
      if(this.each || this.lines){
        var fn = this.each ? this : this.lines();
        fn.each(function(){
          this.writeDataToDom()
        })
      }

      // remove previously set data
      this.node.removeAttribute('svgjs:data')

      if(Object.keys(this.dom).length)
        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428

      return this
    }
  // set given data to the elements data property
  , setData: function(o){
      this.dom = o
      return this
    }
  , is: function(obj){
      return is(this, obj)
    }
  }
})

SVG.easing = {
  '-': function(pos){return pos}
, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}
, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}
, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}
}

SVG.morph = function(pos){
  return function(from, to) {
    return new SVG.MorphObj(from, to).at(pos)
  }
}

SVG.Situation = SVG.invent({

  create: function(o){
    this.init = false
    this.reversed = false
    this.reversing = false

    this.duration = new SVG.Number(o.duration).valueOf()
    this.delay = new SVG.Number(o.delay).valueOf()

    this.start = +new Date() + this.delay
    this.finish = this.start + this.duration
    this.ease = o.ease

    // this.loop is incremented from 0 to this.loops
    // it is also incremented when in an infinite loop (when this.loops is true)
    this.loop = 0
    this.loops = false

    this.animations = {
      // functionToCall: [list of morphable objects]
      // e.g. move: [SVG.Number, SVG.Number]
    }

    this.attrs = {
      // holds all attributes which are not represented from a function svg.js provides
      // e.g. someAttr: SVG.Number
    }

    this.styles = {
      // holds all styles which should be animated
      // e.g. fill-color: SVG.Color
    }

    this.transforms = [
      // holds all transformations as transformation objects
      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]
    ]

    this.once = {
      // functions to fire at a specific position
      // e.g. "0.5": function foo(){}
    }

  }

})


SVG.FX = SVG.invent({

  create: function(element) {
    this._target = element
    this.situations = []
    this.active = false
    this.situation = null
    this.paused = false
    this.lastPos = 0
    this.pos = 0
    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)
    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1
    this.absPos = 0
    this._speed = 1
  }

, extend: {

    /**
     * sets or returns the target of this animation
     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation
     * @param ease function || string Function which should be used for easing or easing keyword
     * @param delay Number indicating the delay before the animation starts
     * @return target || this
     */
    animate: function(o, ease, delay){

      if(typeof o == 'object'){
        ease = o.ease
        delay = o.delay
        o = o.duration
      }

      var situation = new SVG.Situation({
        duration: o || 1000,
        delay: delay || 0,
        ease: SVG.easing[ease || '-'] || ease
      })

      this.queue(situation)

      return this
    }

    /**
     * sets a delay before the next element of the queue is called
     * @param delay Duration of delay in milliseconds
     * @return this.target()
     */
  , delay: function(delay){
      // The delay is performed by an empty situation with its duration
      // attribute set to the duration of the delay
      var situation = new SVG.Situation({
        duration: delay,
        delay: 0,
        ease: SVG.easing['-']
      })

      return this.queue(situation)
    }

    /**
     * sets or returns the target of this animation
     * @param null || target SVG.Element which should be set as new target
     * @return target || this
     */
  , target: function(target){
      if(target && target instanceof SVG.Element){
        this._target = target
        return this
      }

      return this._target
    }

    // returns the absolute position at a given time
  , timeToAbsPos: function(timestamp){
      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)
    }

    // returns the timestamp from a given absolute positon
  , absPosToTime: function(absPos){
      return this.situation.duration/this._speed * absPos + this.situation.start
    }

    // starts the animationloop
  , startAnimFrame: function(){
      this.stopAnimFrame()
      this.animationFrame = window.requestAnimationFrame(function(){ this.step() }.bind(this))
    }

    // cancels the animationframe
  , stopAnimFrame: function(){
      window.cancelAnimationFrame(this.animationFrame)
    }

    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set
  , start: function(){
      // dont start if already started
      if(!this.active && this.situation){
        this.active = true
        this.startCurrent()
      }

      return this
    }

    // start the current situation
  , startCurrent: function(){
      this.situation.start = +new Date + this.situation.delay/this._speed
      this.situation.finish = this.situation.start + this.situation.duration/this._speed
      return this.initAnimations().step()
    }

    /**
     * adds a function / Situation to the animation queue
     * @param fn function / situation to add
     * @return this
     */
  , queue: function(fn){
      if(typeof fn == 'function' || fn instanceof SVG.Situation)
        this.situations.push(fn)

      if(!this.situation) this.situation = this.situations.shift()

      return this
    }

    /**
     * pulls next element from the queue and execute it
     * @return this
     */
  , dequeue: function(){
      // stop current animation
      this.stop()

      // get next animation from queue
      this.situation = this.situations.shift()

      if(this.situation){
        if(this.situation instanceof SVG.Situation) {
          this.start()
        } else {
          // If it is not a SVG.Situation, then it is a function, we execute it
          this.situation.call(this)
        }
      }

      return this
    }

    // updates all animations to the current state of the element
    // this is important when one property could be changed from another property
  , initAnimations: function() {
      var i, j, source
      var s = this.situation

      if(s.init) return this

      for(i in s.animations){
        source = this.target()[i]()

        if(!Array.isArray(source)) {
          source = [source]
        }

        if(!Array.isArray(s.animations[i])) {
          s.animations[i] = [s.animations[i]]
        }

        //if(s.animations[i].length > source.length) {
        //  source.concat = source.concat(s.animations[i].slice(source.length, s.animations[i].length))
        //}

        for(j = source.length; j--;) {
          // The condition is because some methods return a normal number instead
          // of a SVG.Number
          if(s.animations[i][j] instanceof SVG.Number)
            source[j] = new SVG.Number(source[j])

          s.animations[i][j] = source[j].morph(s.animations[i][j])
        }
      }

      for(i in s.attrs){
        s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i])
      }

      for(i in s.styles){
        s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i])
      }

      s.initialTransformation = this.target().matrixify()

      s.init = true
      return this
    }
  , clearQueue: function(){
      this.situations = []
      return this
    }
  , clearCurrent: function(){
      this.situation = null
      return this
    }
    /** stops the animation immediately
     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.
     * @param clearQueue A Boolean indicating whether to remove queued animation as well.
     * @return this
     */
  , stop: function(jumpToEnd, clearQueue){
      var active = this.active
      this.active = false

      if(clearQueue){
        this.clearQueue()
      }

      if(jumpToEnd && this.situation){
        // initialize the situation if it was not
        !active && this.startCurrent()
        this.atEnd()
      }

      this.stopAnimFrame()

      return this.clearCurrent()
    }

    /** resets the element to the state where the current element has started
     * @return this
     */
  , reset: function(){
      if(this.situation){
        var temp = this.situation
        this.stop()
        this.situation = temp
        this.atStart()
      }
      return this
    }

    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.
  , finish: function(){

      this.stop(true, false)

      while(this.dequeue().situation && this.stop(true, false));

      this.clearQueue().clearCurrent()

      return this
    }

    // set the internal animation pointer at the start position, before any loops, and updates the visualisation
  , atStart: function() {
      return this.at(0, true)
    }

    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation
  , atEnd: function() {
      if (this.situation.loops === true) {
        // If in a infinite loop, we end the current iteration
        this.situation.loops = this.situation.loop + 1
      }

      if(typeof this.situation.loops == 'number') {
        // If performing a finite number of loops, we go after all the loops
        return this.at(this.situation.loops, true)
      } else {
        // If no loops, we just go at the end
        return this.at(1, true)
      }
    }

    // set the internal animation pointer to the specified position and updates the visualisation
    // if isAbsPos is true, pos is treated as an absolute position
  , at: function(pos, isAbsPos){
      var durDivSpd = this.situation.duration/this._speed

      this.absPos = pos
      // If pos is not an absolute position, we convert it into one
      if (!isAbsPos) {
        if (this.situation.reversed) this.absPos = 1 - this.absPos
        this.absPos += this.situation.loop
      }

      this.situation.start = +new Date - this.absPos * durDivSpd
      this.situation.finish = this.situation.start + durDivSpd

      return this.step(true)
    }

    /**
     * sets or returns the speed of the animations
     * @param speed null || Number The new speed of the animations
     * @return Number || this
     */
  , speed: function(speed){
      if (speed === 0) return this.pause()

      if (speed) {
        this._speed = speed
        // We use an absolute position here so that speed can affect the delay before the animation
        return this.at(this.absPos, true)
      } else return this._speed
    }

    // Make loopable
  , loop: function(times, reverse) {
      var c = this.last()

      // store total loops
      c.loops = (times != null) ? times : true
      c.loop = 0

      if(reverse) c.reversing = true
      return this
    }

    // pauses the animation
  , pause: function(){
      this.paused = true
      this.stopAnimFrame()

      return this
    }

    // unpause the animation
  , play: function(){
      if(!this.paused) return this
      this.paused = false
      // We use an absolute position here so that the delay before the animation can be paused
      return this.at(this.absPos, true)
    }

    /**
     * toggle or set the direction of the animation
     * true sets direction to backwards while false sets it to forwards
     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)
     * @return this
     */
  , reverse: function(reversed){
      var c = this.last()

      if(typeof reversed == 'undefined') c.reversed = !c.reversed
      else c.reversed = reversed

      return this
    }


    /**
     * returns a float from 0-1 indicating the progress of the current animation
     * @param eased Boolean indicating whether the returned position should be eased or not
     * @return number
     */
  , progress: function(easeIt){
      return easeIt ? this.situation.ease(this.pos) : this.pos
    }

    /**
     * adds a callback function which is called when the current animation is finished
     * @param fn Function which should be executed as callback
     * @return number
     */
  , after: function(fn){
      var c = this.last()
        , wrapper = function wrapper(e){
            if(e.detail.situation == c){
              fn.call(this, c)
              this.off('finished.fx', wrapper) // prevent memory leak
            }
          }

      this.target().on('finished.fx', wrapper)

      return this._callStart()
    }

    // adds a callback which is called whenever one animation step is performed
  , during: function(fn){
      var c = this.last()
        , wrapper = function(e){
            if(e.detail.situation == c){
              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)
            }
          }

      // see above
      this.target().off('during.fx', wrapper).on('during.fx', wrapper)

      this.after(function(){
        this.off('during.fx', wrapper)
      })

      return this._callStart()
    }

    // calls after ALL animations in the queue are finished
  , afterAll: function(fn){
      var wrapper = function wrapper(e){
            fn.call(this)
            this.off('allfinished.fx', wrapper)
          }

      // see above
      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)

      return this._callStart()
    }

    // calls on every animation step for all animations
  , duringAll: function(fn){
      var wrapper = function(e){
            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)
          }

      this.target().off('during.fx', wrapper).on('during.fx', wrapper)

      this.afterAll(function(){
        this.off('during.fx', wrapper)
      })

      return this._callStart()
    }

  , last: function(){
      return this.situations.length ? this.situations[this.situations.length-1] : this.situation
    }

    // adds one property to the animations
  , add: function(method, args, type){
      this.last()[type || 'animations'][method] = args
      return this._callStart()
    }

    /** perform one step of the animation
     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time
     *  @return this
     */
  , step: function(ignoreTime){

      // convert current time to an absolute position
      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)

      // This part convert an absolute position to a position
      if(this.situation.loops !== false) {
        var absPos, absPosInt, lastLoop

        // If the absolute position is below 0, we just treat it as if it was 0
        absPos = Math.max(this.absPos, 0)
        absPosInt = Math.floor(absPos)

        if(this.situation.loops === true || absPosInt < this.situation.loops) {
          this.pos = absPos - absPosInt
          lastLoop = this.situation.loop
          this.situation.loop = absPosInt
        } else {
          this.absPos = this.situation.loops
          this.pos = 1
          // The -1 here is because we don't want to toggle reversed when all the loops have been completed
          lastLoop = this.situation.loop - 1
          this.situation.loop = this.situation.loops
        }

        if(this.situation.reversing) {
          // Toggle reversed if an odd number of loops as occured since the last call of step
          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)
        }

      } else {
        // If there are no loop, the absolute position must not be above 1
        this.absPos = Math.min(this.absPos, 1)
        this.pos = this.absPos
      }

      // while the absolute position can be below 0, the position must not be below 0
      if(this.pos < 0) this.pos = 0

      if(this.situation.reversed) this.pos = 1 - this.pos


      // apply easing
      var eased = this.situation.ease(this.pos)

      // call once-callbacks
      for(var i in this.situation.once){
        if(i > this.lastPos && i <= eased){
          this.situation.once[i].call(this.target(), this.pos, eased)
          delete this.situation.once[i]
        }
      }

      // fire during callback with position, eased position and current situation as parameter
      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})

      // the user may call stop or finish in the during callback
      // so make sure that we still have a valid situation
      if(!this.situation){
        return this
      }

      // apply the actual animation to every property
      this.eachAt()

      // do final code when situation is finished
      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){

        // stop animation callback
        this.stopAnimFrame()

        // fire finished callback with current situation as parameter
        this.target().fire('finished', {fx:this, situation: this.situation})

        if(!this.situations.length){
          this.target().fire('allfinished')

          // Recheck the length since the user may call animate in the afterAll callback
          if(!this.situations.length){
            this.target().off('.fx') // there shouldnt be any binding left, but to make sure...
            this.active = false
          }
        }

        // start next animation
        if(this.active) this.dequeue()
        else this.clearCurrent()

      }else if(!this.paused && this.active){
        // we continue animating when we are not at the end
        this.startAnimFrame()
      }

      // save last eased position for once callback triggering
      this.lastPos = eased
      return this

    }

    // calculates the step for every property and calls block with it
  , eachAt: function(){
      var i, len, at, self = this, target = this.target(), s = this.situation

      // apply animations which can be called trough a method
      for(i in s.animations){

        at = [].concat(s.animations[i]).map(function(el){
          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el
        })

        target[i].apply(target, at)

      }

      // apply animation which has to be applied with attr()
      for(i in s.attrs){

        at = [i].concat(s.attrs[i]).map(function(el){
          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el
        })

        target.attr.apply(target, at)

      }

      // apply animation which has to be applied with style()
      for(i in s.styles){

        at = [i].concat(s.styles[i]).map(function(el){
          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el
        })

        target.style.apply(target, at)

      }

      // animate initialTransformation which has to be chained
      if(s.transforms.length){

        // get initial initialTransformation
        at = s.initialTransformation
        for(i = 0, len = s.transforms.length; i < len; i++){

          // get next transformation in chain
          var a = s.transforms[i]

          // multiply matrix directly
          if(a instanceof SVG.Matrix){

            if(a.relative){
              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))
            }else{
              at = at.morph(a).at(s.ease(this.pos))
            }
            continue
          }

          // when transformation is absolute we have to reset the needed transformation first
          if(!a.relative)
            a.undo(at.extract())

          // and reapply it after
          at = at.multiply(a.at(s.ease(this.pos)))

        }

        // set new matrix on element
        target.matrix(at)
      }

      return this

    }


    // adds an once-callback which is called at a specific position and never again
  , once: function(pos, fn, isEased){
      var c = this.last()
      if(!isEased) pos = c.ease(pos)

      c.once[pos] = fn

      return this
    }

  , _callStart: function() {
      setTimeout(function(){this.start()}.bind(this), 0)
      return this
    }

  }

, parent: SVG.Element

  // Add method to parent elements
, construct: {
    // Get fx module or create a new one, then animate with given duration and ease
    animate: function(o, ease, delay) {
      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)
    }
  , delay: function(delay){
      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)
    }
  , stop: function(jumpToEnd, clearQueue) {
      if (this.fx)
        this.fx.stop(jumpToEnd, clearQueue)

      return this
    }
  , finish: function() {
      if (this.fx)
        this.fx.finish()

      return this
    }
    // Pause current animation
  , pause: function() {
      if (this.fx)
        this.fx.pause()

      return this
    }
    // Play paused current animation
  , play: function() {
      if (this.fx)
        this.fx.play()

      return this
    }
    // Set/Get the speed of the animations
  , speed: function(speed) {
      if (this.fx)
        if (speed == null)
          return this.fx.speed()
        else
          this.fx.speed(speed)

      return this
    }
  }

})

// MorphObj is used whenever no morphable object is given
SVG.MorphObj = SVG.invent({

  create: function(from, to){
    // prepare color for morphing
    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)
    // check if we have a list of values
    if(SVG.regex.delimiter.test(from)) {
      // prepare path for morphing
      if(SVG.regex.pathLetters.test(from)) return new SVG.PathArray(from).morph(to)
      // prepare value list for morphing
      else return new SVG.Array(from).morph(to)
    }
    // prepare number for morphing
    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)

    // prepare for plain morphing
    this.value = from
    this.destination = to
  }

, extend: {
    at: function(pos, real){
      return real < 1 ? this.value : this.destination
    },

    valueOf: function(){
      return this.value
    }
  }

})

SVG.extend(SVG.FX, {
  // Add animatable attributes
  attr: function(a, v, relative) {
    // apply attributes individually
    if (typeof a == 'object') {
      for (var key in a)
        this.attr(key, a[key])

    } else {
      this.add(a, v, 'attrs')
    }

    return this
  }
  // Add animatable styles
, style: function(s, v) {
    if (typeof s == 'object')
      for (var key in s)
        this.style(key, s[key])

    else
      this.add(s, v, 'styles')

    return this
  }
  // Animatable x-axis
, x: function(x, relative) {
    if(this.target() instanceof SVG.G){
      this.transform({x:x}, relative)
      return this
    }

    var num = new SVG.Number(x)
    num.relative = relative
    return this.add('x', num)
  }
  // Animatable y-axis
, y: function(y, relative) {
    if(this.target() instanceof SVG.G){
      this.transform({y:y}, relative)
      return this
    }

    var num = new SVG.Number(y)
    num.relative = relative
    return this.add('y', num)
  }
  // Animatable center x-axis
, cx: function(x) {
    return this.add('cx', new SVG.Number(x))
  }
  // Animatable center y-axis
, cy: function(y) {
    return this.add('cy', new SVG.Number(y))
  }
  // Add animatable move
, move: function(x, y) {
    return this.x(x).y(y)
  }
  // Add animatable center
, center: function(x, y) {
    return this.cx(x).cy(y)
  }
  // Add animatable size
, size: function(width, height) {
    if (this.target() instanceof SVG.Text) {
      // animate font size for Text elements
      this.attr('font-size', width)

    } else {
      // animate bbox based size for all other elements
      var box

      if(!width || !height){
        box = this.target().bbox()
      }

      if(!width){
        width = box.width / box.height  * height
      }

      if(!height){
        height = box.height / box.width  * width
      }

      this.add('width' , new SVG.Number(width))
          .add('height', new SVG.Number(height))

    }

    return this
  }
  // Add animatable width
, width: function(width) {
    return this.add('width', new SVG.Number(width))
  }
  // Add animatable height
, height: function(height) {
    return this.add('height', new SVG.Number(height))
  }
  // Add animatable plot
, plot: function(a, b, c, d) {
    // Lines can be plotted with 4 arguments
    if(arguments.length == 4) {
      return this.plot([a, b, c, d])
    }

    return this.add('plot', new (this.target().morphArray)(a))
  }
  // Add leading method
, leading: function(value) {
    return this.target().leading ?
      this.add('leading', new SVG.Number(value)) :
      this
  }
  // Add animatable viewbox
, viewbox: function(x, y, width, height) {
    if (this.target() instanceof SVG.Container) {
      this.add('viewbox', new SVG.ViewBox(x, y, width, height))
    }

    return this
  }
, update: function(o) {
    if (this.target() instanceof SVG.Stop) {
      if (typeof o == 'number' || o instanceof SVG.Number) {
        return this.update({
          offset:  arguments[0]
        , color:   arguments[1]
        , opacity: arguments[2]
        })
      }

      if (o.opacity != null) this.attr('stop-opacity', o.opacity)
      if (o.color   != null) this.attr('stop-color', o.color)
      if (o.offset  != null) this.attr('offset', o.offset)
    }

    return this
  }
})

SVG.Box = SVG.invent({
  create: function(x, y, width, height) {
    if (typeof x == 'object' && !(x instanceof SVG.Element)) {
      // chromes getBoundingClientRect has no x and y property
      return SVG.Box.call(this, x.left != null ? x.left : x.x , x.top != null ? x.top : x.y, x.width, x.height)
    } else if (arguments.length == 4) {
      this.x = x
      this.y = y
      this.width = width
      this.height = height
    }

    // add center, right, bottom...
    fullBox(this)
  }
, extend: {
    // Merge rect box with another, return a new instance
    merge: function(box) {
      var b = new this.constructor()

      // merge boxes
      b.x      = Math.min(this.x, box.x)
      b.y      = Math.min(this.y, box.y)
      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x
      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y

      return fullBox(b)
    }

  , transform: function(m) {
      var xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, p, bbox

      var pts = [
        new SVG.Point(this.x, this.y),
        new SVG.Point(this.x2, this.y),
        new SVG.Point(this.x, this.y2),
        new SVG.Point(this.x2, this.y2)
      ]

      pts.forEach(function(p) {
        p = p.transform(m)
        xMin = Math.min(xMin,p.x)
        xMax = Math.max(xMax,p.x)
        yMin = Math.min(yMin,p.y)
        yMax = Math.max(yMax,p.y)
      })

      bbox = new this.constructor()
      bbox.x = xMin
      bbox.width = xMax-xMin
      bbox.y = yMin
      bbox.height = yMax-yMin

      fullBox(bbox)

      return bbox
    }
  }
})

SVG.BBox = SVG.invent({
  // Initialize
  create: function(element) {
    SVG.Box.apply(this, [].slice.call(arguments))

    // get values if element is given
    if (element instanceof SVG.Element) {
      var box

      // yes this is ugly, but Firefox can be a pain when it comes to elements that are not yet rendered
      try {

        if (!document.documentElement.contains){
          // This is IE - it does not support contains() for top-level SVGs
          var topParent = element.node
          while (topParent.parentNode){
            topParent = topParent.parentNode
          }
          if (topParent != document) throw new Exception('Element not in the dom')
        } else {
          // the element is NOT in the dom, throw error
          if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')
        }

        // find native bbox
        box = element.node.getBBox()
      } catch(e) {
        if(element instanceof SVG.Shape){
          var clone = element.clone(SVG.parser.draw.instance).show()
          box = clone.node.getBBox()
          clone.remove()
        }else{
          box = {
            x:      element.node.clientLeft
          , y:      element.node.clientTop
          , width:  element.node.clientWidth
          , height: element.node.clientHeight
          }
        }
      }

      SVG.Box.call(this, box)
    }

  }

  // Define ancestor
, inherit: SVG.Box

  // Define Parent
, parent: SVG.Element

  // Constructor
, construct: {
    // Get bounding box
    bbox: function() {
      return new SVG.BBox(this)
    }
  }

})

SVG.BBox.prototype.constructor = SVG.BBox


SVG.extend(SVG.Element, {
  tbox: function(){
    console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.')
    return this.rbox(this.doc())
  }
})

SVG.RBox = SVG.invent({
  // Initialize
  create: function(element) {
    SVG.Box.apply(this, [].slice.call(arguments))

    if (element instanceof SVG.Element) {
      SVG.Box.call(this, element.node.getBoundingClientRect())
    }
  }

, inherit: SVG.Box

  // define Parent
, parent: SVG.Element

, extend: {
    addOffset: function() {
      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
      this.x += window.pageXOffset
      this.y += window.pageYOffset
      return this
    }
  }

  // Constructor
, construct: {
    // Get rect box
    rbox: function(el) {
      if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse())
      return new SVG.RBox(this).addOffset()
    }
  }

})

SVG.RBox.prototype.constructor = SVG.RBox

SVG.Matrix = SVG.invent({
  // Initialize
  create: function(source) {
    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])

    // ensure source as object
    source = source instanceof SVG.Element ?
      source.matrixify() :
    typeof source === 'string' ?
      arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) :
    arguments.length == 6 ?
      arrayToMatrix([].slice.call(arguments)) :
    Array.isArray(source) ?
      arrayToMatrix(source) :
    typeof source === 'object' ?
      source : base

    // merge source
    for (i = abcdef.length - 1; i >= 0; --i)
      this[abcdef[i]] = source[abcdef[i]] != null ?
        source[abcdef[i]] : base[abcdef[i]]
  }

  // Add methods
, extend: {
    // Extract individual transformations
    extract: function() {
      // find delta transform points
      var px    = deltaTransformPoint(this, 0, 1)
        , py    = deltaTransformPoint(this, 1, 0)
        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90

      return {
        // translation
        x:        this.e
      , y:        this.f
      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)
      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)
        // skew
      , skewX:    -skewX
      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)
        // scale
      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)
      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)
        // rotation
      , rotation: skewX
      , a: this.a
      , b: this.b
      , c: this.c
      , d: this.d
      , e: this.e
      , f: this.f
      , matrix: new SVG.Matrix(this)
      }
    }
    // Clone matrix
  , clone: function() {
      return new SVG.Matrix(this)
    }
    // Morph one matrix into another
  , morph: function(matrix) {
      // store new destination
      this.destination = new SVG.Matrix(matrix)

      return this
    }
    // Get morphed matrix at a given position
  , at: function(pos) {
      // make sure a destination is defined
      if (!this.destination) return this

      // calculate morphed matrix at a given position
      var matrix = new SVG.Matrix({
        a: this.a + (this.destination.a - this.a) * pos
      , b: this.b + (this.destination.b - this.b) * pos
      , c: this.c + (this.destination.c - this.c) * pos
      , d: this.d + (this.destination.d - this.d) * pos
      , e: this.e + (this.destination.e - this.e) * pos
      , f: this.f + (this.destination.f - this.f) * pos
      })

      return matrix
    }
    // Multiplies by given matrix
  , multiply: function(matrix) {
      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))
    }
    // Inverses matrix
  , inverse: function() {
      return new SVG.Matrix(this.native().inverse())
    }
    // Translate matrix
  , translate: function(x, y) {
      return new SVG.Matrix(this.native().translate(x || 0, y || 0))
    }
    // Scale matrix
  , scale: function(x, y, cx, cy) {
      // support uniformal scale
      if (arguments.length == 1) {
        y = x
      } else if (arguments.length == 3) {
        cy = cx
        cx = y
        y = x
      }

      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))
    }
    // Rotate matrix
  , rotate: function(r, cx, cy) {
      // convert degrees to radians
      r = SVG.utils.radians(r)

      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))
    }
    // Flip matrix on x or y, at a given offset
  , flip: function(a, o) {
      return a == 'x' ?
          this.scale(-1, 1, o, 0) :
        a == 'y' ?
          this.scale(1, -1, 0, o) :
          this.scale(-1, -1, a, o != null ? o : a)
    }
    // Skew
  , skew: function(x, y, cx, cy) {
      // support uniformal skew
      if (arguments.length == 1) {
        y = x
      } else if (arguments.length == 3) {
        cy = cx
        cx = y
        y = x
      }

      // convert degrees to radians
      x = SVG.utils.radians(x)
      y = SVG.utils.radians(y)

      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))
    }
    // SkewX
  , skewX: function(x, cx, cy) {
      return this.skew(x, 0, cx, cy)
    }
    // SkewY
  , skewY: function(y, cx, cy) {
      return this.skew(0, y, cx, cy)
    }
    // Transform around a center point
  , around: function(cx, cy, matrix) {
      return this
        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))
        .multiply(matrix)
        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))
    }
    // Convert to native SVGMatrix
  , native: function() {
      // create new matrix
      var matrix = SVG.parser.native.createSVGMatrix()

      // update with current values
      for (var i = abcdef.length - 1; i >= 0; i--)
        matrix[abcdef[i]] = this[abcdef[i]]

      return matrix
    }
    // Convert matrix to string
  , toString: function() {
      // Construct the matrix directly, avoid values that are too small
      return 'matrix(' + float32String(this.a) + ',' + float32String(this.b)
        + ',' + float32String(this.c) + ',' + float32String(this.d)
        + ',' + float32String(this.e) + ',' + float32String(this.f)
        + ')'
    }
  }

  // Define parent
, parent: SVG.Element

  // Add parent method
, construct: {
    // Get current matrix
    ctm: function() {
      return new SVG.Matrix(this.node.getCTM())
    },
    // Get current screen matrix
    screenCTM: function() {
      /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
         This is needed because FF does not return the transformation matrix
         for the inner coordinate system when getScreenCTM() is called on nested svgs.
         However all other Browsers do that */
      if(this instanceof SVG.Nested) {
        var rect = this.rect(1,1)
        var m = rect.node.getScreenCTM()
        rect.remove()
        return new SVG.Matrix(m)
      }
      return new SVG.Matrix(this.node.getScreenCTM())
    }

  }

})

SVG.Point = SVG.invent({
  // Initialize
  create: function(x,y) {
    var i, source, base = {x:0, y:0}

    // ensure source as object
    source = Array.isArray(x) ?
      {x:x[0], y:x[1]} :
    typeof x === 'object' ?
      {x:x.x, y:x.y} :
    x != null ?
      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value

    // merge source
    this.x = source.x
    this.y = source.y
  }

  // Add methods
, extend: {
    // Clone point
    clone: function() {
      return new SVG.Point(this)
    }
    // Morph one point into another
  , morph: function(x, y) {
      // store new destination
      this.destination = new SVG.Point(x, y)

      return this
    }
    // Get morphed point at a given position
  , at: function(pos) {
      // make sure a destination is defined
      if (!this.destination) return this

      // calculate morphed matrix at a given position
      var point = new SVG.Point({
        x: this.x + (this.destination.x - this.x) * pos
      , y: this.y + (this.destination.y - this.y) * pos
      })

      return point
    }
    // Convert to native SVGPoint
  , native: function() {
      // create new point
      var point = SVG.parser.native.createSVGPoint()

      // update with current values
      point.x = this.x
      point.y = this.y

      return point
    }
    // transform point with matrix
  , transform: function(matrix) {
      return new SVG.Point(this.native().matrixTransform(matrix.native()))
    }

  }

})

SVG.extend(SVG.Element, {

  // Get point
  point: function(x, y) {
    return new SVG.Point(x,y).transform(this.screenCTM().inverse());
  }

})

SVG.extend(SVG.Element, {
  // Set svg element attribute
  attr: function(a, v, n) {
    // act as full getter
    if (a == null) {
      // get an object of attributes
      a = {}
      v = this.node.attributes
      for (n = v.length - 1; n >= 0; n--)
        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue

      return a

    } else if (typeof a == 'object') {
      // apply every attribute individually if an object is passed
      for (v in a) this.attr(v, a[v])

    } else if (v === null) {
        // remove value
        this.node.removeAttribute(a)

    } else if (v == null) {
      // act as a getter if the first and only argument is not an object
      v = this.node.getAttribute(a)
      return v == null ?
        SVG.defaults.attrs[a] :
      SVG.regex.isNumber.test(v) ?
        parseFloat(v) : v

    } else {
      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0
      if (a == 'stroke-width')
        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)
      else if (a == 'stroke')
        this._stroke = v

      // convert image fill and stroke to patterns
      if (a == 'fill' || a == 'stroke') {
        if (SVG.regex.isImage.test(v))
          v = this.doc().defs().image(v, 0, 0)

        if (v instanceof SVG.Image)
          v = this.doc().defs().pattern(0, 0, function() {
            this.add(v)
          })
      }

      // ensure correct numeric values (also accepts NaN and Infinity)
      if (typeof v === 'number')
        v = new SVG.Number(v)

      // ensure full hex color
      else if (SVG.Color.isColor(v))
        v = new SVG.Color(v)

      // parse array values
      else if (Array.isArray(v))
        v = new SVG.Array(v)

      // if the passed attribute is leading...
      if (a == 'leading') {
        // ... call the leading method instead
        if (this.leading)
          this.leading(v)
      } else {
        // set given attribute on node
        typeof n === 'string' ?
          this.node.setAttributeNS(n, a, v.toString()) :
          this.node.setAttribute(a, v.toString())
      }

      // rebuild if required
      if (this.rebuild && (a == 'font-size' || a == 'x'))
        this.rebuild(a, v)
    }

    return this
  }
})
SVG.extend(SVG.Element, {
  // Add transformations
  transform: function(o, relative) {
    // get target in case of the fx module, otherwise reference this
    var target = this
      , matrix, bbox

    // act as a getter
    if (typeof o !== 'object') {
      // get current matrix
      matrix = new SVG.Matrix(target).extract()

      return typeof o === 'string' ? matrix[o] : matrix
    }

    // get current matrix
    matrix = new SVG.Matrix(target)

    // ensure relative flag
    relative = !!relative || !!o.relative

    // act on matrix
    if (o.a != null) {
      matrix = relative ?
        // relative
        matrix.multiply(new SVG.Matrix(o)) :
        // absolute
        new SVG.Matrix(o)

    // act on rotation
    } else if (o.rotation != null) {
      // ensure centre point
      ensureCentre(o, target)

      // apply transformation
      matrix = relative ?
        // relative
        matrix.rotate(o.rotation, o.cx, o.cy) :
        // absolute
        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)

    // act on scale
    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {
      // ensure centre point
      ensureCentre(o, target)

      // ensure scale values on both axes
      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1
      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1

      if (!relative) {
        // absolute; multiply inversed values
        var e = matrix.extract()
        o.scaleX = o.scaleX * 1 / e.scaleX
        o.scaleY = o.scaleY * 1 / e.scaleY
      }

      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)

    // act on skew
    } else if (o.skew != null || o.skewX != null || o.skewY != null) {
      // ensure centre point
      ensureCentre(o, target)

      // ensure skew values on both axes
      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0
      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0

      if (!relative) {
        // absolute; reset skew values
        var e = matrix.extract()
        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())
      }

      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)

    // act on flip
    } else if (o.flip) {
      if(o.flip == 'x' || o.flip == 'y') {
        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset
      } else {
        if(o.offset == null) {
          bbox = target.bbox()
          o.flip = bbox.cx
          o.offset = bbox.cy
        } else {
          o.flip = o.offset
        }
      }

      matrix = new SVG.Matrix().flip(o.flip, o.offset)

    // act on translate
    } else if (o.x != null || o.y != null) {
      if (relative) {
        // relative
        matrix = matrix.translate(o.x, o.y)
      } else {
        // absolute
        if (o.x != null) matrix.e = o.x
        if (o.y != null) matrix.f = o.y
      }
    }

    return this.attr('transform', matrix)
  }
})

SVG.extend(SVG.FX, {
  transform: function(o, relative) {
    // get target in case of the fx module, otherwise reference this
    var target = this.target()
      , matrix, bbox

    // act as a getter
    if (typeof o !== 'object') {
      // get current matrix
      matrix = new SVG.Matrix(target).extract()

      return typeof o === 'string' ? matrix[o] : matrix
    }

    // ensure relative flag
    relative = !!relative || !!o.relative

    // act on matrix
    if (o.a != null) {
      matrix = new SVG.Matrix(o)

    // act on rotation
    } else if (o.rotation != null) {
      // ensure centre point
      ensureCentre(o, target)

      // apply transformation
      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)

    // act on scale
    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {
      // ensure centre point
      ensureCentre(o, target)

      // ensure scale values on both axes
      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1
      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1

      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)

    // act on skew
    } else if (o.skewX != null || o.skewY != null) {
      // ensure centre point
      ensureCentre(o, target)

      // ensure skew values on both axes
      o.skewX = o.skewX != null ? o.skewX : 0
      o.skewY = o.skewY != null ? o.skewY : 0

      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)

    // act on flip
    } else if (o.flip) {
      if(o.flip == 'x' || o.flip == 'y') {
        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset
      } else {
        if(o.offset == null) {
          bbox = target.bbox()
          o.flip = bbox.cx
          o.offset = bbox.cy
        } else {
          o.flip = o.offset
        }
      }

      matrix = new SVG.Matrix().flip(o.flip, o.offset)

    // act on translate
    } else if (o.x != null || o.y != null) {
      matrix = new SVG.Translate(o.x, o.y)
    }

    if(!matrix) return this

    matrix.relative = relative

    this.last().transforms.push(matrix)

    return this._callStart()
  }
})

SVG.extend(SVG.Element, {
  // Reset all transformations
  untransform: function() {
    return this.attr('transform', null)
  },
  // merge the whole transformation chain into one matrix and returns it
  matrixify: function() {

    var matrix = (this.attr('transform') || '')
      // split transformations
      .split(SVG.regex.transforms).slice(0,-1).map(function(str){
        // generate key => value pairs
        var kv = str.trim().split('(')
        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function(str){ return parseFloat(str) })]
      })
      // merge every transformation into one matrix
      .reduce(function(matrix, transform){

        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))
        return matrix[transform[0]].apply(matrix, transform[1])

      }, new SVG.Matrix())

    return matrix
  },
  // add an element to another parent without changing the visual representation on the screen
  toParent: function(parent) {
    if(this == parent) return this
    var ctm = this.screenCTM()
    var pCtm = parent.screenCTM().inverse()

    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))

    return this
  },
  // same as above with parent equals root-svg
  toDoc: function() {
    return this.toParent(this.doc())
  }

})

SVG.Transformation = SVG.invent({

  create: function(source, inversed){

    if(arguments.length > 1 && typeof inversed != 'boolean'){
      return this.constructor.call(this, [].slice.call(arguments))
    }

    if(Array.isArray(source)){
      for(var i = 0, len = this.arguments.length; i < len; ++i){
        this[this.arguments[i]] = source[i]
      }
    } else if(typeof source == 'object'){
      for(var i = 0, len = this.arguments.length; i < len; ++i){
        this[this.arguments[i]] = source[this.arguments[i]]
      }
    }

    this.inversed = false

    if(inversed === true){
      this.inversed = true
    }

  }

, extend: {

    arguments: []
  , method: ''

  , at: function(pos){

      var params = []

      for(var i = 0, len = this.arguments.length; i < len; ++i){
        params.push(this[this.arguments[i]])
      }

      var m = this._undo || new SVG.Matrix()

      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)

      return this.inversed ? m.inverse() : m

    }

  , undo: function(o){
      for(var i = 0, len = this.arguments.length; i < len; ++i){
        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]
      }

      // The method SVG.Matrix.extract which was used before calling this
      // method to obtain a value for the parameter o doesn't return a cx and
      // a cy so we use the ones that were provided to this object at its creation
      o.cx = this.cx
      o.cy = this.cy

      this._undo = new SVG[capitalize(this.method)](o, true).at(1)

      return this
    }

  }

})

SVG.Translate = SVG.invent({

  parent: SVG.Matrix
, inherit: SVG.Transformation

, create: function(source, inversed){
    this.constructor.apply(this, [].slice.call(arguments))
  }

, extend: {
    arguments: ['transformedX', 'transformedY']
  , method: 'translate'
  }

})

SVG.Rotate = SVG.invent({

  parent: SVG.Matrix
, inherit: SVG.Transformation

, create: function(source, inversed){
    this.constructor.apply(this, [].slice.call(arguments))
  }

, extend: {
    arguments: ['rotation', 'cx', 'cy']
  , method: 'rotate'
  , at: function(pos){
      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)
      return this.inversed ? m.inverse() : m
    }
  , undo: function(o){
      this._undo = o
      return this
    }
  }

})

SVG.Scale = SVG.invent({

  parent: SVG.Matrix
, inherit: SVG.Transformation

, create: function(source, inversed){
    this.constructor.apply(this, [].slice.call(arguments))
  }

, extend: {
    arguments: ['scaleX', 'scaleY', 'cx', 'cy']
  , method: 'scale'
  }

})

SVG.Skew = SVG.invent({

  parent: SVG.Matrix
, inherit: SVG.Transformation

, create: function(source, inversed){
    this.constructor.apply(this, [].slice.call(arguments))
  }

, extend: {
    arguments: ['skewX', 'skewY', 'cx', 'cy']
  , method: 'skew'
  }

})

SVG.extend(SVG.Element, {
  // Dynamic style generator
  style: function(s, v) {
    if (arguments.length == 0) {
      // get full style
      return this.node.style.cssText || ''

    } else if (arguments.length < 2) {
      // apply every style individually if an object is passed
      if (typeof s == 'object') {
        for (v in s) this.style(v, s[v])

      } else if (SVG.regex.isCss.test(s)) {
        // parse css string
        s = s.split(/\s*;\s*/)
          // filter out suffix ; and stuff like ;;
          .filter(function(e) { return !!e })
          .map(function(e){ return e.split(/\s*:\s*/) })

        // apply every definition individually
        while (v = s.pop()) {
          this.style(v[0], v[1])
        }
      } else {
        // act as a getter if the first and only argument is not an object
        return this.node.style[camelCase(s)]
      }

    } else {
      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v
    }

    return this
  }
})
SVG.Parent = SVG.invent({
  // Initialize node
  create: function(element) {
    this.constructor.call(this, element)
  }

  // Inherit from
, inherit: SVG.Element

  // Add class methods
, extend: {
    // Returns all child elements
    children: function() {
      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {
        return SVG.adopt(node)
      })
    }
    // Add given element at a position
  , add: function(element, i) {
      if (i == null)
        this.node.appendChild(element.node)
      else if (element.node != this.node.childNodes[i])
        this.node.insertBefore(element.node, this.node.childNodes[i])

      return this
    }
    // Basically does the same as `add()` but returns the added element instead
  , put: function(element, i) {
      this.add(element, i)
      return element
    }
    // Checks if the given element is a child
  , has: function(element) {
      return this.index(element) >= 0
    }
    // Gets index of given element
  , index: function(element) {
      return [].slice.call(this.node.childNodes).indexOf(element.node)
    }
    // Get a element at the given index
  , get: function(i) {
      return SVG.adopt(this.node.childNodes[i])
    }
    // Get first child
  , first: function() {
      return this.get(0)
    }
    // Get the last child
  , last: function() {
      return this.get(this.node.childNodes.length - 1)
    }
    // Iterates over all children and invokes a given block
  , each: function(block, deep) {
      var i, il
        , children = this.children()

      for (i = 0, il = children.length; i < il; i++) {
        if (children[i] instanceof SVG.Element)
          block.apply(children[i], [i, children])

        if (deep && (children[i] instanceof SVG.Container))
          children[i].each(block, deep)
      }

      return this
    }
    // Remove a given child
  , removeElement: function(element) {
      this.node.removeChild(element.node)

      return this
    }
    // Remove all elements in this container
  , clear: function() {
      // remove children
      while(this.node.hasChildNodes())
        this.node.removeChild(this.node.lastChild)

      // remove defs reference
      delete this._defs

      return this
    }
  , // Get defs
    defs: function() {
      return this.doc().defs()
    }
  }

})

SVG.extend(SVG.Parent, {

  ungroup: function(parent, depth) {
    if(depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this

    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))
    depth = depth || Infinity

    this.each(function(){
      if(this instanceof SVG.Defs) return this
      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)
      return this.toParent(parent)
    })

    this.node.firstChild || this.remove()

    return this
  },

  flatten: function(parent, depth) {
    return this.ungroup(parent, depth)
  }

})
SVG.Container = SVG.invent({
  // Initialize node
  create: function(element) {
    this.constructor.call(this, element)
  }

  // Inherit from
, inherit: SVG.Parent

})

SVG.ViewBox = SVG.invent({

  create: function(source) {
    var i, base = [0, 0, 0, 0]

    var x, y, width, height, box, view, we, he
      , wm   = 1 // width multiplier
      , hm   = 1 // height multiplier
      , reg  = /[+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?/gi

    if(source instanceof SVG.Element){

      we = source
      he = source
      view = (source.attr('viewBox') || '').match(reg)
      box = source.bbox

      // get dimensions of current node
      width  = new SVG.Number(source.width())
      height = new SVG.Number(source.height())

      // find nearest non-percentual dimensions
      while (width.unit == '%') {
        wm *= width.value
        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())
        we = we.parent()
      }
      while (height.unit == '%') {
        hm *= height.value
        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())
        he = he.parent()
      }

      // ensure defaults
      this.x      = 0
      this.y      = 0
      this.width  = width  * wm
      this.height = height * hm
      this.zoom   = 1

      if (view) {
        // get width and height from viewbox
        x      = parseFloat(view[0])
        y      = parseFloat(view[1])
        width  = parseFloat(view[2])
        height = parseFloat(view[3])

        // calculate zoom accoring to viewbox
        this.zoom = ((this.width / this.height) > (width / height)) ?
          this.height / height :
          this.width  / width

        // calculate real pixel dimensions on parent SVG.Doc element
        this.x      = x
        this.y      = y
        this.width  = width
        this.height = height

      }

    }else{

      // ensure source as object
      source = typeof source === 'string' ?
        source.match(reg).map(function(el){ return parseFloat(el) }) :
      Array.isArray(source) ?
        source :
      typeof source == 'object' ?
        [source.x, source.y, source.width, source.height] :
      arguments.length == 4 ?
        [].slice.call(arguments) :
        base

      this.x = source[0]
      this.y = source[1]
      this.width = source[2]
      this.height = source[3]
    }


  }

, extend: {

    toString: function() {
      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height
    }
  , morph: function(x, y, width, height){
      this.destination = new SVG.ViewBox(x, y, width, height)
      return this
    }

  , at: function(pos) {

      if(!this.destination) return this

      return new SVG.ViewBox([
          this.x + (this.destination.x - this.x) * pos
        , this.y + (this.destination.y - this.y) * pos
        , this.width + (this.destination.width - this.width) * pos
        , this.height + (this.destination.height - this.height) * pos
      ])

    }

  }

  // Define parent
, parent: SVG.Container

  // Add parent method
, construct: {

    // get/set viewbox
    viewbox: function(x, y, width, height) {
      if (arguments.length == 0)
        // act as a getter if there are no arguments
        return new SVG.ViewBox(this)

      // otherwise act as a setter
      return this.attr('viewBox', new SVG.ViewBox(x, y, width, height))
    }

  }

})
// Add events to elements

;[ 'click',
  'dblclick',
  'mousedown',
  'mouseup',
  'mouseover',
  'mouseout',
  'mousemove',
  'mouseenter',
  'mouseleave',
  'touchstart',
  'touchmove',
  'touchleave',
  'touchend',
  'touchcancel' ].forEach(function (event) {
    // add event to SVG.Element
    SVG.Element.prototype[event] = function (f) {
      // bind event to element rather than element node
      if (f == null) {
        SVG.off(this, event)
      } else {
        SVG.on(this, event, f)
      }
      return this
    }
  })

SVG.listenerId = 0

// Add event binder in the SVG namespace
SVG.on = function (node, events, listener, binding, options) {
  var l = listener.bind(binding || node)
  var n = node instanceof SVG.Element ? node.node : node

  // ensure instance object for nodes which are not adopted
  n.instance = n.instance || {_events: {}}

  var bag = n.instance._events

  // add id to listener
  if (!listener._svgjsListenerId) { listener._svgjsListenerId = ++SVG.listenerId }

  events.split(SVG.regex.delimiter).forEach(function (event) {
    var ev = event.split('.')[0]
    var ns = event.split('.')[1] || '*'

    // ensure valid object
    bag[ev] = bag[ev] || {}
    bag[ev][ns] = bag[ev][ns] || {}

    // reference listener
    bag[ev][ns][listener._svgjsListenerId] = l

    // add listener
    n.addEventListener(ev, l, options || false)
  })
}

// Add event unbinder in the SVG namespace
SVG.off = function (node, events, listener, options) {
  var n = node instanceof SVG.Element ? node.node : node
  if (!n.instance) return

  // listener can be a function or a number
  if (typeof listener === 'function') {
    listener = listener._svgjsListenerId
    if (!listener) return
  }

  var bag = n.instance._events

  ;(events || '').split(SVG.regex.delimiter).forEach(function (event) {
    var ev = event && event.split('.')[0]
    var ns = event && event.split('.')[1]
    var namespace, l

    if (listener) {
      // remove listener reference
      if (bag[ev] && bag[ev][ns || '*']) {
        // removeListener
        n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false)

        delete bag[ev][ns || '*'][listener]
      }
    } else if (ev && ns) {
      // remove all listeners for a namespaced event
      if (bag[ev] && bag[ev][ns]) {
        for (l in bag[ev][ns]) { SVG.off(n, [ev, ns].join('.'), l) }

        delete bag[ev][ns]
      }
    } else if (ns) {
      // remove all listeners for a specific namespace
      for (event in bag) {
        for (namespace in bag[event]) {
          if (ns === namespace) { SVG.off(n, [event, ns].join('.')) }
        }
      }
    } else if (ev) {
      // remove all listeners for the event
      if (bag[ev]) {
        for (namespace in bag[ev]) { SVG.off(n, [ev, namespace].join('.')) }

        delete bag[ev]
      }
    } else {
      // remove all listeners on a given node
      for (event in bag) { SVG.off(n, event) }

      n.instance._events = {}
    }
  })
}

SVG.extend(SVG.Element, {
  // Bind given event to listener
  on: function (event, listener, binding, options) {
    SVG.on(this, event, listener, binding, options)
    return this
  },
  // Unbind event from listener
  off: function (event, listener) {
    SVG.off(this.node, event, listener)
    return this
  },
  fire: function (event, data) {
    // Dispatch event
    if (event instanceof window.Event) {
      this.node.dispatchEvent(event)
    } else {
      this.node.dispatchEvent(event = new SVG.CustomEvent(event, {detail: data, cancelable: true}))
    }
    this._event = event
    return this
  },
  event: function() {
    return this._event
  }
})


SVG.Defs = SVG.invent({
  // Initialize node
  create: 'defs'

  // Inherit from
, inherit: SVG.Container

})
SVG.G = SVG.invent({
  // Initialize node
  create: 'g'

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Move over x-axis
    x: function(x) {
      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)
    }
    // Move over y-axis
  , y: function(y) {
      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)
    }
    // Move by center over x-axis
  , cx: function(x) {
      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)
    }
    // Move by center over y-axis
  , cy: function(y) {
      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)
    }
  , gbox: function() {

      var bbox  = this.bbox()
        , trans = this.transform()

      bbox.x  += trans.x
      bbox.x2 += trans.x
      bbox.cx += trans.x

      bbox.y  += trans.y
      bbox.y2 += trans.y
      bbox.cy += trans.y

      return bbox
    }
  }

  // Add parent method
, construct: {
    // Create a group element
    group: function() {
      return this.put(new SVG.G)
    }
  }
})

SVG.Doc = SVG.invent({
  // Initialize node
  create: function(element) {
    if (element) {
      // ensure the presence of a dom element
      element = typeof element == 'string' ?
        document.getElementById(element) :
        element

      // If the target is an svg element, use that element as the main wrapper.
      // This allows svg.js to work with svg documents as well.
      if (element.nodeName == 'svg') {
        this.constructor.call(this, element)
      } else {
        this.constructor.call(this, SVG.create('svg'))
        element.appendChild(this.node)
        this.size('100%', '100%')
      }

      // set svg element attributes and ensure defs node
      this.namespace().defs()
    }
  }

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Add namespaces
    namespace: function() {
      return this
        .attr({ xmlns: SVG.ns, version: '1.1' })
        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)
        .attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns)
    }
    // Creates and returns defs element
  , defs: function() {
      if (!this._defs) {
        var defs

        // Find or create a defs element in this instance
        if (defs = this.node.getElementsByTagName('defs')[0])
          this._defs = SVG.adopt(defs)
        else
          this._defs = new SVG.Defs

        // Make sure the defs node is at the end of the stack
        this.node.appendChild(this._defs.node)
      }

      return this._defs
    }
    // custom parent method
  , parent: function() {
      if(!this.node.parentNode || this.node.parentNode.nodeName == '#document' || this.node.parentNode.nodeName == '#document-fragment') return null
      return this.node.parentNode
    }
    // Fix for possible sub-pixel offset. See:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=608812
  , spof: function() {
      var pos = this.node.getScreenCTM()

      if (pos)
        this
          .style('left', (-pos.e % 1) + 'px')
          .style('top',  (-pos.f % 1) + 'px')

      return this
    }

      // Removes the doc from the DOM
  , remove: function() {
      if(this.parent()) {
        this.parent().removeChild(this.node)
      }

      return this
    }
  , clear: function() {
      // remove children
      while(this.node.hasChildNodes())
        this.node.removeChild(this.node.lastChild)

      // remove defs reference
      delete this._defs

      // add back parser
      if(!SVG.parser.draw.parentNode)
        this.node.appendChild(SVG.parser.draw)

      return this
    }
  , clone: function (parent) {
      // write dom data to the dom so the clone can pickup the data
      this.writeDataToDom()

      // get reference to node
      var node = this.node

      // clone element and assign new id
      var clone = assignNewId(node.cloneNode(true))

      // insert the clone in the given parent or after myself
      if(parent) {
        (parent.node || parent).appendChild(clone.node)
      } else {
        node.parentNode.insertBefore(clone.node, node.nextSibling)
      }

      return clone
    }
  }

})

// ### This module adds backward / forward functionality to elements.

//
SVG.extend(SVG.Element, {
  // Get all siblings, including myself
  siblings: function() {
    return this.parent().children()
  }
  // Get the curent position siblings
, position: function() {
    return this.parent().index(this)
  }
  // Get the next element (will return null if there is none)
, next: function() {
    return this.siblings()[this.position() + 1]
  }
  // Get the next element (will return null if there is none)
, previous: function() {
    return this.siblings()[this.position() - 1]
  }
  // Send given element one step forward
, forward: function() {
    var i = this.position() + 1
      , p = this.parent()

    // move node one step forward
    p.removeElement(this).add(this, i)

    // make sure defs node is always at the top
    if (p instanceof SVG.Doc)
      p.node.appendChild(p.defs().node)

    return this
  }
  // Send given element one step backward
, backward: function() {
    var i = this.position()

    if (i > 0)
      this.parent().removeElement(this).add(this, i - 1)

    return this
  }
  // Send given element all the way to the front
, front: function() {
    var p = this.parent()

    // Move node forward
    p.node.appendChild(this.node)

    // Make sure defs node is always at the top
    if (p instanceof SVG.Doc)
      p.node.appendChild(p.defs().node)

    return this
  }
  // Send given element all the way to the back
, back: function() {
    if (this.position() > 0)
      this.parent().removeElement(this).add(this, 0)

    return this
  }
  // Inserts a given element before the targeted element
, before: function(element) {
    element.remove()

    var i = this.position()

    this.parent().add(element, i)

    return this
  }
  // Insters a given element after the targeted element
, after: function(element) {
    element.remove()

    var i = this.position()

    this.parent().add(element, i + 1)

    return this
  }

})
SVG.Mask = SVG.invent({
  // Initialize node
  create: function() {
    this.constructor.call(this, SVG.create('mask'))

    // keep references to masked elements
    this.targets = []
  }

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Unmask all masked elements and remove itself
    remove: function() {
      // unmask all targets
      for (var i = this.targets.length - 1; i >= 0; i--)
        if (this.targets[i])
          this.targets[i].unmask()
      this.targets = []

      // remove mask from parent
      SVG.Element.prototype.remove.call(this)

      return this
    }
  }

  // Add parent method
, construct: {
    // Create masking element
    mask: function() {
      return this.defs().put(new SVG.Mask)
    }
  }
})


SVG.extend(SVG.Element, {
  // Distribute mask to svg element
  maskWith: function(element) {
    // use given mask or create a new one
    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)

    // store reverence on self in mask
    this.masker.targets.push(this)

    // apply mask
    return this.attr('mask', 'url("#' + this.masker.attr('id') + '")')
  }
  // Unmask element
, unmask: function() {
    delete this.masker
    return this.attr('mask', null)
  }

})

SVG.ClipPath = SVG.invent({
  // Initialize node
  create: function() {
    this.constructor.call(this, SVG.create('clipPath'))

    // keep references to clipped elements
    this.targets = []
  }

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Unclip all clipped elements and remove itself
    remove: function() {
      // unclip all targets
      for (var i = this.targets.length - 1; i >= 0; i--)
        if (this.targets[i])
          this.targets[i].unclip()
      this.targets = []

      // remove clipPath from parent
      this.parent().removeElement(this)

      return this
    }
  }

  // Add parent method
, construct: {
    // Create clipping element
    clip: function() {
      return this.defs().put(new SVG.ClipPath)
    }
  }
})

//
SVG.extend(SVG.Element, {
  // Distribute clipPath to svg element
  clipWith: function(element) {
    // use given clip or create a new one
    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)

    // store reverence on self in mask
    this.clipper.targets.push(this)

    // apply mask
    return this.attr('clip-path', 'url("#' + this.clipper.attr('id') + '")')
  }
  // Unclip element
, unclip: function() {
    delete this.clipper
    return this.attr('clip-path', null)
  }

})
SVG.Gradient = SVG.invent({
  // Initialize node
  create: function(type) {
    this.constructor.call(this, SVG.create(type + 'Gradient'))

    // store type
    this.type = type
  }

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Add a color stop
    at: function(offset, color, opacity) {
      return this.put(new SVG.Stop).update(offset, color, opacity)
    }
    // Update gradient
  , update: function(block) {
      // remove all stops
      this.clear()

      // invoke passed block
      if (typeof block == 'function')
        block.call(this, this)

      return this
    }
    // Return the fill id
  , fill: function() {
      return 'url(#' + this.id() + ')'
    }
    // Alias string convertion to fill
  , toString: function() {
      return this.fill()
    }
    // custom attr to handle transform
  , attr: function(a, b, c) {
      if(a == 'transform') a = 'gradientTransform'
      return SVG.Container.prototype.attr.call(this, a, b, c)
    }
  }

  // Add parent method
, construct: {
    // Create gradient element in defs
    gradient: function(type, block) {
      return this.defs().gradient(type, block)
    }
  }
})

// Add animatable methods to both gradient and fx module
SVG.extend(SVG.Gradient, SVG.FX, {
  // From position
  from: function(x, y) {
    return (this._target || this).type == 'radial' ?
      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :
      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })
  }
  // To position
, to: function(x, y) {
    return (this._target || this).type == 'radial' ?
      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :
      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })
  }
})

// Base gradient generation
SVG.extend(SVG.Defs, {
  // define gradient
  gradient: function(type, block) {
    return this.put(new SVG.Gradient(type)).update(block)
  }

})

SVG.Stop = SVG.invent({
  // Initialize node
  create: 'stop'

  // Inherit from
, inherit: SVG.Element

  // Add class methods
, extend: {
    // add color stops
    update: function(o) {
      if (typeof o == 'number' || o instanceof SVG.Number) {
        o = {
          offset:  arguments[0]
        , color:   arguments[1]
        , opacity: arguments[2]
        }
      }

      // set attributes
      if (o.opacity != null) this.attr('stop-opacity', o.opacity)
      if (o.color   != null) this.attr('stop-color', o.color)
      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))

      return this
    }
  }

})

SVG.Pattern = SVG.invent({
  // Initialize node
  create: 'pattern'

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Return the fill id
    fill: function() {
      return 'url(#' + this.id() + ')'
    }
    // Update pattern by rebuilding
  , update: function(block) {
      // remove content
      this.clear()

      // invoke passed block
      if (typeof block == 'function')
        block.call(this, this)

      return this
    }
    // Alias string convertion to fill
  , toString: function() {
      return this.fill()
    }
    // custom attr to handle transform
  , attr: function(a, b, c) {
      if(a == 'transform') a = 'patternTransform'
      return SVG.Container.prototype.attr.call(this, a, b, c)
    }

  }

  // Add parent method
, construct: {
    // Create pattern element in defs
    pattern: function(width, height, block) {
      return this.defs().pattern(width, height, block)
    }
  }
})

SVG.extend(SVG.Defs, {
  // Define gradient
  pattern: function(width, height, block) {
    return this.put(new SVG.Pattern).update(block).attr({
      x:            0
    , y:            0
    , width:        width
    , height:       height
    , patternUnits: 'userSpaceOnUse'
    })
  }

})
SVG.Shape = SVG.invent({
  // Initialize node
  create: function(element) {
    this.constructor.call(this, element)
  }

  // Inherit from
, inherit: SVG.Element

})

SVG.Bare = SVG.invent({
  // Initialize
  create: function(element, inherit) {
    // construct element
    this.constructor.call(this, SVG.create(element))

    // inherit custom methods
    if (inherit)
      for (var method in inherit.prototype)
        if (typeof inherit.prototype[method] === 'function')
          this[method] = inherit.prototype[method]
  }

  // Inherit from
, inherit: SVG.Element

  // Add methods
, extend: {
    // Insert some plain text
    words: function(text) {
      // remove contents
      while (this.node.hasChildNodes())
        this.node.removeChild(this.node.lastChild)

      // create text node
      this.node.appendChild(document.createTextNode(text))

      return this
    }
  }
})


SVG.extend(SVG.Parent, {
  // Create an element that is not described by SVG.js
  element: function(element, inherit) {
    return this.put(new SVG.Bare(element, inherit))
  }
})

SVG.Symbol = SVG.invent({
  // Initialize node
  create: 'symbol'

  // Inherit from
, inherit: SVG.Container

, construct: {
    // create symbol
    symbol: function() {
      return this.put(new SVG.Symbol)
    }
  }
})

SVG.Use = SVG.invent({
  // Initialize node
  create: 'use'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Use element as a reference
    element: function(element, file) {
      // Set lined element
      return this.attr('href', (file || '') + '#' + element, SVG.xlink)
    }
  }

  // Add parent method
, construct: {
    // Create a use element
    use: function(element, file) {
      return this.put(new SVG.Use).element(element, file)
    }
  }
})
SVG.Rect = SVG.invent({
  // Initialize node
  create: 'rect'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create a rect element
    rect: function(width, height) {
      return this.put(new SVG.Rect()).size(width, height)
    }
  }
})
SVG.Circle = SVG.invent({
  // Initialize node
  create: 'circle'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create circle element, based on ellipse
    circle: function(size) {
      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)
    }
  }
})

SVG.extend(SVG.Circle, SVG.FX, {
  // Radius x value
  rx: function(rx) {
    return this.attr('r', rx)
  }
  // Alias radius x value
, ry: function(ry) {
    return this.rx(ry)
  }
})

SVG.Ellipse = SVG.invent({
  // Initialize node
  create: 'ellipse'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create an ellipse
    ellipse: function(width, height) {
      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)
    }
  }
})

SVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {
  // Radius x value
  rx: function(rx) {
    return this.attr('rx', rx)
  }
  // Radius y value
, ry: function(ry) {
    return this.attr('ry', ry)
  }
})

// Add common method
SVG.extend(SVG.Circle, SVG.Ellipse, {
    // Move over x-axis
    x: function(x) {
      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())
    }
    // Move over y-axis
  , y: function(y) {
      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())
    }
    // Move by center over x-axis
  , cx: function(x) {
      return x == null ? this.attr('cx') : this.attr('cx', x)
    }
    // Move by center over y-axis
  , cy: function(y) {
      return y == null ? this.attr('cy') : this.attr('cy', y)
    }
    // Set width of element
  , width: function(width) {
      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))
    }
    // Set height of element
  , height: function(height) {
      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))
    }
    // Custom size function
  , size: function(width, height) {
      var p = proportionalSize(this, width, height)

      return this
        .rx(new SVG.Number(p.width).divide(2))
        .ry(new SVG.Number(p.height).divide(2))
    }
})
SVG.Line = SVG.invent({
  // Initialize node
  create: 'line'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Get array
    array: function() {
      return new SVG.PointArray([
        [ this.attr('x1'), this.attr('y1') ]
      , [ this.attr('x2'), this.attr('y2') ]
      ])
    }
    // Overwrite native plot() method
  , plot: function(x1, y1, x2, y2) {
      if (x1 == null)
        return this.array()
      else if (typeof y1 !== 'undefined')
        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }
      else
        x1 = new SVG.PointArray(x1).toLine()

      return this.attr(x1)
    }
    // Move by left top corner
  , move: function(x, y) {
      return this.attr(this.array().move(x, y).toLine())
    }
    // Set element size to given width and height
  , size: function(width, height) {
      var p = proportionalSize(this, width, height)

      return this.attr(this.array().size(p.width, p.height).toLine())
    }
  }

  // Add parent method
, construct: {
    // Create a line element
    line: function(x1, y1, x2, y2) {
      // make sure plot is called as a setter
      // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray
      return SVG.Line.prototype.plot.apply(
        this.put(new SVG.Line)
      , x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]
      )
    }
  }
})

SVG.Polyline = SVG.invent({
  // Initialize node
  create: 'polyline'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create a wrapped polyline element
    polyline: function(p) {
      // make sure plot is called as a setter
      return this.put(new SVG.Polyline).plot(p || new SVG.PointArray)
    }
  }
})

SVG.Polygon = SVG.invent({
  // Initialize node
  create: 'polygon'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create a wrapped polygon element
    polygon: function(p) {
      // make sure plot is called as a setter
      return this.put(new SVG.Polygon).plot(p || new SVG.PointArray)
    }
  }
})

// Add polygon-specific functions
SVG.extend(SVG.Polyline, SVG.Polygon, {
  // Get array
  array: function() {
    return this._array || (this._array = new SVG.PointArray(this.attr('points')))
  }
  // Plot new path
, plot: function(p) {
    return (p == null) ?
      this.array() :
      this.clear().attr('points', typeof p == 'string' ? p : (this._array = new SVG.PointArray(p)))
  }
  // Clear array cache
, clear: function() {
    delete this._array
    return this
  }
  // Move by left top corner
, move: function(x, y) {
    return this.attr('points', this.array().move(x, y))
  }
  // Set element size to given width and height
, size: function(width, height) {
    var p = proportionalSize(this, width, height)

    return this.attr('points', this.array().size(p.width, p.height))
  }

})

// unify all point to point elements
SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {
  // Define morphable array
  morphArray:  SVG.PointArray
  // Move by left top corner over x-axis
, x: function(x) {
    return x == null ? this.bbox().x : this.move(x, this.bbox().y)
  }
  // Move by left top corner over y-axis
, y: function(y) {
    return y == null ? this.bbox().y : this.move(this.bbox().x, y)
  }
  // Set width of element
, width: function(width) {
    var b = this.bbox()

    return width == null ? b.width : this.size(width, b.height)
  }
  // Set height of element
, height: function(height) {
    var b = this.bbox()

    return height == null ? b.height : this.size(b.width, height)
  }
})
SVG.Path = SVG.invent({
  // Initialize node
  create: 'path'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Define morphable array
    morphArray:  SVG.PathArray
    // Get array
  , array: function() {
      return this._array || (this._array = new SVG.PathArray(this.attr('d')))
    }
    // Plot new path
  , plot: function(d) {
      return (d == null) ?
        this.array() :
        this.clear().attr('d', typeof d == 'string' ? d : (this._array = new SVG.PathArray(d)))
    }
    // Clear array cache
  , clear: function() {
      delete this._array
      return this
    }
    // Move by left top corner
  , move: function(x, y) {
      return this.attr('d', this.array().move(x, y))
    }
    // Move by left top corner over x-axis
  , x: function(x) {
      return x == null ? this.bbox().x : this.move(x, this.bbox().y)
    }
    // Move by left top corner over y-axis
  , y: function(y) {
      return y == null ? this.bbox().y : this.move(this.bbox().x, y)
    }
    // Set element size to given width and height
  , size: function(width, height) {
      var p = proportionalSize(this, width, height)

      return this.attr('d', this.array().size(p.width, p.height))
    }
    // Set width of element
  , width: function(width) {
      return width == null ? this.bbox().width : this.size(width, this.bbox().height)
    }
    // Set height of element
  , height: function(height) {
      return height == null ? this.bbox().height : this.size(this.bbox().width, height)
    }

  }

  // Add parent method
, construct: {
    // Create a wrapped path element
    path: function(d) {
      // make sure plot is called as a setter
      return this.put(new SVG.Path).plot(d || new SVG.PathArray)
    }
  }
})

SVG.Image = SVG.invent({
  // Initialize node
  create: 'image'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // (re)load image
    load: function(url) {
      if (!url) return this

      var self = this
        , img  = new window.Image()

      // preload image
      SVG.on(img, 'load', function() {
        SVG.off(img)

        var p = self.parent(SVG.Pattern)

        if(p === null) return

        // ensure image size
        if (self.width() == 0 && self.height() == 0)
          self.size(img.width, img.height)

        // ensure pattern size if not set
        if (p && p.width() == 0 && p.height() == 0)
          p.size(self.width(), self.height())

        // callback
        if (typeof self._loaded === 'function')
          self._loaded.call(self, {
            width:  img.width
          , height: img.height
          , ratio:  img.width / img.height
          , url:    url
          })
      })

      SVG.on(img, 'error', function(e){
        SVG.off(img)

        if (typeof self._error === 'function'){
            self._error.call(self, e)
        }
      })

      return this.attr('href', (img.src = this.src = url), SVG.xlink)
    }
    // Add loaded callback
  , loaded: function(loaded) {
      this._loaded = loaded
      return this
    }

  , error: function(error) {
      this._error = error
      return this
    }
  }

  // Add parent method
, construct: {
    // create image element, load image and set its size
    image: function(source, width, height) {
      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)
    }
  }

})
SVG.Text = SVG.invent({
  // Initialize node
  create: function() {
    this.constructor.call(this, SVG.create('text'))

    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding
    this._rebuild = true                      // enable automatic updating of dy values
    this._build   = false                     // disable build mode for adding multiple lines

    // set default font
    this.attr('font-family', SVG.defaults.attrs['font-family'])
  }

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Move over x-axis
    x: function(x) {
      // act as getter
      if (x == null)
        return this.attr('x')

      return this.attr('x', x)
    }
    // Move over y-axis
  , y: function(y) {
      var oy = this.attr('y')
        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0

      // act as getter
      if (y == null)
        return typeof oy === 'number' ? oy - o : oy

      return this.attr('y', typeof y.valueOf() === 'number' ? y + o : y)
    }
    // Move center over x-axis
  , cx: function(x) {
      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)
    }
    // Move center over y-axis
  , cy: function(y) {
      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)
    }
    // Set the text content
  , text: function(text) {
      // act as getter
      if (typeof text === 'undefined'){
        var text = ''
        var children = this.node.childNodes
        for(var i = 0, len = children.length; i < len; ++i){

          // add newline if its not the first child and newLined is set to true
          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){
            text += '\n'
          }

          // add content of this node
          text += children[i].textContent
        }

        return text
      }

      // remove existing content
      this.clear().build(true)

      if (typeof text === 'function') {
        // call block
        text.call(this, this)

      } else {
        // store text and make sure text is not blank
        text = text.split('\n')

        // build new lines
        for (var i = 0, il = text.length; i < il; i++)
          this.tspan(text[i]).newLine()
      }

      // disable build mode and rebuild lines
      return this.build(false).rebuild()
    }
    // Set font size
  , size: function(size) {
      return this.attr('font-size', size).rebuild()
    }
    // Set / get leading
  , leading: function(value) {
      // act as getter
      if (value == null)
        return this.dom.leading

      // act as setter
      this.dom.leading = new SVG.Number(value)

      return this.rebuild()
    }
    // Get all the first level lines
  , lines: function() {
      var node = (this.textPath && this.textPath() || this).node

      // filter tspans and map them to SVG.js instances
      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){
        return SVG.adopt(el)
      })

      // return an instance of SVG.set
      return new SVG.Set(lines)
    }
    // Rebuild appearance type
  , rebuild: function(rebuild) {
      // store new rebuild flag if given
      if (typeof rebuild == 'boolean')
        this._rebuild = rebuild

      // define position of all lines
      if (this._rebuild) {
        var self = this
          , blankLineOffset = 0
          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))

        this.lines().each(function() {
          if (this.dom.newLined) {
            if (!self.textPath())
              this.attr('x', self.attr('x'))
            if(this.text() == '\n') {
              blankLineOffset += dy
            }else{
              this.attr('dy', dy + blankLineOffset)
              blankLineOffset = 0
            }
          }
        })

        this.fire('rebuild')
      }

      return this
    }
    // Enable / disable build mode
  , build: function(build) {
      this._build = !!build
      return this
    }
    // overwrite method from parent to set data properly
  , setData: function(o){
      this.dom = o
      this.dom.leading = new SVG.Number(o.leading || 1.3)
      return this
    }
  }

  // Add parent method
, construct: {
    // Create text element
    text: function(text) {
      return this.put(new SVG.Text).text(text)
    }
    // Create plain text element
  , plain: function(text) {
      return this.put(new SVG.Text).plain(text)
    }
  }

})

SVG.Tspan = SVG.invent({
  // Initialize node
  create: 'tspan'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Set text content
    text: function(text) {
      if(text == null) return this.node.textContent + (this.dom.newLined ? '\n' : '')

      typeof text === 'function' ? text.call(this, this) : this.plain(text)

      return this
    }
    // Shortcut dx
  , dx: function(dx) {
      return this.attr('dx', dx)
    }
    // Shortcut dy
  , dy: function(dy) {
      return this.attr('dy', dy)
    }
    // Create new line
  , newLine: function() {
      // fetch text parent
      var t = this.parent(SVG.Text)

      // mark new line
      this.dom.newLined = true

      // apply new hy¡n
      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())
    }
  }

})

SVG.extend(SVG.Text, SVG.Tspan, {
  // Create plain text node
  plain: function(text) {
    // clear if build mode is disabled
    if (this._build === false)
      this.clear()

    // create text node
    this.node.appendChild(document.createTextNode(text))

    return this
  }
  // Create a tspan
, tspan: function(text) {
    var node  = (this.textPath && this.textPath() || this).node
      , tspan = new SVG.Tspan

    // clear if build mode is disabled
    if (this._build === false)
      this.clear()

    // add new tspan
    node.appendChild(tspan.node)

    return tspan.text(text)
  }
  // Clear all lines
, clear: function() {
    var node = (this.textPath && this.textPath() || this).node

    // remove existing child nodes
    while (node.hasChildNodes())
      node.removeChild(node.lastChild)

    return this
  }
  // Get length of text element
, length: function() {
    return this.node.getComputedTextLength()
  }
})

SVG.TextPath = SVG.invent({
  // Initialize node
  create: 'textPath'

  // Inherit from
, inherit: SVG.Parent

  // Define parent class
, parent: SVG.Text

  // Add parent method
, construct: {
    morphArray: SVG.PathArray
    // Create path for text to run on
  , path: function(d) {
      // create textPath element
      var path  = new SVG.TextPath
        , track = this.doc().defs().path(d)

      // move lines to textpath
      while (this.node.hasChildNodes())
        path.node.appendChild(this.node.firstChild)

      // add textPath element as child node
      this.node.appendChild(path.node)

      // link textPath to path and add content
      path.attr('href', '#' + track, SVG.xlink)

      return this
    }
    // return the array of the path track element
  , array: function() {
      var track = this.track()

      return track ? track.array() : null
    }
    // Plot path if any
  , plot: function(d) {
      var track = this.track()
        , pathArray = null

      if (track) {
        pathArray = track.plot(d)
      }

      return (d == null) ? pathArray : this
    }
    // Get the path track element
  , track: function() {
      var path = this.textPath()

      if (path)
        return path.reference('href')
    }
    // Get the textPath child
  , textPath: function() {
      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')
        return SVG.adopt(this.node.firstChild)
    }
  }
})

SVG.Nested = SVG.invent({
  // Initialize node
  create: function() {
    this.constructor.call(this, SVG.create('svg'))

    this.style('overflow', 'visible')
  }

  // Inherit from
, inherit: SVG.Container

  // Add parent method
, construct: {
    // Create nested svg document
    nested: function() {
      return this.put(new SVG.Nested)
    }
  }
})
SVG.A = SVG.invent({
  // Initialize node
  create: 'a'

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Link url
    to: function(url) {
      return this.attr('href', url, SVG.xlink)
    }
    // Link show attribute
  , show: function(target) {
      return this.attr('show', target, SVG.xlink)
    }
    // Link target attribute
  , target: function(target) {
      return this.attr('target', target)
    }
  }

  // Add parent method
, construct: {
    // Create a hyperlink element
    link: function(url) {
      return this.put(new SVG.A).to(url)
    }
  }
})

SVG.extend(SVG.Element, {
  // Create a hyperlink element
  linkTo: function(url) {
    var link = new SVG.A

    if (typeof url == 'function')
      url.call(link, link)
    else
      link.to(url)

    return this.parent().put(link).put(this)
  }

})
SVG.Marker = SVG.invent({
  // Initialize node
  create: 'marker'

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Set width of element
    width: function(width) {
      return this.attr('markerWidth', width)
    }
    // Set height of element
  , height: function(height) {
      return this.attr('markerHeight', height)
    }
    // Set marker refX and refY
  , ref: function(x, y) {
      return this.attr('refX', x).attr('refY', y)
    }
    // Update marker
  , update: function(block) {
      // remove all content
      this.clear()

      // invoke passed block
      if (typeof block == 'function')
        block.call(this, this)

      return this
    }
    // Return the fill id
  , toString: function() {
      return 'url(#' + this.id() + ')'
    }
  }

  // Add parent method
, construct: {
    marker: function(width, height, block) {
      // Create marker element in defs
      return this.defs().marker(width, height, block)
    }
  }

})

SVG.extend(SVG.Defs, {
  // Create marker
  marker: function(width, height, block) {
    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
    return this.put(new SVG.Marker)
      .size(width, height)
      .ref(width / 2, height / 2)
      .viewbox(0, 0, width, height)
      .attr('orient', 'auto')
      .update(block)
  }

})

SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {
  // Create and attach markers
  marker: function(marker, width, height, block) {
    var attr = ['marker']

    // Build attribute name
    if (marker != 'all') attr.push(marker)
    attr = attr.join('-')

    // Set marker attribute
    marker = arguments[1] instanceof SVG.Marker ?
      arguments[1] :
      this.doc().marker(width, height, block)

    return this.attr(attr, marker)
  }

})
// Define list of available attributes for stroke and fill
var sugar = {
  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']
, fill:   ['color', 'opacity', 'rule']
, prefix: function(t, a) {
    return a == 'color' ? t : t + '-' + a
  }
}

// Add sugar for fill and stroke
;['fill', 'stroke'].forEach(function(m) {
  var i, extension = {}

  extension[m] = function(o) {
    if (typeof o == 'undefined')
      return this
    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))
      this.attr(m, o)

    else
      // set all attributes from sugar.fill and sugar.stroke list
      for (i = sugar[m].length - 1; i >= 0; i--)
        if (o[sugar[m][i]] != null)
          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])

    return this
  }

  SVG.extend(SVG.Element, SVG.FX, extension)

})

SVG.extend(SVG.Element, SVG.FX, {
  // Map rotation to transform
  rotate: function(d, cx, cy) {
    return this.transform({ rotation: d, cx: cx, cy: cy })
  }
  // Map skew to transform
, skew: function(x, y, cx, cy) {
    return arguments.length == 1  || arguments.length == 3 ?
      this.transform({ skew: x, cx: y, cy: cx }) :
      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })
  }
  // Map scale to transform
, scale: function(x, y, cx, cy) {
    return arguments.length == 1  || arguments.length == 3 ?
      this.transform({ scale: x, cx: y, cy: cx }) :
      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })
  }
  // Map translate to transform
, translate: function(x, y) {
    return this.transform({ x: x, y: y })
  }
  // Map flip to transform
, flip: function(a, o) {
    o = typeof a == 'number' ? a : o
    return this.transform({ flip: a || 'both', offset: o })
  }
  // Map matrix to transform
, matrix: function(m) {
    return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m))
  }
  // Opacity
, opacity: function(value) {
    return this.attr('opacity', value)
  }
  // Relative move over x axis
, dx: function(x) {
    return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true)
  }
  // Relative move over y axis
, dy: function(y) {
    return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true)
  }
  // Relative move over x and y axes
, dmove: function(x, y) {
    return this.dx(x).dy(y)
  }
})

SVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {
  // Add x and y radius
  radius: function(x, y) {
    var type = (this._target || this).type;
    return type == 'radial' || type == 'circle' ?
      this.attr('r', new SVG.Number(x)) :
      this.rx(x).ry(y == null ? x : y)
  }
})

SVG.extend(SVG.Path, {
  // Get path length
  length: function() {
    return this.node.getTotalLength()
  }
  // Get point at length
, pointAt: function(length) {
    return this.node.getPointAtLength(length)
  }
})

SVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {
  // Set font
  font: function(a, v) {
    if (typeof a == 'object') {
      for (v in a) this.font(v, a[v])
    }

    return a == 'leading' ?
        this.leading(v) :
      a == 'anchor' ?
        this.attr('text-anchor', v) :
      a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ?
        this.attr('font-'+ a, v) :
        this.attr(a, v)
  }
})

SVG.Set = SVG.invent({
  // Initialize
  create: function(members) {
    if (members instanceof SVG.Set) {
      this.members = members.members.slice()
    } else {
      Array.isArray(members) ? this.members = members : this.clear()
    }
  }

  // Add class methods
, extend: {
    // Add element to set
    add: function() {
      var i, il, elements = [].slice.call(arguments)

      for (i = 0, il = elements.length; i < il; i++)
        this.members.push(elements[i])

      return this
    }
    // Remove element from set
  , remove: function(element) {
      var i = this.index(element)

      // remove given child
      if (i > -1)
        this.members.splice(i, 1)

      return this
    }
    // Iterate over all members
  , each: function(block) {
      for (var i = 0, il = this.members.length; i < il; i++)
        block.apply(this.members[i], [i, this.members])

      return this
    }
    // Restore to defaults
  , clear: function() {
      // initialize store
      this.members = []

      return this
    }
    // Get the length of a set
  , length: function() {
      return this.members.length
    }
    // Checks if a given element is present in set
  , has: function(element) {
      return this.index(element) >= 0
    }
    // retuns index of given element in set
  , index: function(element) {
      return this.members.indexOf(element)
    }
    // Get member at given index
  , get: function(i) {
      return this.members[i]
    }
    // Get first member
  , first: function() {
      return this.get(0)
    }
    // Get last member
  , last: function() {
      return this.get(this.members.length - 1)
    }
    // Default value
  , valueOf: function() {
      return this.members
    }
    // Get the bounding box of all members included or empty box if set has no items
  , bbox: function(){
      // return an empty box of there are no members
      if (this.members.length == 0)
        return new SVG.RBox()

      // get the first rbox and update the target bbox
      var rbox = this.members[0].rbox(this.members[0].doc())

      this.each(function() {
        // user rbox for correct position and visual representation
        rbox = rbox.merge(this.rbox(this.doc()))
      })

      return rbox
    }
  }

  // Add parent method
, construct: {
    // Create a new set
    set: function(members) {
      return new SVG.Set(members)
    }
  }
})

SVG.FX.Set = SVG.invent({
  // Initialize node
  create: function(set) {
    // store reference to set
    this.set = set
  }

})

// Alias methods
SVG.Set.inherit = function() {
  var m
    , methods = []

  // gather shape methods
  for(var m in SVG.Shape.prototype)
    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')
      methods.push(m)

  // apply shape aliasses
  methods.forEach(function(method) {
    SVG.Set.prototype[method] = function() {
      for (var i = 0, il = this.members.length; i < il; i++)
        if (this.members[i] && typeof this.members[i][method] == 'function')
          this.members[i][method].apply(this.members[i], arguments)

      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this
    }
  })

  // clear methods for the next round
  methods = []

  // gather fx methods
  for(var m in SVG.FX.prototype)
    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')
      methods.push(m)

  // apply fx aliasses
  methods.forEach(function(method) {
    SVG.FX.Set.prototype[method] = function() {
      for (var i = 0, il = this.set.members.length; i < il; i++)
        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)

      return this
    }
  })
}


SVG.extend(SVG.Element, {
  // Store data values on svg nodes
  data: function(a, v, r) {
    if (typeof a == 'object') {
      for (v in a)
        this.data(v, a[v])

    } else if (arguments.length < 2) {
      try {
        return JSON.parse(this.attr('data-' + a))
      } catch(e) {
        return this.attr('data-' + a)
      }

    } else {
      this.attr(
        'data-' + a
      , v === null ?
          null :
        r === true || typeof v === 'string' || typeof v === 'number' ?
          v :
          JSON.stringify(v)
      )
    }

    return this
  }
})
SVG.extend(SVG.Element, {
  // Remember arbitrary data
  remember: function(k, v) {
    // remember every item in an object individually
    if (typeof arguments[0] == 'object')
      for (var v in k)
        this.remember(v, k[v])

    // retrieve memory
    else if (arguments.length == 1)
      return this.memory()[k]

    // store memory
    else
      this.memory()[k] = v

    return this
  }

  // Erase a given memory
, forget: function() {
    if (arguments.length == 0)
      this._memory = {}
    else
      for (var i = arguments.length - 1; i >= 0; i--)
        delete this.memory()[arguments[i]]

    return this
  }

  // Initialize or return local memory object
, memory: function() {
    return this._memory || (this._memory = {})
  }

})
// Method for getting an element by id
SVG.get = function(id) {
  var node = document.getElementById(idFromReference(id) || id)
  return SVG.adopt(node)
}

// Select elements by query string
SVG.select = function(query, parent) {
  return new SVG.Set(
    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {
      return SVG.adopt(node)
    })
  )
}

SVG.extend(SVG.Parent, {
  // Scoped select method
  select: function(query) {
    return SVG.select(query, this.node)
  }

})
function pathRegReplace(a, b, c, d) {
  return c + d.replace(SVG.regex.dots, ' .')
}

// creates deep clone of array
function array_clone(arr){
  var clone = arr.slice(0)
  for(var i = clone.length; i--;){
    if(Array.isArray(clone[i])){
      clone[i] = array_clone(clone[i])
    }
  }
  return clone
}

// tests if a given element is instance of an object
function is(el, obj){
  return el instanceof obj
}

// tests if a given selector matches an element
function matches(el, selector) {
  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
}

// Convert dash-separated-string to camelCase
function camelCase(s) {
  return s.toLowerCase().replace(/-(.)/g, function(m, g) {
    return g.toUpperCase()
  })
}

// Capitalize first letter of a string
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1)
}

// Ensure to six-based hex
function fullHex(hex) {
  return hex.length == 4 ?
    [ '#',
      hex.substring(1, 2), hex.substring(1, 2)
    , hex.substring(2, 3), hex.substring(2, 3)
    , hex.substring(3, 4), hex.substring(3, 4)
    ].join('') : hex
}

// Component to hex value
function compToHex(comp) {
  var hex = comp.toString(16)
  return hex.length == 1 ? '0' + hex : hex
}

// Calculate proportional width and height values when necessary
function proportionalSize(element, width, height) {
  if (width == null || height == null) {
    var box = element.bbox()

    if (width == null)
      width = box.width / box.height * height
    else if (height == null)
      height = box.height / box.width * width
  }

  return {
    width:  width
  , height: height
  }
}

// Delta transform point
function deltaTransformPoint(matrix, x, y) {
  return {
    x: x * matrix.a + y * matrix.c + 0
  , y: x * matrix.b + y * matrix.d + 0
  }
}

// Map matrix array to object
function arrayToMatrix(a) {
  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }
}

// Parse matrix if required
function parseMatrix(matrix) {
  if (!(matrix instanceof SVG.Matrix))
    matrix = new SVG.Matrix(matrix)

  return matrix
}

// Add centre point to transform object
function ensureCentre(o, target) {
  o.cx = o.cx == null ? target.bbox().cx : o.cx
  o.cy = o.cy == null ? target.bbox().cy : o.cy
}

// PathArray Helpers
function arrayToString(a) {
  for (var i = 0, il = a.length, s = ''; i < il; i++) {
    s += a[i][0]

    if (a[i][1] != null) {
      s += a[i][1]

      if (a[i][2] != null) {
        s += ' '
        s += a[i][2]

        if (a[i][3] != null) {
          s += ' '
          s += a[i][3]
          s += ' '
          s += a[i][4]

          if (a[i][5] != null) {
            s += ' '
            s += a[i][5]
            s += ' '
            s += a[i][6]

            if (a[i][7] != null) {
              s += ' '
              s += a[i][7]
            }
          }
        }
      }
    }
  }

  return s + ' '
}

// Deep new id assignment
function assignNewId(node) {
  // do the same for SVG child nodes as well
  for (var i = node.childNodes.length - 1; i >= 0; i--)
    if (node.childNodes[i] instanceof window.SVGElement)
      assignNewId(node.childNodes[i])

  return SVG.adopt(node).id(SVG.eid(node.nodeName))
}

// Add more bounding box properties
function fullBox(b) {
  if (b.x == null) {
    b.x      = 0
    b.y      = 0
    b.width  = 0
    b.height = 0
  }

  b.w  = b.width
  b.h  = b.height
  b.x2 = b.x + b.width
  b.y2 = b.y + b.height
  b.cx = b.x + b.width / 2
  b.cy = b.y + b.height / 2

  return b
}

// Get id from reference string
function idFromReference(url) {
  var m = (url || '').toString().match(SVG.regex.reference)

  if (m) return m[1]
}

// If values like 1e-88 are passed, this is not a valid 32 bit float,
// but in those cases, we are so close to 0 that 0 works well!
function float32String(v) {
  return Math.abs(v) > 1e-37 ? v : 0
}

// Create matrix array for looping
var abcdef = 'abcdef'.split('')

// Add CustomEvent to IE9 and IE10
if (typeof window.CustomEvent !== 'function') {
  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent
  var CustomEventPoly = function(event, options) {
    options = options || { bubbles: false, cancelable: false, detail: undefined }
    var e = document.createEvent('CustomEvent')
    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)
    return e
  }

  CustomEventPoly.prototype = window.Event.prototype

  SVG.CustomEvent = CustomEventPoly
} else {
  SVG.CustomEvent = window.CustomEvent
}

// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish
(function(w) {
  var lastTime = 0
  var vendors = ['moz', 'webkit']

  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']
    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||
                              w[vendors[x] + 'CancelRequestAnimationFrame']
  }

  w.requestAnimationFrame = w.requestAnimationFrame ||
    function(callback) {
      var currTime = new Date().getTime()
      var timeToCall = Math.max(0, 16 - (currTime - lastTime))

      var id = w.setTimeout(function() {
        callback(currTime + timeToCall)
      }, timeToCall)

      lastTime = currTime + timeToCall
      return id
    }

  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;

}(window))

return SVG

}));
},{}],236:[function(require,module,exports){
const regex = require('../utils/regex')

const Point = require('./Point')

class Box {
  constructor (source) {
    var base = [0, 0, 0, 0]
    source = typeof source === 'string'
      ? source.split(regex.delimiter).map(parseFloat)
      : Array.isArray(source)
        ? source
        : typeof source === 'object'
          ? [
            source.left != null ? source.left : source.x,
            source.top != null ? source.top : source.y,
            source.width,
            source.height
          ]
          : arguments.length === 4
            ? [].slice.call(arguments)
            : base

    this.x = this.left = source[0]
    this.y = this.top = source[1]
    this.width = source[2]
    this.height = source[3]
  }

  // Merge rect box with another, return a new instance
  merge (box) {
    if (box instanceof NoBox) return new Box(this)

    var x = Math.min(this.x, box.x)
    var y = Math.min(this.y, box.y)

    return new Box(
      x, y,
      Math.max(this.x + this.width, box.x + box.width) - x,
      Math.max(this.y + this.height, box.y + box.height) - y
    )
  }

  transform (m) {
    var xMin = Infinity
    var xMax = -Infinity
    var yMin = Infinity
    var yMax = -Infinity

    var pts = [
      new Point(this.x, this.y),
      new Point(this.x + this.width, this.y),
      new Point(this.x, this.y + this.height),
      new Point(this.x + this.width, this.y + this.height)
    ]

    pts.forEach(function (p) {
      p = p.transform(m)
      xMin = Math.min(xMin, p.x)
      xMax = Math.max(xMax, p.x)
      yMin = Math.min(yMin, p.y)
      yMax = Math.max(yMax, p.y)
    })

    return new Box(
      xMin, yMin,
      xMax - xMin,
      yMax - yMin
    )
  }
}

class NoBox extends Box {
  constructor () {
    super()
    this.x = 0
    this.y = 0
    this.width = 0
    this.height = 0
  }

  // NoBox has no valid values so it cant be merged
  merge (box) {
    return box instanceof NoBox ? new NoBox() : new Box(box)
  }

  transform (m) {
    return new NoBox()
  }
}

Box.NoBox = NoBox

module.exports = Box

},{"../utils/regex":250,"./Point":240}],237:[function(require,module,exports){
const { removeQuotes, splitNotInBrackets } = require('../utils/strUtils')
const regex = require('../utils/regex')

class CssQuery {
  constructor (query) {
    if (CssQuery.cache.has(query)) {
      this.queries = CssQuery.cache.get(query)
      return
    }

    var queries = splitNotInBrackets(query, ',')

    queries = queries.map(query => {

      var roundBrackets = 0
      var squareBrackets = 0

      // this is the same as above but easier
      query.replace(/[()[]>~+]/g, function (ch) {
        if (ch === '(') ++roundBrackets
        else if (ch === ')') --roundBrackets
        else if (ch === '[') ++squareBrackets
        else if (ch === ']') --squareBrackets

        if (squareBrackets || roundBrackets) return ch

        return ' ' + ch + ' '
      })

      // split at space and remove empty results
      query = splitNotInBrackets(query, ' ').filter(el => !!el.length)

      var pairs = []

      var relation = '%'

      // generate querynode relation tuples
      for (var i = 0, il = query.length; i < il; ++i) {

        if ('>~+%'.indexOf(query[i]) > -1) {
          relation = query[i]
          continue
        }

        pairs.push([relation, query[i]])
        relation = '%'

      }

      return pairs

    })

    this.queries = queries

    // to prevent memory leaks we have to manage our cache.
    // we delete everything which is older than 50 entries
    if (CssQuery.cacheKeys.length > 50) {
      CssQuery.cache.delete(CssQuery.cacheKeys.shift())
    }
    CssQuery.cache.set(query, queries)
    CssQuery.cacheKeys.push(query)

  }

  matches (node) {
    for (var i = this.queries.length; i--;) {
      if (this.matchHelper(this.queries[i], node)) {
        return true
      }
    }
    return false
  }

  matchHelper (query, node) {
    query = query.slice()
    var last = query.pop()

    if (!new CssQueryNode(last[1]).matches(node)) { return false }

    if (!query.length) return true

    if (last[0] === ',') return true

    if (last[0] === '+') {
      return !!node.previousSibling && this.matchHelper(query, node.previousSibling)
    }

    if (last[0] === '>') {
      return !!node.parentNode && this.matchHelper(query, node.parentNode)
    }

    if (last[0] === '~') {
      while ((node = node.previousSibling)) {
        if (this.matchHelper(query, node)) { return true }
      }
      return false
    }

    if (last[0] === '%') {
      while ((node = node.parentNode)) {
        if (this.matchHelper(query, node)) { return true }
      }
      return false
    }
  }

}

CssQuery.cache = new Map()
CssQuery.cacheKeys = []

// check if [node] is the [nth] child of [arr] where nth can also be a formula
const nth = (node, arr, nth) => {

  if (nth === 'even') nth = '2n'
  else if (nth === 'odd') nth = '2n+1'

  // check for eval chars
  if (/[^\d\-n+*/]+/.test(nth)) return false

  nth = nth.replace('n', '*n')

  // eval nth to get the index
  for (var i, n = 0, nl = arr.length; n < nl; ++n) {
    /* eslint no-eval: off */
    i = eval(nth)

    if (i > nl) break
    if (arr[i - 1] === node) return true
  }

  return false
}

const lower = a => a.toLowerCase()

// checks if a and b are equal. Is insensitive when i is true
const eq = (a, b, i) => i ? lower(a) === lower(b) : a === b

// [i] (prebound) is true if insensitive matching is required
// [a] (prebound) is the value the attr is compared to
// [b] (passed)   is the value of the attribute
const attributeMatcher = {
  '=': (i, a, b) => eq(a, b, i),
  '~=': (i, a, b) => b.split(regex.delimiter).filter(el => eq(el, a, i)).length > 0,
  '|=': (i, a, b) => eq(b.split(regex.delimiter)[0], a, i),
  '^=': (i, a, b) => i ? lower(b).startsWith(lower(a)) : b.startsWith(a),
  '$=': (i, a, b) => i ? lower(b).endsWith(lower(a)) : b.endsWith(a),
  '*=': (i, a, b) => i ? lower(b).includes(lower(a)) : b.includes(a),
  '*': (i, a, b) => b != null
}

// [a] (prebound) [a]rgument of the pseudo selector
// [n] (passed)   [n]ode
const pseudoMatcher = {
  'first-child': (a, n) => n.parentNode && n.parentNode.firstChild === n,
  'last-child': (a, n) => n.parentNode && n.parentNode.lastChild === n,
  'nth-child': (a, n) => n.parentNode && nth(n, n.parentNode.childNodes, a),
  'nth-last-child': (a, n) => n.parentNode && nth(n, n.parentNode.childNodes.slice().reverse(), a),
  'first-of-type': (a, n) => n.parentNode && n.parentNode.childNodes.filter(el => el.nodeName === n.nodeName)[0] === n,
  'last-of-type': (a, n) => n.parentNode && n.parentNode.childNodes.filter(el => el.nodeName === n.nodeName).pop() === n,
  'nth-of-type': (a, n) => n.parentNode && nth(n, n.parentNode.childNodes.filter(el => el.nodeName === n.nodeName), a),
  'nth-last-of-type': (a, n) => n.parentNode && nth(n, n.parentNode.childNodes.filter(el => el.nodeName === n.nodeName).reverse(), a),
  'only-child': (a, n) => n.parentNode && n.parentNode.childNodes.length === 1,
  'only-of-type': (a, n) => n.parentNode && n.parentNode.childNodes.filter(el => el.nodeName === n.nodeName).length === 1,
  'root': (a, n) => n.ownerDocument.documentElement === n,
  'not': (a, n) => !(new CssQuery(a)).matches(n),
  'matches': (a, n) => (new CssQuery(a)).matches(n)
}

class CssQueryNode {
  constructor (node) {
    this.tag = ''
    this.id = ''
    this.classList = []
    this.attrs = []
    this.pseudo = []

    // match the tag name
    var matches = node.match(/^[\w-]+|\*/)
    if (matches) {
      this.tag = matches[0]
      node = node.slice(this.tag.length)
    }

    // match pseudo classes
    while ((matches = /:([\w-]+)(?:\((.+)\))?/g.exec(node))) {
      this.pseudo.push(pseudoMatcher[matches[1]].bind(this, removeQuotes(matches[2] || '')))
      node = node.slice(0, matches.index) + node.slice(matches.index + matches[0].length)
    }

    // match the id
    matches = node.match(/#([\w-]+)/)
    if (matches) {
      this.id = matches[1]
      node = node.slice(0, matches.index) + node.slice(matches.index + matches[0].length)
    }

    // match classes
    while ((matches = /\.([\w-]+)/g.exec(node))) {
      this.classList.push(matches[1])
      node = node.slice(0, matches.index) + node.slice(matches.index + matches[0].length)
    }

    // match attributes
    while ((matches = /\[([\w-]+)(([=^~$|*]+)(.+?)( +[iI])?)?\]/g.exec(node))) {
      this.attrs.push({
        name: matches[1],
        matcher: attributeMatcher[matches[3] || '*'].bind(
          this,
          !!matches[5], // case insensitive yes/no
          removeQuotes((matches[4] || '').trim()) // attribute value
        )
      })
      node = node.slice(0, matches.index) + node.slice(matches.index + matches[0].length)
    }

  }

  matches (node) {
    var i

    if (node.nodeType !== 1) return false

    if (this.tag && this.tag !== node.nodeName && this.tag !== '*') { return false }

    if (this.id && this.id !== node.id) {
      return false
    }

    var classList = (node.getAttribute('class') || '').split(regex.delimiter).filter(el => !!el.length)
    if (this.classList.filter(className => classList.indexOf(className) < 0).length) {
      return false
    }

    for (i = this.attrs.length; i--;) {
      var attrValue = node.getAttribute(this.attrs[i].name)
      if (attrValue === null || !this.attrs[i].matcher(attrValue)) {
        return false
      }
    }

    for (i = this.pseudo.length; i--;) {
      if (!this.pseudo[i](node)) {
        return false
      }
    }

    return true
  }

}

module.exports = CssQuery

},{"../utils/regex":250,"../utils/strUtils":251}],238:[function(require,module,exports){
const $ = Symbol('private properties')

class EventTarget {
  constructor () {
    this[$] = {}
    this[$].listeners = {}
  }

  addEventListener (type, callback) {
    if (!(type in this[$].listeners)) {
      this[$].listeners[type] = []
    }
    this[$].listeners[type].push(callback)
  }

  removeEventListener (type, callback) {
    if (!(type in this[$].listeners)) {
      return
    }

    var stack = this[$].listeners[type]
    for (var i = 0, il = stack.length; i < il; i++) {
      if (stack[i] === callback) {
        stack.splice(i, 1)
        return
      }
    }
  }

  dispatchEvent (event) {
    if (!(event.type in this[$].listeners)) { return true }

    var stack = this[$].listeners[event.type]
    event.target = this

    stack.forEach(function (el) {
      el(event)
    })

    return !event.defaultPrevented
  }

}

module.exports = EventTarget

},{}],239:[function(require,module,exports){
const { extendClass } = require('../utils/objectCreationUtils')

const EventTarget = require('./EventTarget')

const { objectToMap, mapToObject, mapMap, mapToCss, cssToMap } = require('../utils/mapUtils')
const { hexToRGB, camelCase, htmlEntities } = require('../utils/strUtils')
const pathUtils = require('../utils/pathUtils')
const { tag, cloneNode } = require('../utils/tagUtils')
const bbox = require('../utils/bboxUtils')
const regex = require('../utils/regex')

const CssQuery = require('./CssQuery')
const SVGPoint = require('./SVGPoint')
const SVGMatrix = require('./SVGMatrix')
const Box = require('./Box')

// XMLParser
const sax = require('sax')

// Map matrix array to object
function arrayToMatrix (a) {
  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }
}

class Node extends EventTarget {
  constructor (name = '', props = {}) {
    super()

    this.nodeName = name
    this.nodeType = Node.ELEMENT_NODE
    this.nodeValue = 0
    this.childNodes = []

    this._style = {}

    if (props.attrs && props.attrs.style) {
      this._style = mapToObject(cssToMap(props.attrs.style))
    }

    this.attrs = objectToMap(props.attrs || {})
    this.data = props.data || ''

    this.ownerDocument = props.ownerDocument || null
    this.parentNode = null
    this.cnt = 0

    this.style = this.getStyleProxy()

    if (props.childNodes) {
      for (var i = 0, il = props.childNodes.length; i < il; ++i) {
        this.appendChild(props.childNodes[i])
      }
    }
  }

  getStyleProxy () {
    return new Proxy(this._style, {
      get (target, key) {
        if (typeof key !== 'string') return Reflect.get(target, key)
        if (key === 'cssText') {
          return mapToCss(objectToMap(target))
        }
        if (key === 'setProperty') {
          return function (propertyName, value, priority) {
            Reflect.set(target, propertyName, value)
          }
        }
        key = camelCase(key)
        if (!target[key]) return ''
        return Reflect.get(target, key)
      },
      set (target, key, value) {
        value = hexToRGB(value.toString())
        key = camelCase(key)
        return Reflect.set(target, key, value)
      }
    })
  }
  setNewStyle (obj) {
    this._style = hexToRGB(obj)
    this.style = this.getStyleProxy()
  }
  setAttribute (name, value) {
    if (name === 'style') {
      return this.setNewStyle(mapToObject(cssToMap(value)))
    }
    this.attrs.set(name, value)
  }
  setAttributeNS (ns, name, value) {
    this.setAttribute(name, value)
  }
  removeAttribute (name) {
    this.attrs.delete(name)
  }
  removeAttributeNS (ns, name) {
    this.removeAttribute(name)
  }
  hasAttribute (name) {
    if (name === 'style') return !!this.style.cssText // TODO check
    return this.attrs.get(name) != null
  }
  getAttribute (name) {
    if (name === 'style') return this.style.cssText
    return this.attrs.get(name) == null ? null : this.attrs.get(name)
  }
  getAttributeNS (ns, name) {
    return this.getAttribute(name)
  }
  hasChildNodes () {
    return !!this.childNodes.length
  }
  appendChild (node) {
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      for (var i = 0, il = node.childNodes.length; i < il; ++i) {
        node.parentNode = this
        this.childNodes.push(node.childNodes[i])
      }
      node.childNodes.splice(0)
      return node
    }

    if (node.parentNode) { node.parentNode.removeChild(node) }

    node.parentNode = this

    this.childNodes.push(node)
    return node
  }
  insertBefore (node, before) {
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      let index = this.childNodes.indexOf(before)
      if (index === -1) return this.appendChild(node)

      this.childNodes = this.childNodes.slice(0, index).concat(node.childNodes, this.childNodes.slice(index))

      node.childNodes.splice(0)
      return node
    }

    if (node.parentNode) { node.parentNode.removeChild(node) }

    node.parentNode = this

    let index = this.childNodes.indexOf(before)
    if (index === -1) return this.appendChild(node)

    this.childNodes = this.childNodes.slice(0, index).concat(node, this.childNodes.slice(index))
    return node
  }
  removeChild (node) {

    node.parentNode = null
    var index = this.childNodes.indexOf(node)
    if (index === -1) return node
    this.childNodes.splice(index, 1)
    return node
  }
  replaceChild (newChild, oldChild) {
    newChild.parentNode && newChild.parentNode.removeChild(newChild)

    var before = oldChild.nextSibling
    this.removeChild(oldChild)
    this.insertBefore(newChild, before)
    return oldChild
  }
  getElementsByTagName (name) {
    return this.childNodes.reduce(function (last, current) {
      if (current.nodeName === name) last.push(current)
      return last.concat(current.getElementsByTagName(name))
    }, [])
  }
  getElementById (id) {
    for (var i = this.childNodes.length; i--;) {
      if (this.childNodes[i].id === id) return this.childNodes[i]
      var el = this.childNodes[i].getElementById(id)
      if (el) return el
    }
    return null
  }
  cloneNode (deep) {
    var clone = cloneNode(this)

    if (deep) {
      this.childNodes.forEach(function (el) {
        var node = el.cloneNode(deep)
        clone.appendChild(node)
      })
    }

    return clone
  }
  getRootNode () {
    if (!this.parentNode || this.parentNode.nodeType === Node.DOCUMENT_NODE) return this
    return this.parentNode.getRootNode()
  }
  isDefaultNamespace (ns) {
    return ns === this.attrs.get('xmlns')
  }
  isEqualNode (node) {
    return node.nodeName === this.nodeName && node.constructor === this.constructor && node.nodeType === this.nodeType
  }
  isSameNode (node) {
    return this === node
  }
  contains (node) {
    if (node === this) return false

    while (node.parentNode) {
      if (node === this) return true
      node = node.parentNode
    }
    return false
  }
  normalize () {
    this.childNodes = this.childNodes.reduce((textNodes, node) => {
      // FIXME: If first node is an empty textnode, what do we do? -> spec
      if (!textNodes) return [node]
      var last = textNodes.pop()

      if (node.nodeType === Node.TEXT_NODE) {
        if (!node.data) return textNodes

        if (last.nodeType === Node.TEXT_NODE) {
          const merged = new TextNode(last.data + ' ' + node.data)
          textNodes.push(merged)
          return textNodes.concat(merged)
        }
      } else {
        textNodes.push(last, node)
      }

      return textNodes
    }, null)
  }
  dropNameSpace (ns) {
    if (this.parentNode) {
      if (this.parentNode.attrs.get('xmlns') === ns) return true
      return this.parentNode.dropNameSpace(ns)
    }
    return false
  }
  getBBox () {
    return bbox(this).bbox()
  }
  getBoundingClientRect () {
    // The bounding client rect takes the screen ctm of the element
    // and converts the bounding box with it

    // however, normal bounding consists of:
    // - all children transformed
    // - the viewbox of the element if available

    // The boundingClientRect is not affected by its own viewbox
    // So we apply only our own transformations and parents screenCTM

    let m = this.matrixify()

    if (this.parentNode && this.parentNode.nodeName !== '#document') {
      m = this.parentNode.getScreenCTM().multiply(m)
    }

    // let m = this.getScreenCTM()

    return bbox(this).transform(m).bbox()
  }
  matrixify () {
    var matrix = (this.getAttribute('transform') || '')
      // split transformations
      .split(regex.transforms).slice(0, -1).map(function (str) {
        // generate key => value pairs
        var kv = str.trim().split('(')
        return [kv[0].trim(), kv[1].split(regex.delimiter).map(function (str) { return parseFloat(str.trim()) })]
      })
      // merge every transformation into one matrix
      .reduce(function (matrix, transform) {

        if (transform[0] === 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))
        return matrix[transform[0]].apply(matrix, transform[1])

      }, new SVGMatrix())

    return matrix
  }
  // TODO: https://www.w3.org/TR/SVG2/coords.html#ComputingAViewportsTransform
  generateViewBoxMatrix () {
    var view = (this.getAttribute('viewBox') || '').split(regex.delimiter).map(parseFloat).filter(el => !isNaN(el))
    var width = parseFloat(this.getAttribute('width')) || 0
    var height = parseFloat(this.getAttribute('height')) || 0
    var x = parseFloat(this.getAttribute('x')) || 0
    var y = parseFloat(this.getAttribute('y')) || 0

    // TODO: If no width and height is given, width and height of the outer svg element is used
    if (!width || !height) {
      return new SVGMatrix().translate(x, y)
    }

    if (view.length !== 4) {
      view = [0, 0, width, height]
    }

    // first apply x and y if nested, then viewbox scale, then viewBox move
    return new SVGMatrix().translate(x, y).scale(width / view[2], height / view[3]).translate(-view[0], -view[1])
  }
  getCTM () {
    var m = this.matrixify()

    var node = this
    while ((node = node.parentNode)) {
      if (['svg', 'symbol', 'image', 'pattern', 'marker'].indexOf(node.nodeName) > -1) break
      m = m.multiply(node.matrixify())
      if (node.nodeName === '#document') return this.getScreenCTM()
    }

    return node.generateViewBoxMatrix().multiply(m)
  }
  getScreenCTM () {
    // ref: https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
    // We follow Chromes behavior and include the viewbox in the screenCTM
    var m = this.getInnerMatrix()

    if (this.parentNode && this.parentNode.nodeName !== '#document') {
      return this.parentNode.getScreenCTM().multiply(m)
    }

    return m
  }
  getInnerMatrix () {
    var m = this.matrixify()

    if (['svg', 'symbol', 'image', 'pattern', 'marker'].indexOf(this.nodeName) > -1) {
      m = this.generateViewBoxMatrix().multiply(m)
    }
    return m
  }
  createSVGRect () {
    return new Box()
  }
  createSVGMatrix () {
    return new SVGMatrix()
  }
  createSVGPoint () {
    return new SVGPoint()
  }
  matches (query) {
    return new CssQuery(query).matches(this)
  }
  querySelectorAll (query) {
    var ret = []
    for (var i = 0, il = this.childNodes.length; i < il; ++i) {
      if (this.childNodes[i].matches(query)) ret.push(this.childNodes[i])
      ret = ret.concat(this.childNodes[i].querySelectorAll(query))
    }
    return ret
  }
  querySelector (query) {
    var ret = []
    for (var i = 0, il = this.childNodes.length; i < il; ++i) {
      if (this.childNodes[i].matches(query)) ret.push(this.childNodes[i])
      ret = ret.concat(this.childNodes[i].querySelectorAll(query))
    }
    return ret[0] || null
  }
  getComputedTextLength () {
    return this.getBBox().width
  }
  getPointAtLength (len) {
    return pathUtils.pointAtLength(this.getAttribute('d'), len)
  }
  getTotalLength () {
    return pathUtils.length(this.getAttribute('d'))
  }
  getFontDetails () {
    var node = this
    var fontSize = null
    var fontFamily = null
    var textAnchor = null
    var dominantBaseline = null

    const textContentElements = {
      text: true,
      tspan: true,
      tref: true,
      textPath: true,
      altGlyph: true,
      g: true
    }

    do {
      // TODO: stop on
      if (!fontSize) { fontSize = node.style.fontSize || node.getAttribute('font-size') }
      if (!fontFamily) { fontFamily = node.style.fontFamily || node.getAttribute('font-family') }
      if (!textAnchor) { textAnchor = node.style.textAnchor || node.getAttribute('text-anchor') }
      if (!dominantBaseline) { dominantBaseline = node.style.dominantBaseline || node.getAttribute('dominant-baseline') }
      // TODO: check for alignment-baseline in tspan, tref, textPath, altGlyph
      // TODO: alignment-adjust, baseline-shift
      /*
      if(!alignmentBaseline)
      alignmentBaseline = this.style.alignmentBaseline || this.getAttribute('alignment-baseline')
      */

    } while (
      node.parentNode.nodeType === Node.ELEMENT_NODE
      && (node.parentNode.nodeName in textContentElements)
      && (node = node.parentNode)
    )

    return {
      fontFamily,
      fontSize,
      textAnchor: textAnchor || 'start',
      // TODO: use central for writing-mode === horizontal https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/dominant-baseline
      dominantBaseline: dominantBaseline || 'alphabetical',
      fontFamilyMappings: this.ownerDocument.fontFamilyMappings,
      fontDir: this.ownerDocument.fontDir,
      preloaded: this.ownerDocument._preloaded
    }
  }
}

// Define dynamic properties
Object.defineProperties(Node.prototype, {
  attributes: {
    get () {
      var attributes = mapToAttributeArray(this.attrs)
      if (Object.keys(this._style).length) {
        attributes.push(new AttributeNode('style', this.getAttribute('style')))
      }
      return attributes
    }
  },
  className: {
    get () {
      return this.getAttribute('class')
    },
    set (c) {
      this.setAttribute('class', c)
    }
  },
  textContent: {
    get () {
      if (this.nodeType === Node.TEXT_NODE) return this.data

      return this.childNodes.reduce(function (last, current) {
        return last + current.textContent
      }, '')
    },
    set (text) {
      this.childNodes = [new TextNode('#text', { data: htmlEntities(text) })]
    }
  },
  firstChild: {
    get () {
      return this.childNodes[0] || null
    }
  },
  lastChild: {
    get () {
      return this.childNodes[this.childNodes.length - 1] || null
    }
  },
  children: {
    get () {
      return this.childNodes.filter(function (node) { return node.nodeType === Node.ELEMENT_NODE })
    }
  },
  nextSibling: {
    get () {
      const child = this.parentNode && this.parentNode.childNodes[this.parentNode.childNodes.indexOf(this) + 1]
      return child || null
    }
  },
  previousSibling: {
    get () {
      const child = this.parentNode && this.parentNode.childNodes[this.parentNode.childNodes.indexOf(this) - 1]
      return child || null
    }
  },
  innerHTML: {
    get () {
      if (this.nodeType === Node.TEXT_NODE) return this.data
      return this.childNodes.reduce(function (last, current) {
        return last + current.outerHTML
      }, '')
    },
    set (str) {
      while (this.firstChild) {
        this.removeChild(this.firstChild)
      }
      // The parser adds the html to this
      HTMLParser(str, this)
    }
  },
  outerHTML: {
    get () {
      if (this.nodeType === Node.TEXT_NODE) return this.data
      if (this.nodeType === Node.DOCUMENT_NODE || this.nodeType === Node.DOCUMENT_FRAGMENT_NODE) return this.innerHTML
      return tag(this)
    },
    set (str) {
      var well = new SVGElement('well')
      HTMLParser(str, well)
      for (var i = 0, il = well.childNodes.length; i < il; ++i) {
        this.parentNode.insertBefore(well.childNodes[i], this)
      }
      this.parentNode.removeChild(this)
    }
  },
  id: {
    get () {
      return this.attrs.get('id')
    },
    set (id) {
      this.attrs.set('id', id)
    }
  },
  ownerSVGElement: {
    get () {
      return this.ownerDocument ? this.ownerDocument.documentElement : null
    }
  }
})

extendClass(Node, {
  ELEMENT_NODE: 1,
  ATTRIBUTE_NODE: 2,
  TEXT_NODE: 3,
  CDATA_SECTION_NODE: 4,
  ENTITY_REFERENCE_NODE: 5,
  ENTITY_NODE: 6,
  PROCESSING_INSTRUCTION_NODE: 7,
  COMMENT_NODE: 8,
  DOCUMENT_NODE: 9,
  DOCUMENT_TYPE_NODE: 10,
  DOCUMENT_FRAGMENT_NODE: 11,
  NOTATION_NODE: 12
})

class SVGElement extends Node { }

const mapToAttributeArray = function (themap) {
  return mapMap(themap, function (value, key) {
    return new AttributeNode(key, value)
  })
}

class DocumentFragment extends Node {
  constructor () {
    super('#document-fragment')
    this.nodeType = Node.DOCUMENT_FRAGMENT_NODE
  }
}

class AttributeNode extends Node {
  constructor (name = '', value = null) {
    super(name)
    this.nodeValue = value
    this.nodeType = Node.ATTRIBUTE_NODE
  }
}

class CharacterData extends Node {
  constructor (name, props) {
    super(name, props)
    if (Object.getPrototypeOf(this) === CharacterData.prototype) {
      throw new Error('CharacterData cannot be created directly')
    }
  }
}

class TextNode extends CharacterData {
  constructor (name, props) {
    super(name, props)
    this.nodeType = Node.TEXT_NODE
  }
}

class Comment extends CharacterData {
  constructor (name, props) {
    super(name, props)
    this.nodeType = Node.COMMENT_NODE
  }
}

const HTMLParser = function (str, el) {
  let currentTag = el
  var ownerDocument = el.ownerDocument

  var parser = sax.parser(true)
  parser.ontext = t => currentTag.appendChild(new TextNode('#text', {
    data: t,
    ownerDocument: ownerDocument
  }))
  parser.onopentag = node => {
    var newSvgElement = new SVGElement(node.name, {
      attrs: node.attributes,
      ownerDocument: ownerDocument
    })
    currentTag.appendChild(newSvgElement)
    currentTag = newSvgElement
  }
  parser.onclosetag = node => {
    currentTag = currentTag.parentNode
  }

  parser.write(str)
}

module.exports = {
  Node,
  SVGElement,
  DocumentFragment,
  AttributeNode,
  TextNode,
  Comment
}

},{"../utils/bboxUtils":245,"../utils/mapUtils":247,"../utils/objectCreationUtils":248,"../utils/pathUtils":249,"../utils/regex":250,"../utils/strUtils":251,"../utils/tagUtils":252,"./Box":236,"./CssQuery":237,"./EventTarget":238,"./SVGMatrix":241,"./SVGPoint":242,"sax":226}],240:[function(require,module,exports){
const SVGPoint = require('./SVGPoint')

class Point {
  // Initialize
  constructor (x, y) {
    var source
    var base = { x: 0, y: 0 }

    // ensure source as object
    source = Array.isArray(x)
      ? { x: x[0], y: x[1] }
      : typeof x === 'object'
        ? { x: x.x, y: x.y }
        : x != null
          ? { x: x, y: (y != null ? y : x) } : base // If y has no value, then x is used has its value

    // merge source
    this.x = source.x
    this.y = source.y
  }

  // Clone point
  clone () {
    return new Point(this)
  }
  // Convert to native SVGPoint
  native () {
    // create new point
    var point = new SVGPoint()

    // update with current values
    point.x = this.x
    point.y = this.y

    return point
  }
  // transform point with matrix
  transform (matrix) {
    return new Point(this.native().matrixTransform(matrix))
  }
  add (x, y) {
    var p = new Point(x, y)
    return new Point(this.x + p.x, this.y + p.y)
  }
  sub (x, y) {
    var p = new Point(x, y)
    return new Point(this.x - p.x, this.y - p.y)
  }
  mul (factor) {
    return new Point(this.x * factor, this.y * factor)
  }
  div (factor) {
    return new Point(this.x / factor, this.y / factor)
  }
  absQuad () {
    return this.x * this.x + this.y * this.y
  }
  abs () {
    return Math.sqrt(this.absQuad())
  }
  normalize () {
    var abs = this.abs()
    if (!abs) throw new Error('Can\'t normalize vector of zero length')
    return this.div(abs)
  }
  normal () {
    return new Point(this.y, -this.x)
  }
  toArray () {
    return [this.x, this.y]
  }
  reflectAt (p) {
    return p.add(p.sub(this))
  }
  toPath () {
    return ['M', this.x, this.y].join(' ')
  }
  equals (p) {
    return this.x === p.x && this.y === p.y
  }
  closeTo (p, eta = 0.00001) {
    return this.equals(p) || (Math.abs(this.x - p.x) < eta && Math.abs(this.y - p.y) < eta)
  }
  angleTo (p) {
    var sign = Math.sign(this.x * p.y - this.y * p.x)
    sign = sign || 1
    return sign * Math.acos(Math.round((this.dot(p) / (this.abs() * p.abs())) * 1000000) / 1000000)
  }
  dot (p) {
    return this.x * p.x + this.y * p.y
  }
}

module.exports = Point

},{"./SVGPoint":242}],241:[function(require,module,exports){
const { extendClass } = require('../utils/objectCreationUtils')
const matrix = require('gl-matrix').mat2d

const radians = function (d) {
  return d % 360 * Math.PI / 180
}

class SVGMatrix {
  constructor () {
    this.a = this.d = 1
    this.b = this.c = this.e = this.f = 0
  }

  multiply (m) {
    var r = new SVGMatrix()
    r.a = this.a * m.a + this.c * m.b + this.e * 0
    r.b = this.b * m.a + this.d * m.b + this.f * 0
    r.c = this.a * m.c + this.c * m.d + this.e * 0
    r.d = this.b * m.c + this.d * m.d + this.f * 0
    r.e = this.a * m.e + this.c * m.f + this.e * 1
    r.f = this.b * m.e + this.d * m.f + this.f * 1
    return r
  }
  translate (x=0, y=0) {
    return this.multiply(matrixFactory(1, 0, 0, 1, x, y))
  }
  inverse () {
    var t = matrix.fromValues(this.a, this.b, this.c, this.d, this.e, this.f)
    var r = matrix.create()
    matrix.invert(r, t)
    return matrixFactory(...r)
  }
  toString () {
    return 'SVGMatrix'
  }
  scale (scaleX, scaleY=scaleX) {
    return this.multiply(matrixFactory(scaleX, 0, 0, scaleY, 0, 0))
  }
  rotate (r, x, y) {
    r = r % 360 * Math.PI / 180
    return this.multiply(matrixFactory(
      Math.cos(r),
      Math.sin(r),
      -Math.sin(r),
      Math.cos(r),
      x ? -Math.cos(r) * x + Math.sin(r) * y + x : 0,
      y ? -Math.sin(r) * x - Math.cos(r) * y + y : 0
    ))
  }
  skew (x, y) {
    return this.multiply(matrixFactory(1, Math.tan(radians(y)), Math.tan(radians(x)), 1, 0, 0))
  }
  skewX (x) {
    return this.skew(x, 0)
  }
  skewY (y) {
    return this.skew(0, y)
  }
}

const matrixFactory = function (a, b, c, d, e, f) {
  var r = new SVGMatrix()
  r.a = a
  r.b = b
  r.c = c
  r.d = d
  r.e = e
  r.f = f
  return r
}

extendClass(SVGMatrix, {
  matrixFactory
})

module.exports = SVGMatrix

},{"../utils/objectCreationUtils":248,"gl-matrix":203}],242:[function(require,module,exports){
class SVGPoint {
  constructor () {
    this.x = 0
    this.y = 0
  }
  matrixTransform (m) {
    var r = new SVGPoint()
    r.x = m.a * this.x + m.c * this.y + m.e * 1
    r.y = m.b * this.x + m.d * this.y + m.f * 1
    return r
  }
}

module.exports = SVGPoint

},{}],243:[function(require,module,exports){
const { extend } = require('./utils/objectCreationUtils')
const EventTarget = require('./class/EventTarget')
const SVGPoint = require('./class/SVGPoint')
const SVGMatrix = require('./class/SVGMatrix')
const { SVGElement, DocumentFragment, Node, TextNode, Comment, AttributeNode } = require('./class/Node')
const sizeOf = require('image-size')
const path = require('path')
const fontkit = require('fontkit')
const { htmlEntities } = require('./utils/strUtils')

class HTMLLinkElement extends Node {
  constructor () {
    super('link')
  }
}

Object.defineProperties(HTMLLinkElement.prototype, {
  href: {
    get () {
      return this.attrs.get('href')
    },
    set (val) {
      this.attrs.set('href', val)
    }
  },
  rel: {
    get () {
      return this.attrs.get('rel')
    },
    set (val) {
      this.attrs.set('rel', val)
    }
  },
  type: {
    get () {
      return this.attrs.get('type')
    },
    set (val) {
      this.attrs.set('type', val)
    }
  }
})

class HTMLScriptElement extends Node {
  constructor () {
    super('script')
  }
}

Object.defineProperties(HTMLScriptElement.prototype, {
  src: {
    get () {
      return this.attrs.get('src')
    },
    set (val) {
      this.attrs.set('src', val)
    }
  },
  type: {
    get () {
      return this.attrs.get('type')
    },
    set (val) {
      this.attrs.set('type', val)
    }
  }
})

class HTMLImageElement extends Node {
  constructor () {
    super('img')
    this.width = 0
    this.height = 0
    this.naturalWidth = 0
    this.naturalHeight = 0
  }
}

Object.defineProperties(HTMLImageElement.prototype, {
  src: {
    get () {
      return this.attrs.get('src')
    },
    set (val) {
      this.attrs.set('src', val)
      sizeOf(val, (err, size) => {
        if (err) {
          this.dispatchEvent(new Event('error', this))
          return
        }

        this.width = this.naturalWidth = size.width
        this.height = this.naturalHeight = size.height

        this.dispatchEvent(new Event('load', this))
      })
    }
  },
  height: {
    get () {
      return this.attrs.get('height')
    },
    set (val) {
      this.attrs.set('height', val)
    }
  },
  width: {
    get () {
      return this.attrs.get('width')
    },
    set (val) {
      this.attrs.set('width', val)
    }
  }
})

class Event {
  constructor (type) {
    this.type = type
    this.cancelable = false
    this.defaultPrevented = false
  }

  preventDefault () {
    this.defaultPrevented = true
  }
}

class CustomEvent extends Event {
  constructor (name, props = {}) {
    super(name)

    this.detail = props.detail || null
    this.cancelable = props.cancelable || false
  }
}

// Feature/version pairs that DOMImplementation.hasFeature() returns true for.  It returns false for anything else.
var supportedFeatures = {
  'xml': { '': true, '1.0': true, '2.0': true }, // DOM Core
  'core': { '': true, '2.0': true }, // DOM Core
  'html': { '': true, '1.0': true, '2.0': true }, // HTML
  'xhtml': { '': true, '1.0': true, '2.0': true } // HTML
}

class DOMImplementation {
  hasFeature (feature, version) {
    var f = supportedFeatures[(feature || '').toLowerCase()]
    return (f && f[version || '']) || false
  }

  createDocumentType (qualifiedName, publicId, systemId) {
    throw new Error('createDocumentType not implemented yet')
  }

  createDocument (namespace, qualifiedName, doctype) {
    var doc = new Document()

    if (doctype) {
      if (doctype.ownerDocument) { throw new Error('the object is in the wrong Document, a call to importNode is required') }
      doc.appendChild(doctype)
    }

    if (qualifiedName) { doc.appendChild(doc.createElementNS(namespace, qualifiedName)) }

    return doc
  }

  createHTMLDocument (titleText) {
    var d = new Document('html')
    var root = d.documentElement
    var head = d.createElement('head')
    root.appendChild(head)
    var title = d.createElement('title')
    head.appendChild(title)
    title.appendChild(d.createTextNode(titleText))
    root.appendChild(d.createElement('body'))
    return d
  }
}

function getChildByTagName (parent, name) {
  for (var child = parent.firstChild; child != null; child = child.nextSibling) {
    if (child.nodeType === Node.ELEMENT_NODE && child.nodeName === name) {
      return child
    }
  }
  return null
}

class Document extends Node {
  constructor (root) {
    super('#document')
    this.nodeType = Node.DOCUMENT_NODE
    root = this.createElement(root)
    this.appendChild(root)
    root.ownerDocument = this
    this.documentElement = root
    this._preloaded = {}
    this._implementation = new DOMImplementation()
  }

  createElementNS (ns, name) {
    return new SVGElement(name, {
      attrs: { xmlns: ns },
      ownerDocument: this
    })
  }
  createDocumentFragment (name) {
    return new DocumentFragment()
  }
  createElement (name) {
    switch (name) {
    case 'img':
      return new HTMLImageElement({ ownerDocument: this })
    case 'link':
      return new HTMLLinkElement({ ownerDocument: this })
    case 'script':
      return new HTMLScriptElement({ ownerDocument: this })
    default:
      return new SVGElement(name, { ownerDocument: this })
    }
  }
  createTextNode (text) {
    return new TextNode('#text', { data: htmlEntities(text), ownerDocument: this })
  }
  createComment (text) {
    return new Comment('#comment', { data: text, ownerDocument: this })
  }
  createAttribute (name) {
    return new AttributeNode(name, { ownerDocument: this })
  }
}

Object.defineProperties(Document.prototype, {
  implementation: {
    get () {
      return this._implementation
    }
  },
  compatMode: {
    get () {
      return 'CSS1Compat' // always be in standards-mode
    }
  },
  body: {
    get () {
      return getChildByTagName(this.documentElement, 'body')
    },
    set () {
      throw new Error('setting body not implemented yet')
    }
  },
  head: {
    get () {
      return getChildByTagName(this.documentElement, 'head')
    }
  }
})

class Window extends EventTarget {
  constructor () {
    super()
    this.document = new Document('svg')
  }
  setFontDir (dir) {
    this.document.fontDir = dir
    return this
  }
  setFontFamilyMappings (map) {
    this.document.fontFamilyMappings = map
    return this
  }
  preloadFonts () {
    var map = this.document.fontFamilyMappings
    var filename

    for (var i in map) {
      filename = path.join(this.document.fontDir, map[i])

      try {
        this.document._preloaded[i] = fontkit.openSync(filename)
      } catch (e) {
        console.warn('Could not load font file for ' + i + '.' + e)
      }
    }

    return this

  }
  getComputedStyle (node) {

    return {
      // FIXME: Currently this function treats every given attr
      // as inheritable from its parents which is ofc not always true
      // but good enough for svg.js
      getPropertyValue (attr) {
        let value

        do {
          value = node.style[attr] || node.getAttribute(attr)
        } while (
          value == null
          && (node = node.parentNode)
          && node.nodeType === 1
        )

        return value || null
      }
    }
  }
}

extend(Window, {
  Window: Window,
  DocumentFragment: DocumentFragment,
  Node: Node,
  Text: TextNode,
  Element: SVGElement,
  SVGElement: SVGElement,
  CustomEvent: CustomEvent,
  Event: Event,
  SVGMatrix: SVGMatrix,
  SVGPoint: SVGPoint,
  HTMLLinkElement: HTMLLinkElement,
  HTMLScriptElement: HTMLScriptElement,
  Image: HTMLImageElement,
  HTMLImageElement: HTMLImageElement,
  setTimeout: setTimeout,
  clearTimeout: clearTimeout,
  pageXOffset: 0,
  pageYOffset: 0
})

module.exports = new Window()

},{"./class/EventTarget":238,"./class/Node":239,"./class/SVGMatrix":241,"./class/SVGPoint":242,"./utils/objectCreationUtils":248,"./utils/strUtils":251,"fontkit":202,"image-size":205,"path":11}],244:[function(require,module,exports){
const Box = require('../class/Box.js')
const { NoBox } = Box

class PointCloud extends Array {
  constructor (...args) {
    if (args.length === 1 && typeof args[0] === 'number') {
      super(args.shift())
    } else {
      super()
    }

    // except multiple point arrays as input and merge them into one
    args.reduce((last, curr) => {
      last.push(...curr)
      return this
    }, this)
  }

  transform (m) {
    return new PointCloud(this.map((p) => p.transform(m)))
  }

  bbox () {
    if (!this.length) {
      return new NoBox()
    }

    let xMin = Infinity
    let xMax = -Infinity
    let yMin = Infinity
    let yMax = -Infinity

    this.forEach(function (p) {
      xMin = Math.min(xMin, p.x)
      xMax = Math.max(xMax, p.x)
      yMin = Math.min(yMin, p.y)
      yMax = Math.max(yMax, p.y)
    })

    return new Box(
      xMin, yMin,
      xMax - xMin,
      yMax - yMin
    )
  }

  merge (cloud) {
    return new PointCloud(this, cloud)
  }
}

module.exports = PointCloud

},{"../class/Box.js":236}],245:[function(require,module,exports){
const pathUtils = require('./pathUtils')
const { NoBox } = require('../class/Box')
const regex = require('./regex')
const textUtils = require('./textUtils')
const strUtils = require('./strUtils')
const PointCloud = require('./PointCloud.js')

const applyTransformation = (cloud, node, applyTransformations) => {
  if (applyTransformations) {
    return cloud.transform(node.matrixify())
  }
  return cloud
}

const getPointCloud = (node, applyTransformations) => {
  let cloud = getPathCloud(node, applyTransformations)
  return applyTransformation(cloud, node, applyTransformations)
}

const getPathCloud = (node, applyTransformations) => {
  if (node.nodeType !== 1) return new PointCloud()

  switch (node.nodeName) {
  case 'rect':
  case 'image':
    // Create Path from rect and create PointCloud from Path
    return pathUtils.getCloud(pathUtils.pathFrom.rect(node))
  case 'svg':
  case 'mask':
  case 'pattern':
  case 'symbol':
    return pathUtils.getCloud(pathUtils.pathFrom.rect(node))
  case 'g':
  case 'clipPath':
  case 'a':
  case 'marker':
    // Iterate trough all childs and get the point cloud of each
    // Then transform it with viewbox matrix if needed
    return node.childNodes.reduce((cloud, child) => {
      return cloud.merge(getPointCloud(child, true))
    }, new PointCloud())
  case 'circle':
    return pathUtils.getCloud(pathUtils.pathFrom.circle(node))
  case 'ellipse':
    return pathUtils.getCloud(pathUtils.pathFrom.ellipse(node))
  case 'line':
    return pathUtils.getCloud(pathUtils.pathFrom.line(node))
  case 'polyline':
  case 'polygon':
    return pathUtils.getCloud(pathUtils.pathFrom.polyline(node))
  case 'path':
  case 'glyph':
  case 'missing-glyph':
    return pathUtils.getCloud(node.getAttribute('d'))
  case 'use':
    // Get reference from element
    let ref = node.getAttribute('href')
    // Get the actual referenced Node
    let refNode = node.getRootNode().getElementById(ref.slice(1))
    // Get the BBox of the referenced element and apply the viewbox of <use>
    return getPointCloud(refNode).transform(node.generateViewBoxMatrix())
  case 'text':
  case 'tspan':
  case 'altGlyph':
    const boxes = textIterator(node).filter(box => box.x !== 0 || box.y !== 0 || box.width !== 0 || box.height !== 0)
    const box = boxes.reduce((last, curr) => last.merge(curr), new NoBox())

    if (box instanceof NoBox) {
      return new PointCloud()
    }

    return pathUtils.getCloud(pathUtils.pathFrom.box(box))

  default:
    return new PointCloud()
  }
}

// this function is passing dx and dy values by references. Dont assign new values to it!
// const textIterator = function(node, x0=0, y0=0, dx=[0], dy=[0]){
const textIterator = function (node, pos = { x: 0, y: 0 }, dx = [0], dy = [0]) {

  var x = parseFloat(node.getAttribute('x'))
  var y = parseFloat(node.getAttribute('y'))

  pos.x = isNaN(x) ? pos.x : x
  pos.y = isNaN(y) ? pos.y : y

  var dx0 = (node.getAttribute('dx') || '').split(regex.delimiter).filter(num => num !== '').map(parseFloat)
  var dy0 = (node.getAttribute('dy') || '').split(regex.delimiter).filter(num => num !== '').map(parseFloat)
  var boxes = []
  var data = ''

  // TODO: eventually replace only as much values as we have text chars (node.textContent.length) because we could end up adding to much
  // replace initial values with node values if present
  dx.splice(0, dx0.length, ...dx0)
  dy.splice(0, dy0.length, ...dy0)

  var i = 0
  var il = node.childNodes.length

  // iterate through all children
  for (; i < il; ++i) {

    // shift next child
    pos.x += dx.shift() || 0
    pos.y += dy.shift() || 0

    // text
    if (node.childNodes[i].nodeType === 3) {

      // get text data
      data = strUtils.unhtmlEntities(node.childNodes[i].data)

      let j = 0
      let jl = data.length

      // if it is more than one dx/dy single letters are moved by the amount (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/dx)
      if (dy.length || dx.length) {
        for (;j < jl; j++) {
          boxes.push(textUtils.bbox(data.substr(j, 1), pos.x, pos.y, node.getFontDetails()))

          pos.x += dx.shift() || 0
          pos.y += dy.shift() || 0

          if (!dy.length && !dx.length) break
        }
      }

      // in case it was only one dx/dy or no more dx/dy move the rest of the text

      boxes.push(textUtils.bbox(data.substr(j), pos.x, pos.y, node.getFontDetails()))
      pos.x += boxes[boxes.length - 1].width

    // node
    } else {
      // in case of node recursively call function again with new start values
      boxes = boxes.concat(textIterator(node.childNodes[i], pos, dx, dy))
    }
  }

  return boxes

}

module.exports = getPointCloud

},{"../class/Box":236,"./PointCloud.js":244,"./pathUtils":249,"./regex":250,"./strUtils":251,"./textUtils":253}],246:[function(require,module,exports){
(function (__dirname){
const path = require('path')

module.exports = {
  fontSize: 16,
  fontFamily: 'sans-serif',
  fontDir: path.join(__dirname, '..', 'fonts/'),
  fontFamilyMappings: { 'sans-serif': 'OpenSans-Regular.ttf' }
}

}).call(this,"/node_modules/.registry.npmjs.org/svgdom/0.0.20/node_modules/svgdom/utils")
},{"path":11}],247:[function(require,module,exports){
const { decamelize } = require('../utils/strUtils')

const objectToMap = function (obj) {
  if (obj instanceof Map) return new Map(obj)
  return Object.keys(obj).reduce((map, key) => map.set(key, obj[key]), new Map())
}

const mapToObject = function (map) {
  var obj = {}
  map.forEach(function (value, key) {
    obj[key] = value
  })
  return obj
}

const mapMap = function (map, cb) {
  var arr = []
  map.forEach(function (value, key) {
    arr.push(cb(value, key))
  })
  return arr
}

const mapToCss = function (myMap) {
  return mapMap(myMap, function (value, key) {
    if (!value) return false
    return decamelize(key) + ':' + value
  }).filter(function (el) { return !!el }).join(';') || null
}

const cssToMap = function (css) {
  return new Map(css.split(/\s*;\s*/).filter(function (el) { return !!el }).map(function (el) {
    return el.split(/\s*:\s*/)
  }))
}

module.exports = {
  mapMap,
  objectToMap,
  mapToObject,
  mapToCss,
  cssToMap
}

},{"../utils/strUtils":251}],248:[function(require,module,exports){
var extend = function () {
  var modules, methods, key, i

  // Get list of modules
  modules = [].slice.call(arguments)

  // Get object with extensions
  methods = modules.pop()

  for (i = modules.length - 1; i >= 0; i--) {
    for (key in methods) { modules[i].prototype[key] = methods[key] }
  }
}

var extendClass = function () {
  var modules, methods, key, i

  // Get list of modules
  modules = [].slice.call(arguments)

  // Get object with extensions
  methods = modules.pop()

  for (i = modules.length - 1; i >= 0; i--) {
    for (key in methods) { modules[i][key] = methods[key] }
  }
}

var invent = function (config) {
  var initializer = config.create || function () {}

  if (config.name) { Object.defineProperty(initializer, 'name', { value: config.name }) }

  // Inherit prototype
  if (config.inherit) {
    initializer.prototype = Object.create(config.inherit.prototype)
  }

  initializer.prototype.constructor = initializer

  // Extend with methods
  if (config.extend) { extend(initializer, config.extend) }

  if (config.props) {
    for (var i in config.props) { Object.defineProperty(initializer.prototype, i, config.props[i]) }
  }

  return initializer
}

module.exports = {
  invent: invent,
  extend: extend,
  extendClass: extendClass
}

},{}],249:[function(require,module,exports){
const Box = require('../class/Box')
const Point = require('../class/Point')
const regex = require('./regex')
const matrixFactory = require('../class/SVGMatrix').matrixFactory
const PointCloud = require('./PointCloud.js')
const { NoBox } = Box

var pathHandlers = {
  M (c, p, r, p0) {
    p.x = p0.x = c[0]
    p.y = p0.y = c[1]

    return new Move(p)
  },
  L (c, p) {
    var ret = new Line(p.x, p.y, c[0], c[1])// .offset(o)
    p.x = c[0]
    p.y = c[1]
    return ret
  },
  H (c, p) {
    return pathHandlers.L([c[0], p.y], p)
  },
  V (c, p) {
    return pathHandlers.L([p.x, c[0]], p)
  },
  Q (c, p, r) {
    var ret = Cubic.fromQuad(p, new Point(c[0], c[1]), new Point(c[2], c[3]))// .offset(o)
    p.x = c[2]
    p.y = c[3]

    var reflect = new Point(c[0], c[1]).reflectAt(p)
    r.x = reflect.x
    r.y = reflect.y

    return ret
  },
  T (c, p, r, p0, reflectionIsPossible) {
    if (reflectionIsPossible) { c = [r.x, r.y].concat(c) } else { c = [p.x, p.y].concat(c) }
    return pathHandlers.Q(c, p, r)
  },
  C (c, p, r) {
    var ret = new Cubic(p, new Point(c[0], c[1]), new Point(c[2], c[3]), new Point(c[4], c[5]))// .offset(o)
    p.x = c[4]
    p.y = c[5]
    var reflect = new Point(c[2], c[3]).reflectAt(p)
    r.x = reflect.x
    r.y = reflect.y
    return ret
  },
  S (c, p, r, p0, reflectionIsPossible) {
    // reflection makes only sense if this command was preceeded by another beziere command (QTSC)
    if (reflectionIsPossible) { c = [r.x, r.y].concat(c) } else { c = [p.x, p.y].concat(c) }
    return pathHandlers.C(c, p, r)
  },
  Z (c, p, r, p0) {
    // FIXME: The behavior of Z depends on the command before
    return pathHandlers.L([p0.x, p0.y], p)
  },
  A (c, p, r) {
    var ret = new Arc(p, new Point(c[5], c[6]), c[0], c[1], c[2], c[3], c[4])
    p.x = c[5]
    p.y = c[6]
    return ret
  }
}

var mlhvqtcsa = 'mlhvqtcsaz'.split('')

for (var i = 0, il = mlhvqtcsa.length; i < il; ++i) {
  pathHandlers[mlhvqtcsa[i]] = (function (i) {
    return function (c, p, r, p0, reflectionIsPossible) {
      if (i === 'H') c[0] = c[0] + p.x
      else if (i === 'V') c[0] = c[0] + p.y
      else if (i === 'A') {
        c[5] = c[5] + p.x
        c[6] = c[6] + p.y
      } else {
        for (var j = 0, jl = c.length; j < jl; ++j) {
          c[j] = c[j] + (j % 2 ? p.y : p.x)
        }
      }

      return pathHandlers[i](c, p, r, p0, reflectionIsPossible)
    }
  })(mlhvqtcsa[i].toUpperCase())
}

function pathRegReplace (a, b, c, d) {
  return c + d.replace(regex.dots, ' .')
}

function isBeziere (obj) {
  return obj instanceof Cubic
}

const pathParser = (array) => {

  // prepare for parsing
  var paramCnt = { 'M': 2, 'L': 2, 'H': 1, 'V': 1, 'C': 6, 'S': 4, 'Q': 4, 'T': 2, 'A': 7, 'Z': 0 }

  array = array
    .replace(regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123
    .replace(regex.pathLetters, ' $& ') // put some room between letters and numbers
    .replace(regex.hyphen, '$1 -') // add space before hyphen
    .trim() // trim
    .split(regex.delimiter) // split into array

  // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]
  var arr = []
  var p = new Point()
  var p0 = new Point()
  var r = new Point()
  var index = 0
  var len = array.length
  var s

  do {
    // Test if we have a path letter
    if (regex.isPathLetter.test(array[index])) {
      s = array[index]
      ++index
    // If last letter was a move command and we got no new, it defaults to [L]ine
    } else if (s === 'M') {
      s = 'L'
    } else if (s === 'm') {
      s = 'l'
    }

    arr.push(
      pathHandlers[s].call(null,
        array.slice(index, (index = index + paramCnt[s.toUpperCase()])).map(parseFloat),
        p, r, p0,
        isBeziere(arr[arr.length - 1])
      )
    )

  } while (len > index)

  return arr
}

class Move {
  constructor (p) {
    this.p1 = p.clone()
  }

  getCloud () {
    return new PointCloud([this.p1])
  }

  // FIXME: Use pointcloud
  bbox () {
    let p = this.p1
    return new Box(p.x, p.y, 0, 0)
  }

  length () { return 0 }

  toPath () {
    return ['M', this.p1.x, this.p1.y].join(' ')
  }

  toPathFragment () {
    return ['M', this.p1.x, this.p1.y]
  }
}

class Arc {
  constructor (p1, p2, rx, ry, φ, arc, sweep) {
    this.p1 = p1.clone()
    this.p2 = p2.clone()
    this.arc = arc ? 1 : 0
    this.sweep = sweep ? 1 : 0

    var cosφ = Math.cos(φ / 180 * Math.PI)

    var sinφ = Math.sin(φ / 180 * Math.PI)

    var p1_ = new Point(
      (p1.x - p2.x) / 2,
      (p1.y - p2.y) / 2
    ).transform(matrixFactory(
      cosφ, -sinφ, sinφ, cosφ, 0, 0
    ))

    var ratio = (p1_.x * p1_.x) / (rx * rx) + (p1_.y * p1_.y) / (ry * ry)

    if (ratio > 1) {
      rx = Math.sqrt(ratio) * rx
      ry = Math.sqrt(ratio) * ry
    }

    var divisor1 = rx * rx * p1_.y * p1_.y
    var divisor2 = ry * ry * p1_.x * p1_.x

    var c_ = new Point(
      rx * p1_.y / ry,
      -ry * p1_.x / rx
    ).mul(Math.sqrt(
      Math.round((rx * rx * ry * ry - divisor1 - divisor2) * 100000) / 100000
      // -------------------------------//
             / (divisor1 + divisor2)
    ))

    if (this.arc === this.sweep) c_ = c_.mul(-1)

    var c = c_.transform(matrixFactory(
      cosφ, sinφ, -sinφ, cosφ, 0, 0
    )).add(new Point(
      (p1.x + p2.x) / 2,
      (p1.y + p2.y) / 2
    ))

    var anglePoint = new Point(
      (p1_.x - c_.x) / rx,
      (p1_.y - c_.y) / ry
    )

    var θ = new Point(1, 0).angleTo(anglePoint)

    var Δθ = anglePoint.angleTo(new Point(
      (-p1_.x - c_.x) / rx,
      (-p1_.y - c_.y) / ry
    ))

    Δθ = (Δθ % (2 * Math.PI))

    if (!sweep && Δθ > 0) Δθ -= 2 * Math.PI
    if (sweep && Δθ < 0) Δθ += 2 * Math.PI

    this.c = c
    this.theta = θ * 180 / Math.PI
    this.theta2 = (θ + Δθ) * 180 / Math.PI

    this.delta = Δθ * 180 / Math.PI
    this.rx = rx
    this.ry = ry
    this.phi = φ
    this.cosφ = cosφ
    this.sinφ = sinφ
  }

  pointAt (t) {
    const tInAngle = (this.theta + t * this.delta) / 180 * Math.PI
    const sinθ = Math.sin(tInAngle)
    const cosθ = Math.cos(tInAngle)

    return new Point(
      this.cosφ * this.rx * cosθ - this.sinφ * this.ry * sinθ + this.c.x,
      this.sinφ * this.rx * cosθ + this.cosφ * this.ry * sinθ + this.c.y
    )
  }

  length () {
    var length = this.p2.sub(this.p1).abs()

    var ret = this.splitAt(0.5)
    var len1 = ret[0].p2.sub(ret[0].p1).abs()
    var len2 = ret[1].p2.sub(ret[1].p1).abs()

    if (len1 + len2 - length < 0.00001) {
      return len1 + len2
    }

    return ret[0].length() + ret[1].length()
  }

  splitAt (t) {
    var absDelta = Math.abs(this.delta)
    var delta1 = absDelta * t
    var delta2 = absDelta * (1 - t)

    return [
      new Arc(this.p1, this.pointAt(t), this.rx, this.ry, this.phi, delta1 > 180, this.sweep),
      new Arc(this.pointAt(t), this.p2, this.rx, this.ry, this.phi, delta2 > 180, this.sweep)
    ]
  }

  clone () {
    return new Arc(this.p1, this.p2, this.rx, this.ry, this.phi, this.arc, this.sweep)
  }

  getCloud () {
    // arc could be rotated. the min and max values then dont lie on multiples of 90 degress but are shifted by the rotation angle
    // so we first calculate our 0/90 degree angle
    var θ01 = Math.atan(-this.sinφ / this.cosφ * this.ry / this.rx) * 180 / Math.PI
    var θ02 = Math.atan(this.cosφ / this.sinφ * this.ry / this.rx) * 180 / Math.PI
    var θ1 = this.theta
    var θ2 = this.theta2

    if (θ1 < 0 || θ2 < 0) {
      θ1 += 360
      θ2 += 360
    }

    if (θ2 < θ1) {
      let temp = θ1
      θ1 = θ2
      θ2 = temp

    }

    while (θ01 - 90 > θ01) θ01 -= 90
    while (θ01 < θ1) θ01 += 90
    while (θ02 - 90 > θ02) θ02 -= 90
    while (θ02 < θ1) θ02 += 90

    const angleToTest = [θ01, θ02, (θ01 + 90), (θ02 + 90), (θ01 + 180), (θ02 + 180), (θ01 + 270), (θ02 + 270)]

    let points = angleToTest.filter(function (angle) {
      return (angle > θ1 && angle < θ2)
    }).map(function (angle) {
      while (this.theta < angle) angle -= 360
      return this.pointAt(((angle - this.theta) % 360) / (this.delta)) // TODO: replace that call with pointAtAngle
    }.bind(this)).concat(this.p1, this.p2)

    return new PointCloud(points)
  }

  bbox () {
    const cloud = this.getCloud()
    return cloud.bbox()
  }

  toPathFragment () {
    return ['A', this.rx, this.ry, this.phi, this.arc, this.sweep, this.p2.x, this.p2.y]
  }

  toPath () {
    return ['M', this.p1.x, this.p1.y, 'A', this.rx, this.ry, this.phi, this.arc, this.sweep, this.p2.x, this.p2.y].join(' ')
  }

  static fromCenterForm (c, rx, ry, φ, θ, Δθ) {
    var cosφ = Math.cos(φ / 180 * Math.PI)
    var sinφ = Math.sin(φ / 180 * Math.PI)
    var m = matrixFactory(cosφ, sinφ, -sinφ, cosφ, 0, 0)

    var p1 = new Point(
      rx * Math.cos(θ / 180 * Math.PI),
      ry * Math.sin(θ / 180 * Math.PI)
    ).transform(m).add(c)

    var p2 = new Point(
      rx * Math.cos((θ + Δθ) / 180 * Math.PI),
      ry * Math.sin((θ + Δθ) / 180 * Math.PI)
    ).transform(m).add(c)

    var arc = Math.abs(Δθ) > 180 ? 1 : 0
    var sweep = Δθ > 0 ? 1 : 0

    return new Arc(p1, p2, rx, ry, φ, arc, sweep)
  }
}

class Cubic {
  constructor (p1, c1, c2, p2) {
    if (p1 instanceof Point) {
      this.p1 = new Point(p1)
      this.c1 = new Point(c1)
      this.c2 = new Point(c2)
      this.p2 = new Point(p2)
    } else {
      this.p1 = new Point(p1.p1)
      this.c1 = new Point(p1.c1)
      this.c2 = new Point(p1.c2)
      this.p2 = new Point(p1.p2)
    }
  }

  pointAt (t) {
    return new Point(
      (1 - t) * (1 - t) * (1 - t) * this.p1.x + 3 * (1 - t) * (1 - t) * t * this.c1.x + 3 * (1 - t) * t * t * this.c2.x + t * t * t * this.p2.x,
      (1 - t) * (1 - t) * (1 - t) * this.p1.y + 3 * (1 - t) * (1 - t) * t * this.c1.y + 3 * (1 - t) * t * t * this.c2.y + t * t * t * this.p2.y
    )
  }

  findRootsX () {
    return this.findRootsXY(this.p1.x, this.c1.x, this.c2.x, this.p2.x)
  }

  findRootsY () {
    return this.findRootsXY(this.p1.y, this.c1.y, this.c2.y, this.p2.y)
  }

  findRootsXY (p1, p2, p3, p4) {
    var a = 3 * (-p1 + 3 * p2 - 3 * p3 + p4)
    var b = 6 * (p1 - 2 * p2 + p3)
    var c = 3 * (p2 - p1)

    if (a === 0) return [-c / b].filter(function (el) { return el > 0 && el < 1 })

    if (b * b - 4 * a * c < 0) return []
    if (b * b - 4 * a * c === 0) return [Math.round((-b / (2 * a)) * 100000) / 100000].filter(function (el) { return el > 0 && el < 1 })

    return [
      Math.round((-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a) * 100000) / 100000,
      Math.round((-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a) * 100000) / 100000
    ].filter(function (el) { return el > 0 && el < 1 })
  }

  findRoots () {
    return this.findRootsX().concat(this.findRootsY())
  }

  lengthAt (t = 1) {
    var curves = this.splitAt(t)[0].makeFlat(t)

    var length = 0
    for (var i = 0, len = curves.length; i < len; ++i) {
      length += curves[i].p2.sub(curves[i].p1).abs()
    }

    return length
  }

  length () {
    return this.lengthAt()
  }

  flatness () {
    var ux = Math.pow(3 * this.c1.x - 2 * this.p1.x - this.p2.x, 2)
    var uy = Math.pow(3 * this.c1.y - 2 * this.p1.y - this.p2.y, 2)
    var vx = Math.pow(3 * this.c2.x - 2 * this.p2.x - this.p1.x, 2)
    var vy = Math.pow(3 * this.c2.y - 2 * this.p2.y - this.p1.y, 2)

    if (ux < vx) { ux = vx }
    if (uy < vy) { uy = vy }

    return ux + uy
  }

  makeFlat (t) {
    if (this.flatness() > 0.15) {
      return this.splitAt(0.5)
        .map(function (el) { return el.makeFlat(t * 0.5) })
        .reduce(function (last, current) { return last.concat(current) }, [])
    } else {
      this.t_value = t
      return [this]
    }
  }

  splitAtScalar (z, p) {
    var p1 = this.p1[p]
    var p2 = this.c1[p]
    var p3 = this.c2[p]
    var p4 = this.p2[p]

    var t = z * z * z * p4 - 3 * z * z * (z - 1) * p3 + 3 * z * (z - 1) * (z - 1) * p2 - (z - 1) * (z - 1) * (z - 1) * p1

    return [
      [
        p1,
        z * p2 - (z - 1) * p1,
        z * z * p3 - 2 * z * (z - 1) * p2 + (z - 1) * (z - 1) * p1,
        t
      ],
      [
        t,
        z * z * p4 - 2 * z * (z - 1) * p3 + (z - 1) * (z - 1) * p2,
        z * p4 - (z - 1) * p3,
        p4
      ]
    ]
  }

  splitAt (z) {
    var x = this.splitAtScalar(z, 'x')
    var y = this.splitAtScalar(z, 'y')

    var a = new Cubic(
      new Point(x[0][0], y[0][0]),
      new Point(x[0][1], y[0][1]),
      new Point(x[0][2], y[0][2]),
      new Point(x[0][3], y[0][3])
    )

    var b = new Cubic(
      new Point(x[1][0], y[1][0]),
      new Point(x[1][1], y[1][1]),
      new Point(x[1][2], y[1][2]),
      new Point(x[1][3], y[1][3])
    )

    return [a, b]
  }

  getCloud () {
    var points = this.findRoots()
      .filter(root => root !== 0 && root !== 1)
      .map(root => this.pointAt(root))
      .concat(this.p1, this.p2)

    return new PointCloud(points)
  }

  bbox () {
    return this.getCloud().bbox()
  }

  toPathFragment () {
    return ['C', this.c1.x, this.c1.y, this.c2.x, this.c2.y, this.p2.x, this.p2.y]
  }

  toPath () {
    return ['M', this.p1.x, this.p1.y].concat(this.toPathFragment()).join(' ')
  }

  static fromQuad (p1, c, p2) {
    var c1 = p1.mul(1 / 3).add(c.mul(2 / 3))
    var c2 = c.mul(2 / 3).add(p2.mul(1 / 3))
    return new Cubic(p1, c1, c2, p2)
  }
}

class Line {
  constructor (x1, y1, x2, y2) {
    if (x1 instanceof Object) {
      this.p1 = new Point(x1)
      this.p2 = new Point(y1)
    } else {
      this.p1 = new Point(x1, y1)
      this.p2 = new Point(x2, y2)
    }
  }

  getCloud () {
    return new PointCloud([this.p1, this.p2])
  }

  bbox () {
    return this.getCloud().bbox()
  }

  pointAt (t) {
    var vec = this.p2.sub(this.p1).mul(t)
    return this.p1.add(vec)
  }

  length () {
    return this.p2.sub(this.p1).abs()
  }

  toPath () {
    return ['M', this.p1.x, this.p1.y, this.p2.x, this.p2.y].join(' ')
  }

  toPathFragment () {
    return ['L', this.p2.x, this.p2.y]
  }
}

const bbox = function (d) {
  return pathParser(d).reduce((l, c) => l.merge(c.bbox()), new NoBox())
}

const pointAtLength = function (d, len) {
  var segs = pathParser(d)

  var segLengths = segs.map(el => el.length())

  var length = segLengths.reduce((l, c) => l + c, 0)

  var i = 0

  let t = len / length

  // FIXME: Pop Move before using shortcut?
  // shortcut for trivial cases
  if (t >= 1) {
    // Check if there is a p2. If not, use p1
    if (segs[segs.length - 1].p2) {
      return segs[segs.length - 1].p2.native()
    } else {
      return segs[segs.length - 1].p1.native()
    }
  }

  if (t <= 0) return segs[0].p1.native()

  // remove move commands at the very end of the path
  while (segs[segs.length - 1] instanceof Move) segs.pop()

  var segEnd = 0

  for (il = segLengths.length; i < il; ++i) {
    var k = segLengths[i] / length
    segEnd += k

    if (segEnd > t) {
      break
    }
  }

  var ratio = length / segLengths[i]
  t = ratio * (t - segEnd) + 1

  return segs[i].pointAt(t).native()
}

const length = function (d) {
  return pathParser(d)
    .reduce((l, c) => l + c.length(), 0)
}

const debug = function (node) {
  const parse = pathParser(node.getAttribute('d'))

  const ret = {
    paths: parse.map(el => el.toPath()),
    fragments: parse.map(el => el.toPathFragment().join(' ')),
    bboxs: parse.map(el => {
      var box = el.bbox()
      return [box.x, box.y, box.width, box.height]
    }),
    bbox: parse.reduce((l, c) => l.merge(c.bbox()), new NoBox()),
    bboxs_new: parse.map(el => {
      return el.getCloud().transform(node.matrixify()).bbox()
    })
  }

  return Object.assign({}, ret, {
    bbox_new: ret.bboxs_new.reduce((l, c) => l.merge(c), new NoBox())
  })
}

const getCloud = (d) => {
  return pathParser(d).reduce((cloud, segment) =>
    segment.getCloud().merge(cloud), new PointCloud()
  )
}

const pathFrom = {
  box ({ x, y, width, height }) {
    return `M ${x} ${y} h ${width} v ${height} H ${x} V ${y}`
  },
  rect (node) {
    const width = parseFloat(node.getAttribute('width')) || 0
    const height = parseFloat(node.getAttribute('height')) || 0
    const x = parseFloat(node.getAttribute('x')) || 0
    const y = parseFloat(node.getAttribute('y')) || 0
    return `M ${x} ${y} h ${width} v ${height} H ${x} V ${y}`
  },
  circle (node) {
    const r = parseFloat(node.getAttribute('r')) || 0
    const x = parseFloat(node.getAttribute('cx')) || 0
    const y = parseFloat(node.getAttribute('cy')) || 0

    if (r === 0) return 'M0 0'

    return `M ${x - r} ${y} A ${r} ${r} 0 0 0 ${x + r} ${y} A ${r} ${r} 0 0 0 ${x - r} ${y}`
  },
  ellipse (node) {
    const rx = parseFloat(node.getAttribute('rx')) || 0
    const ry = parseFloat(node.getAttribute('ry')) || 0
    const x = parseFloat(node.getAttribute('cx')) || 0
    const y = parseFloat(node.getAttribute('cy')) || 0

    return `M ${x - rx} ${y} A ${rx} ${ry} 0 0 0 ${x + rx} ${y} A ${rx} ${ry} 0 0 0 ${x - rx} ${y}`
  },
  line (node) {
    const x1 = parseFloat(node.getAttribute('x1')) || 0
    const x2 = parseFloat(node.getAttribute('x2')) || 0
    const y1 = parseFloat(node.getAttribute('y1')) || 0
    const y2 = parseFloat(node.getAttribute('y2')) || 0

    return `M ${x1} ${y1} L ${x2} ${y2}`
  },
  polygon (node) {
    return `M ${node.getAttribute('points')} z`
  },
  polyline (node) {
    return `M ${node.getAttribute('points')}`
  }
}

module.exports = {
  bbox,
  pointAtLength,
  length,
  debug,
  Arc,
  pathParser,
  pathFrom,
  getCloud
}

},{"../class/Box":236,"../class/Point":240,"../class/SVGMatrix":241,"./PointCloud.js":244,"./regex":250}],250:[function(require,module,exports){
module.exports = {
  // splits a transformation chain
  transforms: /\)\s*,?\s*/,
  // split at whitespace and comma
  delimiter: /[\s,]+/,

  // The following regex are used to parse the d attribute of a path

  // Matches all hyphens which are not after an exponent
  hyphen: /([^e])-/gi,

  // Replaces and tests for all path letters
  pathLetters: /[MLHVCSQTAZ]/gi,

  // yes we need this one, too
  isPathLetter: /[MLHVCSQTAZ]/i,

  // matches 0.154.23.45
  numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,

  // matches .
  dots: /\./g
}

},{}],251:[function(require,module,exports){
// Ensure to six-based hex
const fullHex = function (hex) {
  return hex.length === 4
    ? [ '#',
      hex.substring(1, 2), hex.substring(1, 2),
      hex.substring(2, 3), hex.substring(2, 3),
      hex.substring(3, 4), hex.substring(3, 4)
    ].join('') : hex
}

const hexToRGB = function (a) {
  if (typeof a === 'object') {
    for (var i in a) {
      a[i] = hexToRGB(a[i])
    }
    return a
  }

  if (!/#[0-9a-f]{3,6}/.test(a)) { return a }

  a = fullHex(a)

  return 'rgb(' + [
    parseInt(a.slice(1, 3), 16),
    parseInt(a.slice(3, 5), 16),
    parseInt(a.slice(5, 7), 16)
  ].join(',') + ')'
}

function decamelize (s) {
  return String(s).replace(/([a-z])([A-Z])/g, function (m, g1, g2) {
    return g1 + '-' + g2.toLowerCase()
  })
}

function camelCase (s) {
  return String(s).replace(/([a-z])-([a-z])/g, function (m, g1, g2) {
    return g1 + g2.toUpperCase()
  })
}

function removeQuotes (str) {
  if (str.startsWith('"') || str.startsWith("'")) {
    return str.slice(1, -1)
  }
  return str
}

function htmlEntities (str) {
  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;')
}

function unhtmlEntities (str) {
  return String(str).replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace('&quot;', '"')
}

const splitNotInBrackets = (str, delimiter) => {
  var roundBrackets = 0

  var squareBrackets = 0

  var lastIndex = 0

  var split = []

  var ch; var i; var il

  for (i = 0, il = str.length; i < il; ++i) {
    ch = str.charAt(i)

    if (ch === delimiter && !roundBrackets && !squareBrackets) {
      split.push(str.slice(lastIndex, i).trim())
      lastIndex = i + 1
      continue
    }

    if (ch === '(') ++roundBrackets
    else if (ch === ')') --roundBrackets
    else if (ch === '[') ++squareBrackets
    else if (ch === ']') --squareBrackets
  }

  split.push(str.slice(lastIndex).trim())
  return split
}

module.exports = {
  fullHex,
  hexToRGB,
  camelCase,
  decamelize,
  removeQuotes,
  htmlEntities,
  unhtmlEntities,
  splitNotInBrackets
}

},{}],252:[function(require,module,exports){
const { mapMap } = require('./mapUtils')

const htmlEntities = function (str) {
  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;')
}

var emptyElements = {
  br: true,
  hr: true,
  img: true,
  link: true
}

const tag = function (node) {

  var attrs = new Map(node.attrs)

  var name = node.nodeName

  var style = node.getAttribute('style')

  attrs.delete('style')
  if (style) {
    attrs.set('style', style)
  }

  if (attrs.has('xmlns') && node.dropNameSpace(attrs.get('xmlns'))) {
    attrs.delete('xmlns')
  }

  attrs = mapMap(attrs, function (value, key) {
    return key + '="' + htmlEntities(value) + '"'
  })

  return '<' + [].concat(name, attrs).join(' ') + '>' + (emptyElements[name] ? '' : node.innerHTML + '</' + name + '>')
}

const cloneNode = function (node) {

  var clone = new node.constructor(node.nodeName, {
    attrs: node.attrs,
    data: node.data,
    ownerDocument: node.ownerDocument
  })

  // clone styles
  Object.keys(node._style).forEach(function (el) { clone._style[el] = node._style[el] })
  clone.nodeType = node.nodeType

  return clone
}

module.exports = {
  tag,
  cloneNode
}

},{"./mapUtils":247}],253:[function(require,module,exports){
const defaults = require('./defaults')
const Box = require('../class/Box')
const path = require('path')
const fontkit = require('fontkit')

const bbox = function (text, x, y, details) {

  var families = (details.fontFamily || defaults.fontFamily).split(/\s*,\s*/)
  var fontMap = Object.assign({}, defaults.fontFamilyMappings, details.fontFamilyMappings)
  var fontSize = details.fontSize || defaults.fontSize
  var fontDir = details.fontDir || defaults.fontDir
  var fontFamily
  var font

  for (var i = 0, il = families.length; i < il; ++i) {
    if (fontMap[families[i]]) {
      fontFamily = families[i]
      break
    }
  }

  if (!fontFamily) {
    fontFamily = defaults.fontFamily
  }

  if (details.preloaded[fontFamily]) {
    font = details.preloaded[fontFamily]
  } else {
    let filename = path.join(fontDir, fontMap[fontFamily])

    try {
      font = fontkit.openSync(filename)
    } catch (e) {
      console.warn(`Could not open font "${fontFamily}" in file "${filename}". ${e.toString()}`)
      return new Box()
    }

    details.preloaded[fontFamily] = font
  }

  var fontHeight = font.ascent - font.descent
  var lineHeight = fontHeight > font.unitsPerEm ? fontHeight : fontHeight + font.lineGap

  var height = lineHeight / font.unitsPerEm * fontSize
  var width = font.layout(text).glyphs.reduce((last, curr) => last + curr.advanceWidth, 0) / font.unitsPerEm * fontSize

  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/text-anchor
  var xAdjust = 0
  if (details.textAnchor === 'end') {
    xAdjust = -width
  } else if (details.textAnchor === 'middle') {
    xAdjust = -width / 2
  }

  // https://www.w3.org/TR/2002/WD-css3-linebox-20020515/
  // 4.2. Baseline identifiers
  var yAdjust = font.ascent // alphabetic
  if (details.dominantBaseline === 'before-edge' || details.dominantBaseline === 'text-before-edge') {
    yAdjust = 0
  } else if (details.dominantBaseline === 'hanging') {
    yAdjust = font.ascent - font.xHeight - font.capHeight
  } else if (details.dominantBaseline === 'mathematical') {
    yAdjust = font.ascent - font.xHeight
  } else if (details.dominantBaseline === 'middle') {
    yAdjust = font.ascent - font.xHeight / 2
  } else if (details.dominantBaseline === 'central') {
    yAdjust = font.ascent / 2 + font.descent / 2
  } else if (details.dominantBaseline === 'ideographic') {
    yAdjust = font.ascent + font.descent
  }

  return new Box(x + xAdjust, y - yAdjust / font.unitsPerEm * fontSize, width, height)
}

module.exports = { bbox }

},{"../class/Box":236,"./defaults":246,"fontkit":202,"path":11}],254:[function(require,module,exports){
var TINF_OK = 0;
var TINF_DATA_ERROR = -3;

function Tree() {
  this.table = new Uint16Array(16);   /* table of code length counts */
  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
}

function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  
  this.dest = dest;
  this.destLen = 0;
  
  this.ltree = new Tree();  /* dynamic length/symbol tree */
  this.dtree = new Tree();  /* dynamic distance tree */
}

/* --------------------------------------------------- *
 * -- uninitialized global data (static structures) -- *
 * --------------------------------------------------- */

var sltree = new Tree();
var sdtree = new Tree();

/* extra bits and base tables for length codes */
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);

/* extra bits and base tables for distance codes */
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);

/* special ordering of code length codes */
var clcidx = new Uint8Array([
  16, 17, 18, 0, 8, 7, 9, 6,
  10, 5, 11, 4, 12, 3, 13, 2,
  14, 1, 15
]);

/* used by tinf_decode_trees, avoids allocations every call */
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);

/* ----------------------- *
 * -- utility functions -- *
 * ----------------------- */

/* build extra bits and base tables */
function tinf_build_bits_base(bits, base, delta, first) {
  var i, sum;

  /* build bits table */
  for (i = 0; i < delta; ++i) bits[i] = 0;
  for (i = 0; i < 30 - delta; ++i) bits[i + delta] = i / delta | 0;

  /* build base table */
  for (sum = first, i = 0; i < 30; ++i) {
    base[i] = sum;
    sum += 1 << bits[i];
  }
}

/* build the fixed huffman trees */
function tinf_build_fixed_trees(lt, dt) {
  var i;

  /* build fixed length tree */
  for (i = 0; i < 7; ++i) lt.table[i] = 0;

  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;

  for (i = 0; i < 24; ++i) lt.trans[i] = 256 + i;
  for (i = 0; i < 144; ++i) lt.trans[24 + i] = i;
  for (i = 0; i < 8; ++i) lt.trans[24 + 144 + i] = 280 + i;
  for (i = 0; i < 112; ++i) lt.trans[24 + 144 + 8 + i] = 144 + i;

  /* build fixed distance tree */
  for (i = 0; i < 5; ++i) dt.table[i] = 0;

  dt.table[5] = 32;

  for (i = 0; i < 32; ++i) dt.trans[i] = i;
}

/* given an array of code lengths, build a tree */
var offs = new Uint16Array(16);

function tinf_build_tree(t, lengths, off, num) {
  var i, sum;

  /* clear code length count table */
  for (i = 0; i < 16; ++i) t.table[i] = 0;

  /* scan symbol lengths, and sum code length counts */
  for (i = 0; i < num; ++i) t.table[lengths[off + i]]++;

  t.table[0] = 0;

  /* compute offset table for distribution sort */
  for (sum = 0, i = 0; i < 16; ++i) {
    offs[i] = sum;
    sum += t.table[i];
  }

  /* create code->symbol translation table (symbols sorted by code) */
  for (i = 0; i < num; ++i) {
    if (lengths[off + i]) t.trans[offs[lengths[off + i]]++] = i;
  }
}

/* ---------------------- *
 * -- decode functions -- *
 * ---------------------- */

/* get one bit from source stream */
function tinf_getbit(d) {
  /* check if tag is empty */
  if (!d.bitcount--) {
    /* load next tag */
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }

  /* shift bit out of tag */
  var bit = d.tag & 1;
  d.tag >>>= 1;

  return bit;
}

/* read a num bit value from a stream and add base */
function tinf_read_bits(d, num, base) {
  if (!num)
    return base;

  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }

  var val = d.tag & (0xffff >>> (16 - num));
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}

/* given a data stream and a tree, decode a symbol */
function tinf_decode_symbol(d, t) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  
  var sum = 0, cur = 0, len = 0;
  var tag = d.tag;

  /* get more bits while code value is above sum */
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;

    sum += t.table[len];
    cur -= t.table[len];
  } while (cur >= 0);
  
  d.tag = tag;
  d.bitcount -= len;

  return t.trans[sum + cur];
}

/* given a data stream, decode dynamic trees from it */
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;

  /* get 5 bits HLIT (257-286) */
  hlit = tinf_read_bits(d, 5, 257);

  /* get 5 bits HDIST (1-32) */
  hdist = tinf_read_bits(d, 5, 1);

  /* get 4 bits HCLEN (4-19) */
  hclen = tinf_read_bits(d, 4, 4);

  for (i = 0; i < 19; ++i) lengths[i] = 0;

  /* read code lengths for code length alphabet */
  for (i = 0; i < hclen; ++i) {
    /* get 3 bits code length (0-7) */
    var clen = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i]] = clen;
  }

  /* build code length tree */
  tinf_build_tree(code_tree, lengths, 0, 19);

  /* decode code lengths for the dynamic trees */
  for (num = 0; num < hlit + hdist;) {
    var sym = tinf_decode_symbol(d, code_tree);

    switch (sym) {
      case 16:
        /* copy previous code length 3-6 times (read 2 bits) */
        var prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        /* repeat code length 0 for 3-10 times (read 3 bits) */
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        /* repeat code length 0 for 11-138 times (read 7 bits) */
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        /* values 0-15 represent the actual code lengths */
        lengths[num++] = sym;
        break;
    }
  }

  /* build dynamic trees */
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}

/* ----------------------------- *
 * -- block inflate functions -- *
 * ----------------------------- */

/* given a stream and two trees, inflate a block of data */
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);

    /* check for end of block */
    if (sym === 256) {
      return TINF_OK;
    }

    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs;
      var i;

      sym -= 257;

      /* possibly get more bits from length code */
      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

      dist = tinf_decode_symbol(d, dt);

      /* possibly get more bits from distance code */
      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

      /* copy match */
      for (i = offs; i < offs + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}

/* inflate an uncompressed block of data */
function tinf_inflate_uncompressed_block(d) {
  var length, invlength;
  var i;
  
  /* unread from bitbuffer */
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }

  /* get length */
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];

  /* get one's complement of length */
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

  /* check length */
  if (length !== (~invlength & 0x0000ffff))
    return TINF_DATA_ERROR;

  d.sourceIndex += 4;

  /* copy block */
  for (i = length; i; --i)
    d.dest[d.destLen++] = d.source[d.sourceIndex++];

  /* make sure we start next block on a byte boundary */
  d.bitcount = 0;

  return TINF_OK;
}

/* inflate stream from source to dest */
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;

  do {
    /* read final block flag */
    bfinal = tinf_getbit(d);

    /* read block type (2 bits) */
    btype = tinf_read_bits(d, 2, 0);

    /* decompress block */
    switch (btype) {
      case 0:
        /* decompress uncompressed block */
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        /* decompress block with fixed huffman trees */
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        /* decompress block with dynamic huffman trees */
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }

    if (res !== TINF_OK)
      throw new Error('Data error');

  } while (!bfinal);

  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === 'function')
      return d.dest.slice(0, d.destLen);
    else
      return d.dest.subarray(0, d.destLen);
  }
  
  return d.dest;
}

/* -------------------- *
 * -- initialization -- *
 * -------------------- */

/* build fixed huffman trees */
tinf_build_fixed_trees(sltree, sdtree);

/* build extra bits and base tables */
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);

/* fix a special case */
length_bits[28] = 0;
length_base[28] = 258;

module.exports = tinf_uncompress;

},{}],255:[function(require,module,exports){
module.exports={"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Tirhuta","Siddham","Modi","Takri","Ahom","Warang_Citi","Pau_Cin_Hau","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Miao","Duployan","SignWriting","Mende_Kikakui"],"eaw":["N","Na","A","W","H","F"]}
},{}],256:[function(require,module,exports){
(function (Buffer){
// Generated by CoffeeScript 1.9.1
var CATEGORY_BITS, CATEGORY_MASK, CATEGORY_SHIFT, COMBINING_BITS, COMBINING_MASK, COMBINING_SHIFT, EAW_BITS, EAW_MASK, EAW_SHIFT, NUMBER_BITS, NUMBER_MASK, SCRIPT_BITS, SCRIPT_MASK, SCRIPT_SHIFT, UnicodeTrie, bits, data, fs, log2, trie;

UnicodeTrie = require('unicode-trie');

data = require('./data.json');



trie = new UnicodeTrie(Buffer("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","base64"));

log2 = Math.log2 || function(n) {
  return Math.log(n) / Math.LN2;
};

bits = function(n) {
  return (log2(n) + 1) | 0;
};

CATEGORY_BITS = bits(data.categories.length - 1);

COMBINING_BITS = bits(data.combiningClasses.length - 1);

SCRIPT_BITS = bits(data.scripts.length - 1);

EAW_BITS = bits(data.eaw.length - 1);

NUMBER_BITS = 10;

CATEGORY_SHIFT = COMBINING_BITS + SCRIPT_BITS + EAW_BITS + NUMBER_BITS;

COMBINING_SHIFT = SCRIPT_BITS + EAW_BITS + NUMBER_BITS;

SCRIPT_SHIFT = EAW_BITS + NUMBER_BITS;

EAW_SHIFT = NUMBER_BITS;

CATEGORY_MASK = (1 << CATEGORY_BITS) - 1;

COMBINING_MASK = (1 << COMBINING_BITS) - 1;

SCRIPT_MASK = (1 << SCRIPT_BITS) - 1;

EAW_MASK = (1 << EAW_BITS) - 1;

NUMBER_MASK = (1 << NUMBER_BITS) - 1;

exports.getCategory = function(codePoint) {
  var val;
  val = trie.get(codePoint);
  return data.categories[(val >> CATEGORY_SHIFT) & CATEGORY_MASK];
};

exports.getCombiningClass = function(codePoint) {
  var val;
  val = trie.get(codePoint);
  return data.combiningClasses[(val >> COMBINING_SHIFT) & COMBINING_MASK];
};

exports.getScript = function(codePoint) {
  var val;
  val = trie.get(codePoint);
  return data.scripts[(val >> SCRIPT_SHIFT) & SCRIPT_MASK];
};

exports.getEastAsianWidth = function(codePoint) {
  var val;
  val = trie.get(codePoint);
  return data.eaw[(val >> EAW_SHIFT) & EAW_MASK];
};

exports.getNumericValue = function(codePoint) {
  var denominator, exp, num, numerator, val;
  val = trie.get(codePoint);
  num = val & NUMBER_MASK;
  if (num === 0) {
    return null;
  } else if (num <= 50) {
    return num - 1;
  } else if (num < 0x1e0) {
    numerator = (num >> 4) - 12;
    denominator = (num & 0xf) + 1;
    return numerator / denominator;
  } else if (num < 0x300) {
    val = (num >> 5) - 14;
    exp = (num & 0x1f) + 2;
    while (exp > 0) {
      val *= 10;
      exp--;
    }
    return val;
  } else {
    val = (num >> 2) - 0xbf;
    exp = (num & 3) + 1;
    while (exp > 0) {
      val *= 60;
      exp--;
    }
    return val;
  }
};

exports.isAlphabetic = function(codePoint) {
  var ref;
  return (ref = exports.getCategory(codePoint)) === 'Lu' || ref === 'Ll' || ref === 'Lt' || ref === 'Lm' || ref === 'Lo' || ref === 'Nl';
};

exports.isDigit = function(codePoint) {
  return exports.getCategory(codePoint) === 'Nd';
};

exports.isPunctuation = function(codePoint) {
  var ref;
  return (ref = exports.getCategory(codePoint)) === 'Pc' || ref === 'Pd' || ref === 'Pe' || ref === 'Pf' || ref === 'Pi' || ref === 'Po' || ref === 'Ps';
};

exports.isLowerCase = function(codePoint) {
  return exports.getCategory(codePoint) === 'Ll';
};

exports.isUpperCase = function(codePoint) {
  return exports.getCategory(codePoint) === 'Lu';
};

exports.isTitleCase = function(codePoint) {
  return exports.getCategory(codePoint) === 'Lt';
};

exports.isWhiteSpace = function(codePoint) {
  var ref;
  return (ref = exports.getCategory(codePoint)) === 'Zs' || ref === 'Zl' || ref === 'Zp';
};

exports.isBaseForm = function(codePoint) {
  var ref;
  return (ref = exports.getCategory(codePoint)) === 'Nd' || ref === 'No' || ref === 'Nl' || ref === 'Lu' || ref === 'Ll' || ref === 'Lt' || ref === 'Lm' || ref === 'Lo' || ref === 'Me' || ref === 'Mc';
};

exports.isMark = function(codePoint) {
  var ref;
  return (ref = exports.getCategory(codePoint)) === 'Mn' || ref === 'Me' || ref === 'Mc';
};

}).call(this,require("buffer").Buffer)
},{"./data.json":255,"buffer":4,"unicode-trie":257}],257:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var UnicodeTrie, inflate;

inflate = require('tiny-inflate');

UnicodeTrie = (function() {
  var DATA_BLOCK_LENGTH, DATA_GRANULARITY, DATA_MASK, INDEX_1_OFFSET, INDEX_2_BLOCK_LENGTH, INDEX_2_BMP_LENGTH, INDEX_2_MASK, INDEX_SHIFT, LSCP_INDEX_2_LENGTH, LSCP_INDEX_2_OFFSET, OMITTED_BMP_INDEX_1_LENGTH, SHIFT_1, SHIFT_1_2, SHIFT_2, UTF8_2B_INDEX_2_LENGTH, UTF8_2B_INDEX_2_OFFSET;

  SHIFT_1 = 6 + 5;

  SHIFT_2 = 5;

  SHIFT_1_2 = SHIFT_1 - SHIFT_2;

  OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> SHIFT_1;

  INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;

  INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;

  INDEX_SHIFT = 2;

  DATA_BLOCK_LENGTH = 1 << SHIFT_2;

  DATA_MASK = DATA_BLOCK_LENGTH - 1;

  LSCP_INDEX_2_OFFSET = 0x10000 >> SHIFT_2;

  LSCP_INDEX_2_LENGTH = 0x400 >> SHIFT_2;

  INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;

  UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;

  UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6;

  INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;

  DATA_GRANULARITY = 1 << INDEX_SHIFT;

  function UnicodeTrie(data) {
    var isBuffer, uncompressedLength, view;
    isBuffer = typeof data.readUInt32BE === 'function' && typeof data.slice === 'function';
    if (isBuffer || data instanceof Uint8Array) {
      if (isBuffer) {
        this.highStart = data.readUInt32BE(0);
        this.errorValue = data.readUInt32BE(4);
        uncompressedLength = data.readUInt32BE(8);
        data = data.slice(12);
      } else {
        view = new DataView(data.buffer);
        this.highStart = view.getUint32(0);
        this.errorValue = view.getUint32(4);
        uncompressedLength = view.getUint32(8);
        data = data.subarray(12);
      }
      data = inflate(data, new Uint8Array(uncompressedLength));
      data = inflate(data, new Uint8Array(uncompressedLength));
      this.data = new Uint32Array(data.buffer);
    } else {
      this.data = data.data, this.highStart = data.highStart, this.errorValue = data.errorValue;
    }
  }

  UnicodeTrie.prototype.get = function(codePoint) {
    var index;
    if (codePoint < 0 || codePoint > 0x10ffff) {
      return this.errorValue;
    }
    if (codePoint < 0xd800 || (codePoint > 0xdbff && codePoint <= 0xffff)) {
      index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    if (codePoint <= 0xffff) {
      index = (this.data[LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    if (codePoint < this.highStart) {
      index = this.data[(INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH) + (codePoint >> SHIFT_1)];
      index = this.data[index + ((codePoint >> SHIFT_2) & INDEX_2_MASK)];
      index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    return this.data[this.data.length - DATA_GRANULARITY];
  };

  return UnicodeTrie;

})();

module.exports = UnicodeTrie;

},{"tiny-inflate":254}],258:[function(require,module,exports){
// 3D Perlin noise implementation
// This code is in the public domain

function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }

function lerp(t, a, b) { return a + t * (b - a); }

function grad(hash, x, y, z) {
  const h = hash & 15;
  const u = h < 8 ? x : y;
  const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
  return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
}

module.exports = class PerlinNoise {
  constructor(rng) {
    this.permutation = [];
    for (let i = 0; i < 256; i++) this.permutation.push(i);

    for (let i = 256; i > 0; i--) {
      const randomIndex = Math.floor(rng() * i);
      const temporaryValue = this.permutation[i - 1];
      this.permutation[i - 1] = this.permutation[randomIndex];
      this.permutation[randomIndex] = temporaryValue;
    }

    for (let i = 0; i < 256; i++) this.permutation.push(this.permutation[i]);
  }

  noise(xi, yi, zi) {
    const X = Math.floor(xi) & 255;
    const Y = Math.floor(yi) & 255;
    const Z = Math.floor(zi) & 255;
    const x = xi - Math.floor(xi);
    const y = yi - Math.floor(yi);
    const z = zi - Math.floor(zi);
    const u = fade(x);
    const v = fade(y);
    const w = fade(z);
    const A = this.permutation[X] + Y;
    const AA = this.permutation[A] + Z;
    const AB = this.permutation[A + 1] + Z;
    const B = this.permutation[X + 1] + Y;
    const BA = this.permutation[B] + Z;
    const BB = this.permutation[B + 1] + Z;
    return (lerp(w, lerp(v, lerp(u, grad(this.permutation[AA], x, y, z),
      grad(this.permutation[BA], x - 1, y, z)),
    lerp(u, grad(this.permutation[AB], x, y - 1, z),
      grad(this.permutation[BB], x - 1, y - 1, z))),
    lerp(v, lerp(u, grad(this.permutation[AA + 1], x, y, z - 1),
      grad(this.permutation[BA + 1], x - 1, y, z - 1)),
    lerp(u, grad(this.permutation[AB + 1], x, y - 1, z - 1),
      grad(this.permutation[BB + 1], x - 1, y - 1, z - 1))))) + 0.5;
  }
};

},{}],259:[function(require,module,exports){
// Iterative Poisson disc sampler
// Based on this implementation: https://www.jasondavies.com/poisson-disc/
// This code is in the public domain

module.exports = function IterativePoissonDiscSampler(width, height, radius, rng) {
  const k = 30; // Maximum number of samples before rejection
  const radius2 = radius * radius;
  const R = 3 * radius2;
  const cellSize = radius * Math.SQRT1_2;
  const gridWidth = Math.ceil(width / cellSize);
  const gridHeight = Math.ceil(height / cellSize);
  const grid = new Array(gridWidth * gridHeight);
  const queue = [];
  let queueSize = 0;
  let sampleSize = 0;

  function far(x, y) {
    let i = Math.floor(x / cellSize);
    let j = Math.floor(y / cellSize);
    const i0 = Math.max(i - 2, 0);
    const j0 = Math.max(j - 2, 0);
    const i1 = Math.min(i + 3, gridWidth);
    const j1 = Math.min(j + 3, gridHeight);

    for (j = j0; j < j1; ++j) {
      const o = j * gridWidth;
      for (i = i0; i < i1; ++i) {
        if (grid[o + i]) {
          const dx = grid[o + i][0] - x;
          const dy = grid[o + i][1] - y;
          if (dx * dx + dy * dy < radius2) return false;
        }
      }
    }

    return true;
  }

  function sample(x, y) {
    const s = [x, y];
    queue.push(s);
    grid[gridWidth * Math.floor(y / cellSize) + Math.floor(x / cellSize)] = s;
    sampleSize++;
    queueSize++;
    return s;
  }

  return function iterate() {
    // Pick a random point for the first sample
    if (!sampleSize) return sample(rng() * width, rng() * height);

    // Pick a random existing sample and remove it from the queue.
    while (queueSize) {
      const i = Math.floor(rng() * queueSize);

      // Make a new candidate between [radius, 2 * radius] from the existing sample.
      for (let j = 0; j < k; ++j) {
        const a = 2 * Math.PI * rng();
        const r = Math.sqrt(rng() * R + radius2);
        const x = queue[i][0] + r * Math.cos(a);
        const y = queue[i][1] + r * Math.sin(a);

        // Reject candidates that are outside the allowed extent,
        // or closer than 2 * radius to any existing sample.
        if (x >= 0 && x < width && y >= 0 && y < height && far(x, y)) return sample(x, y);
      }

      queue[i] = queue[--queueSize];
      queue.length = queueSize;
    }
    return false;
  };
};

},{}],260:[function(require,module,exports){
// triangulator2 - SVG triangle art generator
// Copyright 2019 jackw01. Released under the MIT License (see LICENSE for details).

const svg = typeof window === 'undefined' ? require('svg.js')(require('svgdom')) : require('svg.js');
const seedrandom = require('seedrandom');
const delaunator = require('delaunator');
const chroma = require('chroma-js');
const IterativePoissonDiscSampler = require('./poissondisc.js');
const PerlinNoise = require('./perlin.js');

// Utility stuff
// Map value
function map(x, inMin, inMax, outMin, outMax) {
  return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
}

// Distance to closest edge of image, for x and y values normalized to (0, 1)
function edgeDist(x, y) {
  return Math.min(Math.min(x, 1 - x), Math.min(y, 1 - y)) * 2;
}

let rng = Math.random;
let noiseGenerator = new PerlinNoise(rng);

// triangulator2
const triangulator = {
  GridMode: { Square: 1, Triangle: 2, Poisson: 3, Override: 4 },
  // Must return a scalar from 0 to 1
  ColorFunction: {
    Horizontal: (x, y) => x,
    Vertical: (x, y) => y,
    DiagonalFromRight: (x, y) => (x + y) / 2,
    DiagonalFromLeft: (x, y) => (1 - x + y) / 2,
    RadialFromCenter: (x, y) => Math.hypot(x - 0.5, y - 0.5) * Math.sqrt(2) * 1.1,
    RadialFromBottom: (x, y) => Math.hypot(x - 0.5, y - 1.5) - 0.5,
    FromEdges: (x, y) => edgeDist(x, y) * 0.3 + (1 - Math.hypot(x - 0.5, y - 0.5) * Math.sqrt(2)) * 0.7,
    Noise: (sx, sy) => (x, y) => noiseGenerator.noise(x * sx, y * sy, 0),
  },
  // Must return a vector with x and y from 0 to 1 as an array and a direction value (-1 or 1)
  GradientFunction: {
    Random: (triangle, x, y) => {
      const i = Math.floor(rng() * 3);
      const p2 = triangle[(i + 1 + Math.floor(rng() * 2)) % 3];
      const vector = [p2[0] - triangle[i][0], p2[1] - triangle[i][1]];
      const gradientDirection = Math.sign(vector[0] * vector[1]);
      let gradientVector = vector.map(a => Math.abs(a));
      gradientVector = gradientVector.map(a => a / Math.max(...gradientVector));
      return { gradientVector, gradientDirection };
    },
  },
};

triangulator.generate = function generate(input) {
  const options = input || {
    svgInput: false,
    seed: Math.random(),
    width: 1920,
    height: 1080,
    gridMode: triangulator.GridMode.Poisson,
    gridOverridde: false,
    cellSize: 100,
    cellRandomness: 0.3,
    colorOverride: false,
    color: triangulator.ColorFunction.Vertical,
    colorPalette: ['#efee69', '#21313e'],
    colorRandomness: 0.0,
    quantizeSteps: 0,
    useGradient: false,
    gradient: triangulator.GradientFunction.Random,
    gradientNegativeFactor: 0.03,
    gradientPositiveFactor: 0.03,
    strokeColor: false,
    strokeWidth: false,
  };

  const gridOverdraw = 10;

  // Set up RNG
  rng = seedrandom(`${options.seed}`);
  noiseGenerator = new PerlinNoise(rng);

  // Generate points
  const points = [];
  const cellRandomnessLimit = options.cellRandomness * options.cellSize;
  if (options.gridMode === triangulator.GridMode.Square) {
    for (let y = -gridOverdraw;
      y < options.height + gridOverdraw + options.cellSize;
      y += options.cellSize) {
      for (let x = -gridOverdraw;
        x < options.width + gridOverdraw + options.cellSize;
        x += options.cellSize) {
        points.push([
          x + Math.floor(rng() * (2 * cellRandomnessLimit + 1)) - cellRandomnessLimit,
          y + Math.floor(rng() * (2 * cellRandomnessLimit + 1)) - cellRandomnessLimit,
        ]);
      }
    }
  } else if (options.gridMode === triangulator.GridMode.Triangle) {
    let r = 0;
    for (let x = -gridOverdraw;
      x < options.width + gridOverdraw + options.cellSize;
      x += options.cellSize) {
      for (let y = -gridOverdraw + options.cellSize / Math.sqrt(3) * (r % 2);
        y < options.height + gridOverdraw + options.cellSize;
        y += options.cellSize) {
        points.push([
          x + Math.floor(rng() * (2 * cellRandomnessLimit + 1)) - cellRandomnessLimit,
          y + Math.floor(rng() * (2 * cellRandomnessLimit + 1)) - cellRandomnessLimit,
        ]);
      }
      r++;
    }
  } else if (options.gridMode === triangulator.GridMode.Poisson) {
    const sample = IterativePoissonDiscSampler(1.5 * options.width, 1.5 * options.height,
      options.cellSize, rng);
    let nextPoint = sample();
    while (nextPoint) {
      points.push([nextPoint[0] - 0.25 * options.width, nextPoint[1] - 0.25 * options.height]);
      nextPoint = sample();
    }
  } else if (options.gridMode === triangulator.GridMode.Override) {
    points.push(...options.gridOverride);
  }

  // Triangulate
  const delaunay = delaunator.from(points);
  const trianglePoints = [];
  for (let i = 0; i < delaunay.triangles.length; i += 3) {
    trianglePoints.push([
      points[delaunay.triangles[i]], points[delaunay.triangles[i + 1]], points[delaunay.triangles[i + 2]],
    ]);
  }

  // Convert input colors to chroma.js scale
  const scale = chroma.scale(options.colorPalette).mode('hcl');

  // Create SVG context and draw
  const draw = svg(options.svgInput).size(options.width, options.height);

  trianglePoints.forEach((tri) => {
    // Find where the triangle's centroid lies on the gradient
    const normX = map(tri.reduce((a, b) => a + b[0], 0) / 3, 0, options.width, 0, 1);
    const normY = map(tri.reduce((a, b) => a + b[1], 0) / 3, 0, options.height, 0, 1);

    // Get color/gradient for triangle
    let color;

    if (!options.colorOverride) {
      // Determine where the color lies on the scale - quantize if necessary
      let colorIndex = options.color(normX, normY) + (rng() - 0.5) * options.colorRandomness;
      if (options.quantizeSteps) {
        colorIndex = Math.round(colorIndex * options.quantizeSteps) / (options.quantizeSteps - 1);
      }

      if (!options.useGradient) { // Use solid color
        color = scale(colorIndex).hex();
      } else { // Generate gradient vector and direction
        const { gradientVector, gradientDirection } = options.gradient(tri, normX, normY);
        color = draw.gradient('linear', (stop) => {
          stop.at(0, scale(colorIndex - options.gradientNegativeFactor * gradientDirection).hex());
          stop.at(1, scale(colorIndex + options.gradientPositiveFactor * gradientDirection).hex());
        }).from(0.0, 0.0).to(...gradientVector);
      }
    } else {
      color = options.colorOverride(normX, normY);
    }

    draw.polygon(tri.map(p => p.join(',')).join(' '))
      .fill(color).stroke({ color: options.strokeColor || color, width: options.strokeWidth || 1 });
  });

  return draw.svg();
};

module.exports = triangulator;

},{"./perlin.js":258,"./poissondisc.js":259,"chroma-js":72,"delaunator":200,"seedrandom":227,"svg.js":235,"svgdom":243}],261:[function(require,module,exports){
const triangulator = require('../src/triangulator.js');

window.onload = () => {
  const svgString = triangulator.generate({
    svgInput: 'drawing',
    seed: 4,
    width: 3840,
    height: 2160,
    gridMode: triangulator.GridMode.Poisson,
    gridOverride: false,
    cellSize: 150,
    cellRandomness: 0.2,
    colorOverride: false,
    color: triangulator.ColorFunction.RadialFromBottom,
    colorPalette: ['#e7a71d', '#dc433e', '#9e084b', '#41062f'],
    colorRandomness: 0.15,
    quantizeSteps: 0,
    useGradient: true,
    gradient: triangulator.GradientFunction.Random,
    gradientNegativeFactor: 0.03,
    gradientPositiveFactor: 0.03,
    strokeColor: false,
    strokeWidth: 1,
  });

  console.log(svgString);
};

},{"../src/triangulator.js":260}]},{},[261]);
